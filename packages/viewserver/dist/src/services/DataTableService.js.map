{
  "version": 3,
  "sources": ["../../../src/services/DataTableService.ts"],
  "sourcesContent": ["import Table from './Table.js';\nimport Subscription from './Subscription.js';\nimport { uuid } from '@heswell/server-core';\n\nconst _tables = {};\nvar _subscriptions = {};\nvar _client_subscriptions = {};\nconst _queued_subscriptions = {};\n\n// TODO unify these with DataTypes\nconst DataType = {\n  Rowset: 'rowset',\n  Update: 'update',\n  Snapshot: 'snapshot',\n  FilterData: 'filterData',\n  SearchData: 'searchData',\n  Selected: 'selected'\n};\n\n// need an API call to expose tables so extension services can manipulate data\n\nexport const configure = ({ DataTables }) =>\n  Promise.all(DataTables.map(async (config) => await createTable(config)));\n\nasync function createTable({ dataPath, ...config }) {\n  const { name: tablename } = config;\n  const table = (_tables[tablename] = new Table(config));\n\n  if (dataPath) {\n    await table.loadData(dataPath);\n  }\n\n  const qs = _queued_subscriptions[tablename];\n  if (qs) {\n    console.log(`Table ${tablename} created and we have queued Subscription(s)}`);\n    _queued_subscriptions[tablename] = undefined;\n    qs.forEach(({ clientId, request, queue }) => {\n      console.log(`Add Queued Subscription clientId:${clientId}`);\n      AddSubscription(clientId, request, queue);\n    });\n  }\n\n  return table;\n}\n\nexport function GET_TABLE_LIST(sessionId, requestId, request, queue) {\n  const tables = getTableNames();\n  console.log(`received GET_TABLE_LIST request, requestId ${requestId} tables are ${tables}`);\n\n  queue.push({\n    requestId,\n    sessionId,\n    token: 'poo',\n    user: 'user',\n    priority: 1,\n    body: {\n      requestId,\n      type: 'TABLE_LIST_RESP',\n      tables: tables.map((table) => ({ table, module: 'SIMUL' }))\n    }\n  });\n}\n\nexport function GET_TABLE_META(sessionId, requestId, request, queue) {\n  const table = getTable(request.table.table);\n\n  queue.push({\n    requestId,\n    sessionId,\n    token: 'poo',\n    user: 'user',\n    priority: 1,\n    body: {\n      requestId,\n      type: 'TABLE_META_RESP',\n      columns: table.columns.map((col) => col.name),\n      dataTypes: table.columns.map((col) => col.type?.name ?? col.type ?? 'string'),\n      table: request.table\n    }\n  });\n}\n\nexport function CREATE_VP(sessionId, requestId, request, queue) {\n  const {\n    table: { table: tableName }\n  } = request;\n  const table = _tables[tableName];\n  if (table.status === 'ready') {\n    const viewportId = uuid();\n    console.log(\n      `subscribe to ${tableName}, table is ready ${JSON.stringify(\n        request\n      )}, viewport id will be ${viewportId}`\n    );\n    _subscriptions[viewportId] = Subscription(table, viewportId, request, queue);\n    let clientSubscriptions =\n      _client_subscriptions[sessionId] || (_client_subscriptions[sessionId] = []);\n    clientSubscriptions.push(request.viewport);\n  } else {\n    const qs = _queued_subscriptions;\n    const q = qs[tablename] || (qs[tablename] = []);\n    q.push({ sessionId, request, queue });\n    console.log(`queued subscriptions for ${tablename} = ${q.length}`);\n  }\n}\n\nexport function unsubscribeAll(clientId, queue) {\n  const subscriptions = _client_subscriptions[clientId];\n  if (subscriptions && subscriptions.length) {\n    subscriptions.forEach((viewport) => {\n      const subscription = _subscriptions[viewport];\n      subscription.cancel();\n      delete _subscriptions[viewport];\n      queue.purgeViewport(viewport);\n    });\n    delete _client_subscriptions[clientId];\n  }\n}\n\nexport function TerminateSubscription(clientId, request, queue) {\n  const { viewport } = request;\n  _subscriptions[viewport].cancel();\n  delete _subscriptions[viewport];\n  // purge any messages for this viewport from the messageQueue\n  _client_subscriptions[clientId] = _client_subscriptions[clientId].filter((vp) => vp !== viewport);\n  if (_client_subscriptions[clientId].length === 0) {\n    delete _client_subscriptions[clientId];\n  }\n  queue.purgeViewport(viewport);\n}\n\n// SuspendSubscription\n// ResumeSUbscription\n// TerminateAllSubscriptionsForClient\n\nexport function ModifySubscription(clientId, request, queue) {\n  _subscriptions[request.viewport].update(request, queue);\n}\n\nexport function ExpandGroup(clientId, request, queue) {\n  _subscriptions[request.viewport].update(request, queue);\n}\n\nexport function CollapseGroup(clientId, request, queue) {\n  _subscriptions[request.viewport].update(request, queue);\n}\n\nexport function GetTableMeta(clientId, request, queue) {\n  const { requestId } = request;\n  const table = getTable(request.table);\n\n  queue.push({\n    priority: 1,\n    requestId,\n    type: 'column-list',\n    table: table.name,\n    key: 'Symbol',\n    columns: table.columns\n  });\n}\n\nexport function setViewRange(clientId, request, queue) {\n  const { viewport, range, useDelta = true, dataType } = request;\n  //TODO this can be standardised\n  const type =\n    dataType === 'rowData'\n      ? DataType.Rowset\n      : dataType === 'filterData'\n      ? DataType.FilterData\n      : dataType === 'searchData'\n      ? DataType.SearchData\n      : null;\n  // should be purge the queue of any pending updates outside the requested range ?\n\n  const now = new Date().getTime();\n  console.log(' ');\n  console.log(`[${now}] DataTableService: setRange ${range.lo} - ${range.hi}`);\n\n  _subscriptions[viewport].invoke('setRange', queue, type, range, useDelta, dataType);\n}\n\nexport function sort(clientId, { viewport, sortCriteria }, queue) {\n  _subscriptions[viewport].invoke('sort', queue, DataType.Snapshot, sortCriteria);\n}\n\nexport function filter(clientId, { viewport, filter, incremental, dataType }, queue) {\n  _subscriptions[viewport].invoke('filter', queue, dataType, filter, dataType, incremental);\n}\n\nexport function select(\n  clientId,\n  { viewport, idx, rangeSelect, keepExistingSelection, dataType },\n  queue\n) {\n  _subscriptions[viewport].invoke(\n    'select',\n    queue,\n    DataType.Selected,\n    idx,\n    rangeSelect,\n    keepExistingSelection,\n    dataType\n  );\n}\n\nexport function selectAll(clientId, { viewport, dataType }, queue) {\n  _subscriptions[viewport].invoke('selectAll', queue, DataType.Selected, dataType);\n}\n\nexport function selectNone(clientId, { viewport, dataType }, queue) {\n  _subscriptions[viewport].invoke('selectNone', queue, DataType.Selected, dataType);\n}\n\nexport function groupBy(clientId, { viewport, groupBy }, queue) {\n  _subscriptions[viewport].invoke('groupBy', queue, DataType.Snapshot, groupBy);\n}\n\nexport function setGroupState(clientId, { viewport, groupState }, queue) {\n  _subscriptions[viewport].invoke('setGroupState', queue, DataType.Rowset, groupState);\n}\n\nexport function GetFilterData(clientId, { viewport, column, searchText, range }, queue) {\n  // TODO what about range ?\n  _subscriptions[viewport].invoke(\n    'getFilterData',\n    queue,\n    DataType.FilterData,\n    column,\n    searchText,\n    range\n  );\n}\n\nexport function InsertTableRow(clientId, request, queue) {\n  const tableHelper = getTable(request.tablename);\n  tableHelper.table.insert(request.row);\n  console.warn(`InsertTableRow TODO send confirmation ${queue.length}`);\n}\n\nfunction getTable(name) {\n  if (_tables[name]) {\n    return _tables[name];\n  } else {\n    throw Error(`DataTableService. no table definition for ${name}`);\n  }\n}\n\nfunction getTableNames() {\n  return Object.keys(_tables);\n}\n"],
  "mappings": "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",
  "names": ["tablename", "filter", "groupBy"]
}
