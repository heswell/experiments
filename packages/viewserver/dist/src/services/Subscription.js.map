{
  "version": 3,
  "sources": ["../../../src/services/Subscription.ts"],
  "sourcesContent": ["import {DataView as View, columnUtils, DataTypes} from '@heswell/data';\n\n//TODO implement as class\nexport default function Subscription (table, viewportId, {requestId, ...options}, queue){\n\n    const {columns: requestedColumns, filterSpec, groupBy, range, sort} = options;\n    const {name: tablename, columns: availableColumns} = table;\n    const columns = requestedColumns.length > 0\n        ? requestedColumns\n        : availableColumns;\n\n    let view = new View(table, {columns, filterSpec, groupBy, sort});\n    let timeoutHandle;\n\n    const tableMeta = columnUtils.metaData(columns);\n\n    console.log(`Subscription ${tablename} ${JSON.stringify(options,null,2)} table.status ${table.status} view.status ${view.status}`)\n\n    queue.push({\n        requestId,\n        sessionId: '',\n        token: '',\n        user: '',\n        body: {\n        table: tablename,\n        type: 'CREATE_VP_SUCCESS',\n        tablename,\n        columns,\n        size: view.size,\n        offset: view.offset,\n        viewportId,\n        }\n    });\n\n    if (view.status === 'ready'){\n        const data = view.setRange(range);\n        if (data.rows.length){\n            console.log(`initial set of data returned immediately on Subscription ${JSON.stringify(range)} (${data.rows.length} rows)`);\n            queue.push({\n                viewport: viewport,\n                type: 'snapshot',\n                data\n            });\n        }\n    }\n\n    function collectUpdates(){\n        let {updates, range} = view.updates;\n        // TODO will we ever get updates for FilterData ? If se we will need correct mats\n        // depending on the batch type there will be one of \n        // updates, rows or size. The others will be \n        // undefined and therefore not survive json serialization.\n        updates.forEach(batch => {\n            const {type, updates, rows, size, offset} = batch;\n            if (type === 'rowset'){\n                queue.push({\n                    priority: 2,\n                    viewport: viewport,\n                    type,\n                    tablename,\n                    data: {\n                        rows,\n                        size,\n                        offset,\n                        range\n                    }\n                }, tableMeta);\n    \n            } else {\n                queue.push({\n                    priority: 2,\n                    viewport: viewport,\n                    type,\n                    tablename,\n                    updates,\n                    rows,\n                    size,\n                    offset,\n                    range\n                }, tableMeta);\n            }\n        });\n\n\n        timeoutHandle = setTimeout(collectUpdates, 100);\n    }\n\n    timeoutHandle = setTimeout(collectUpdates, 1000);\n\n    return Object.create(null,{\n\n        invoke: {\n            value: (method, queue, type, ...params) => {\n                let data, filterData;\n\n                if (method === 'filter'){\n                    [data, ...filterData] = view[method](...params);\n                } else {\n                    data = view[method](...params);\n                }\n                const meta = type === DataTypes.FILTER_DATA\n                    ? columnUtils.setFilterColumnMeta\n                    : tableMeta \n\n                if (data){\n                    queue.push({\n                        priority: 1,\n                        viewport,\n                        type,\n                        data\n                    }, meta);\n                }\n\n                filterData && filterData.forEach(data => {\n                    queue.push({\n                        priority: 1,\n                        viewport,\n                        type: DataTypes.FILTER_DATA,\n                        data\n                    }, columnUtils.setFilterColumnMeta);\n\n                });\n            }\n        },\n\n        // A client update request is handled with a synchronous call to view.rows\n        update: {value: (options, queue) => {\n\n            const {range, ...dataOptions} = options;\n            \n            queue.push({\n                priority: 1,\n                viewport: viewport, \n                type: 'rowset',\n                tablename,\n                data: {\n                    rows: view.rows(range, options),\n                    size: view.size,\n                    offset: view.offset\n                }\n            });\n\n        }},\n\n        cancel: {value : () => {\n\n            if (timeoutHandle){\n                clearTimeout(timeoutHandle);\n                timeoutHandle = null;\n            }\n            view.destroy();\n            view = null;\n        }}\n\n    });\n\n}"],
  "mappings": "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",
  "names": ["range", "updates", "queue", "data", "options"]
}
