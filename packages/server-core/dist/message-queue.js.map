{
  "version": 3,
  "sources": ["../src/message-queue.ts"],
  "sourcesContent": ["\nimport { rangeUtils, DataTypes } from '@heswell/data';\n\nconst EMPTY_ARRAY = [];\nconst ROWSET = 'rowset';\nconst UPDATE = 'update';\nconst FILTER_DATA = 'filterData';\n\nexport default class MessageQueue {\n\n    constructor() {\n        this._queue = [];\n    }\n\n    get length() { return this._queue.length; }\n    set length(val) { this._queue.length = val; }\n    get queue() {\n        const q = this._queue.slice();\n        this._queue.length = 0;\n        return q;\n    }\n\n    push(message, meta) {\n        const { type, data } = message;\n        if (type === UPDATE) {\n            mergeAndPurgeUpdates(this._queue, message);\n        } else if (type === ROWSET) {\n            if (message.data.rows.length === 0 && message.size > 0) {\n                return;\n            }\n            mergeAndPurgeRowset(this._queue, message, meta);\n\n        } else if (type === FILTER_DATA && data.type !== DataTypes.FILTER_BINS) {\n            mergeAndPurgeFilterData(this._queue, message, meta);\n        } else {\n            //onsole.log(`MessageQueue ${type} `);\n        }\n        if (message.type === 'rowset'){\n            console.log(`[${Date.now()}] message queue push message ${JSON.stringify(message.data.range)}`)\n        }\n        this._queue.push(message);\n\n    }\n\n    purgeViewport(viewport) {\n        this._queue = this._queue.filter(batch => batch.viewport !== viewport);\n    }\n\n    // currentRange(){\n    //     for (let i = 0; i<this._queue.length; i++){\n    //         const message = this._queue[i];\n    //         const {data} = message;\n    //         if (data){\n    //             console.log(`message-queue.currentRange ${message.type} ${JSON.stringify(data.range)}`)\n    //         }\n    //     }\n    // }\n\n    extract(test) {\n        if (this._queue.length === 0) {\n            return EMPTY_ARRAY;\n        } else {\n            return extractMessages(this._queue, test);\n        }\n    }\n\n    extractAll(){\n        const messages = this._queue.slice();\n        this._queue.length = 0;\n        return messages;\n    }\n}\n\n\n// This purges redundant messages from the queue and merges their data into the new message. \n// AN unintended consequence of this might be that data slips down the queue, as the new \n// message is added at the back of the queue - INVESTIGATE.\nfunction mergeAndPurgeFilterData(queue, message, meta) {\n    const {IDX} = meta;\n    const { viewport, data: filterData } = message;\n    const { range } = filterData;\n    const { lo, hi } = rangeUtils.getFullRange(range);\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        let { type, viewport: vp, data } = queue[i];\n\n        if (vp === viewport && type === FILTER_DATA) {\n\n            var { lo: lo1, hi: hi1 } = rangeUtils.getFullRange(queue[i].data.range);\n\n            /*if ((lo1 === 0 && hi1 === 0 && lo === 0) ||\n                (lo1 >= hi || hi1 < lo)) {\n                    // nothing to do\n                }\n            else {\n*/\n                var overlaps = data.rows.filter(\n                    row => row[IDX] >= lo && row[IDX] < hi);\n\n\n                if (lo < lo1) {\n                    message.data = {\n                        ...message.data,\n                        rows: filterData.rows.concat(overlaps)\n                    };\n                }\n                else {\n                    message.data = {\n                        ...message.data,\n                        rows: overlaps.concat(filterData.rows)\n                    };\n                }\n\n            // }\n            queue.splice(i, 1);\n        }\n    }\n}\n\n// we need to know the current range in order to be able to merge rowsets which are still valid\nfunction mergeAndPurgeRowset(queue, message, meta) {\n    const { viewport, data: { rows, size, range, offset=0 } } = message;\n    const { lo, hi } = rangeUtils.getFullRange(range);\n    const low = lo + offset;\n    const high = hi + offset;\n\n    if (rows.length === 0){\n        console.log(`MESSAGE PUSHED TO MESAGEQ WITH NO ROWS`);\n        return;\n    }\n\n    const {IDX} = meta;\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        let { type, viewport: vp, data } = queue[i];\n\n        if (vp === viewport) {\n\n            if (type === ROWSET) { // snapshot. filterData, searchData \n\n                var { range: { lo: lo1, hi: hi1 } } = queue[i].data;\n\n                if (lo1 >= hi || hi1 < lo) {\n                    // no overlap, purge the message\n                }\n                else {\n                    var overlaps = data.rows.filter(\n                        row => row[IDX] >= low && row[IDX] < high);\n\n                    if (lo < lo1) {\n                        message.data.rows = rows.concat(overlaps);\n                    }\n                    else {\n                        message.data.rows = overlaps.concat(rows);\n                    }\n                }\n                queue.splice(i, 1);\n            }\n            else if (type === UPDATE) {\n                // if we have updates for rows within the current rowset, discard them - the rowset\n                // represents latest data.\n                let validUpdates = queue[i].updates.filter(u => {\n                    let idx = u[IDX];\n\n                    if (typeof rows[IDX] === 'undefined') {\n                        console.warn(`MessageQueue:about to error, these are the rows that have been passed `);\n                        console.warn(`[${rows.map(r => r[IDX]).join(',')}]`);\n                    }\n\n\n                    let min = rows[0][IDX];\n                    let max = rows[rows.length - 1][IDX];\n\n                    return idx >= low && idx < high &&   \t// within range \n                        idx < size &&  \t\t\t\t// within dataset  \n                        (idx < min || idx >= max); \t\t// NOT within new rowset \n                });\n\n                if (validUpdates.length) {\n                    queue[i].updates = validUpdates;\n                }\n                else {\n                    //onsole.log(`MessageQueue:purging updates that are no longer applicable`);\n                    queue.splice(i, 1);\n                }\n            }\n\n\n        }\n    }\n}\n\n// we need to know the current range in order to be able to merge rowsets which are still valid\nfunction mergeAndPurgeUpdates(queue, message) {\n\n    //onsole.log(`mergeAndPurge: update message ${JSON.stringify(message)}` );\n\n    var { viewport, range: { lo, hi } } = message;\n\n    //onsole.log(`mergeAndPurge: update message ${lo} - ${hi}   ${JSON.stringify(queue)}` );\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        if (queue[i].type === message.type && queue[i].viewport === viewport) {\n\n            //onsole.log(`we have a match for an update ${i} of ${queue.length}   ${JSON.stringify(queue[i].updates)}`)\n\n            var { lo: lo1, hi: hi1 } = queue[i].updates;\n\n            if (lo1 >= hi || hi1 < lo) {\n                // no overlap, purge the message\n            }\n            else {\n                // merge updates for same row(s)\n                //console.log(`mergeAndPurgeUpdates ${JSON.stringify(queue[i])} ${JSON.stringify(message.updates)}`)\n            }\n            console.log(`merging rowset current range [${lo},${hi}] [${queue[i].rows.lo},${queue[i].rows.hi}]`);\n            queue.splice(i, 1);\n        }\n    }\n}\n\nfunction extractMessages(queue, test) {\n    var extract = [];\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n        if (test(queue[i])) {\n            extract.push(queue.splice(i, 1)[0]);\n        }\n    }\n\n    extract.reverse();\n    return extract;\n}\n\n\nconst formatMessage = msg => ` type: ${msg.type} \n    rows: [${msg.data && msg.data.rows && msg.data.rows.map(row => row[7])}]`;\n"],
  "mappings": "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",
  "names": []
}
