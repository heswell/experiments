{"version":3,"file":"index.js","sources":["../src/requestHandlers.js","../../utils/dist/index.es.js","../../data/dist/index.es.js","../src/message-queue.js","../src/updateLoop.js","../src/handlers/viewserverRequestHandler.js","../src/server.js"],"sourcesContent":["/* global require:false */\n\nconst services = {};\nconst serviceAPI = {};\n\nexport function configure(config){\n\n    console.log(`requestHandler.configure ${JSON.stringify(config,null,2)}`)\n\n    config.services.forEach(async ({name, module, API}) => {\n        console.log(`about to import ${module}`)\n        const service = await import(module);\n        services[name] = service;\n        API.forEach(messageType => serviceAPI[messageType] = name);\n        console.log(`configure service ${name} `)\n        service.configure(config);\n    });\n\n}\n\nexport function findHandler(type){\n    const serviceName = serviceAPI[type];\n    if (serviceName){\n        return services[serviceName][type];\n    }\n}\n\nexport function killSubscriptions(clientId, queue){\n    Object.keys(services).forEach(name => {\n        const killSubscription = services[name]['unsubscribeAll']\n        if (killSubscription){\n            killSubscription(clientId, queue);\n        }\n    })\n\n}\n","const MAX_LISTENERS = 10;\n\nclass EventEmitter {\n\n    constructor() {\n        this._events = {};\n        this._maxListeners = MAX_LISTENERS;\n    }\n\n    addListener(type, listener) {\n        let m;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (this._events.newListener) {\n            this.emit('newListener', type, listener);\n        }\n\n        if (!this._events[type]) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        } else if (Array.isArray(this._events[type])) {\n            // If we've already got an array, just append.\n            this._events[type].push(listener);\n        } else {\n            // Adding the second element, need to change to array.\n            this._events[type] = [this._events[type], listener];\n        }\n\n        // Check for listener leak\n        if (Array.isArray(this._events[type]) && !this._events[type].warned) {\n            if (!isUndefined(this._maxListeners)) {\n                m = this._maxListeners;\n            } else {\n                m = MAX_LISTENERS;\n            }\n\n            if (m && m > 0 && this._events[type].length > m) {\n                this._events[type].warned = true;\n                console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                this._events[type].length);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeListener(type, listener) {\n        let list, position, length, i;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events || !this._events[type]) {\n            return this;\n        }\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n\n        } else if (Array.isArray(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0) {\n                return this;\n            }\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeAllListeners(type) {\n\n        if (!this._events) {\n            return this;\n        }\n\n        const listeners = this._events[type];\n\n        if (isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else if (listeners) {\n            // LIFO order\n            while (listeners.length) {\n                this.removeListener(type, listeners[listeners.length - 1]);\n            }\n        }\n        delete this._events[type];\n\n        return this;\n\n    }\n\n    emit(type, ...args) {\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // If there is no 'error' event listener then throw.\n        if (type === 'error') {\n            if (!this._events.error ||\n                (isObject(this._events.error) && !this._events.error.length)) {\n                const err = arguments[1];\n                if (err instanceof Error) {\n                    throw err; // Unhandled 'error' event\n                } else {\n                    // At least give some kind of context to the user\n                    throw new Error('Uncaught, unspecified \"error\" event. (' + err + ')');\n                }\n            }\n        }\n\n        const handler = this._events[type];\n\n        if (isUndefined(handler)) {\n            return false;\n        }\n\n        if (isFunction(handler)) {\n            switch (args.length) {\n                // fast cases\n                case 0:\n                    handler.call(this);\n                    break;\n                case 1:\n                    handler.call(this, type, args[0]);\n                    break;\n                case 2:\n                    handler.call(this, type, args[0], args[1]);\n                    break;\n                // slower\n                default:\n                    handler.call(this, type, ...args);\n            }\n        } else if (Array.isArray(handler)) {\n            handler.slice().forEach(listener => listener.call(this, type, ...args));\n        }\n\n        return true;\n\n    }\n\n    once(type, listener) {\n\n        const handler = (evtName, message) => {\n            this.removeListener(evtName, handler);\n            listener(evtName, message);\n        };\n\n        this.on(type, handler);\n\n    }\n\n    on(type, listener) {\n        return this.addListener(type, listener);\n    }\n\n}\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\n\nconst logColor = {\n  plain : 'color: black; font-weight: normal',\n  blue : 'color: blue; font-weight: bold',\n  brown : 'color: brown; font-weight: bold',\n  green : 'color: green; font-weight: bold',\n};\n\nconst {plain} = logColor;\nconst createLogger = (source, labelColor=plain, msgColor=plain) => ({\n  log: (msg, args='') => console.log(`[${Date.now()}]%c[${source}] %c${msg}`,labelColor, msgColor, args),\n  warn: (msg) => console.warn(`[${source}] ${msg}`)\n});\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar uuid = createCommonjsModule(function (module) {\n/*!\n**  Pure-UUID -- Pure JavaScript Based Universally Unique Identifier (UUID)\n**  Copyright (c) 2004-2019 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  Universal Module Definition (UMD)  */\n(function (root, name, factory) {\n    /* global define: false */\n    /* global module: false */\n    {\n        /*  CommonJS environment  */\n        module.exports = factory(root);\n        module.exports[\"default\"] = module.exports;\n    }\n}(commonjsGlobal, \"UUID\", function (/* root */) {\n\n    /*  array to hex-string conversion  */\n    var a2hs = function (bytes, begin, end, uppercase, str, pos) {\n        var mkNum = function (num, uppercase) {\n            var base16 = num.toString(16);\n            if (base16.length < 2)\n                base16 = \"0\" + base16;\n            if (uppercase)\n                base16 = base16.toUpperCase();\n            return base16;\n        };\n        for (var i = begin; i <= end; i++)\n            str[pos++] = mkNum(bytes[i], uppercase);\n        return str;\n    };\n\n    /*  hex-string to array conversion  */\n    var hs2a = function (str, begin, end, bytes, pos) {\n        for (var i = begin; i <= end; i += 2)\n            bytes[pos++] = parseInt(str.substr(i, 2), 16);\n    };\n\n    /*  This library provides Z85: ZeroMQ's Base-85 encoding/decoding\n        (see http://rfc.zeromq.org/spec:32 for details)  */\n\n    var z85_encoder = (\n        \"0123456789\" +\n         \"abcdefghijklmnopqrstuvwxyz\" +\n         \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n         \".-:+=^!/*?&<>()[]{}@%$#\"\n    ).split(\"\");\n    var z85_decoder = [\n        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,\n        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,\n        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,\n        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,\n        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,\n        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00\n    ];\n    var z85_encode = function (data, size) {\n        if ((size % 4) !== 0)\n            throw new Error(\"z85_encode: invalid input length (multiple of 4 expected)\");\n        var str = \"\", i = 0, value = 0;\n        while (i < size) {\n            value = (value * 256) + data[i++];\n            if ((i % 4) === 0) {\n                var divisor = 85 * 85 * 85 * 85;\n                while (divisor >= 1) {\n                    var idx = Math.floor(value / divisor) % 85;\n                    str += z85_encoder[idx];\n                    divisor /= 85;\n                }\n                value = 0;\n             }\n        }\n        return str;\n    };\n    var z85_decode = function (str, dest) {\n        var l = str.length;\n        if ((l % 5) !== 0)\n            throw new Error(\"z85_decode: invalid input length (multiple of 5 expected)\");\n        if (typeof dest === \"undefined\")\n            dest = new Array(l * 4 / 5);\n        var i = 0, j = 0, value = 0;\n        while (i < l) {\n            var idx = str.charCodeAt(i++) - 32;\n            if (idx < 0 || idx >= z85_decoder.length)\n                break;\n            value = (value * 85) + z85_decoder[idx];\n            if ((i % 5) === 0) {\n                var divisor = 256 * 256 * 256;\n                while (divisor >= 1) {\n                    dest[j++] = Math.trunc((value / divisor) % 256);\n                    divisor /= 256;\n                }\n                value = 0;\n            }\n        }\n        return dest;\n    };\n\n    /*  This library provides conversions between 8/16/32-bit character\n        strings and 8/16/32-bit big/little-endian word arrays.  */\n\n    /*  string to array conversion  */\n    var s2a = function (s, _options) {\n        /*  determine options  */\n        var options = { ibits: 8, obits: 8, obigendian: true };\n        for (var opt in _options)\n            if (typeof options[opt] !== \"undefined\")\n                options[opt] = _options[opt];\n\n        /*  convert string to array  */\n        var a = [];\n        var i = 0;\n        var c, C;\n        var ck = 0;\n        var w;\n        var wk = 0;\n        var sl = s.length;\n        for (;;) {\n            /*  fetch next octet from string  */\n            if (ck === 0)\n                C = s.charCodeAt(i++);\n            c = (C >> (options.ibits - (ck + 8))) & 0xFF;\n            ck = (ck + 8) % options.ibits;\n\n            /*  place next word into array  */\n            if (options.obigendian) {\n                if (wk === 0) w  = (c <<  (options.obits - 8));\n                else          w |= (c << ((options.obits - 8) - wk));\n            }\n            else {\n                if (wk === 0) w  = c;\n                else          w |= (c << wk);\n            }\n            wk = (wk + 8) % options.obits;\n            if (wk === 0) {\n                a.push(w);\n                if (i >= sl)\n                    break;\n            }\n        }\n        return a;\n    };\n\n    /*  array to string conversion  */\n    var a2s = function (a, _options) {\n        /*  determine options  */\n        var options = { ibits: 32, ibigendian: true };\n        for (var opt in _options)\n            if (typeof options[opt] !== \"undefined\")\n                options[opt] = _options[opt];\n\n        /* convert array to string */\n        var s = \"\";\n        var imask = 0xFFFFFFFF;\n        if (options.ibits < 32)\n            imask = (1 << options.ibits) - 1;\n        var al = a.length;\n        for (var i = 0; i < al; i++) {\n            /* fetch next word from array */\n            var w = a[i] & imask;\n\n            /* place next octet into string */\n            for (var j = 0; j < options.ibits; j += 8) {\n                if (options.ibigendian)\n                    s += String.fromCharCode((w >> ((options.ibits - 8) - j)) & 0xFF);\n                else\n                    s += String.fromCharCode((w >> j) & 0xFF);\n            }\n        }\n        return s;\n    };\n\n    /*  this is just a really minimal UI64 functionality,\n        just sufficient enough for the UUID v1 generator and PCG PRNG!  */\n\n    /*  UI64 constants  */\n    var UI64_DIGITS     = 8;    /* number of digits */\n    var UI64_DIGIT_BITS = 8;    /* number of bits in a digit */\n    var UI64_DIGIT_BASE = 256;  /* the numerical base of a digit */\n\n    /*  convert between individual digits and the UI64 representation  */\n    var ui64_d2i = function (d7, d6, d5, d4, d3, d2, d1, d0) {\n        return [ d0, d1, d2, d3, d4, d5, d6, d7 ];\n    };\n\n    /*  the zero represented as an UI64  */\n    var ui64_zero = function () {\n        return ui64_d2i(0, 0, 0, 0, 0, 0, 0, 0);\n    };\n\n    /*  clone the UI64  */\n    var ui64_clone = function (x) {\n        return x.slice(0);\n    };\n\n    /*  convert between number and UI64 representation  */\n    var ui64_n2i = function (n) {\n        var ui64 = ui64_zero();\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            ui64[i] = Math.floor(n % UI64_DIGIT_BASE);\n            n /= UI64_DIGIT_BASE;\n        }\n        return ui64;\n    };\n\n    /*  convert between UI64 representation and number  */\n    var ui64_i2n = function (x) {\n        var n = 0;\n        for (var i = UI64_DIGITS - 1; i >= 0; i--) {\n            n *= UI64_DIGIT_BASE;\n            n += x[i];\n        }\n        return Math.floor(n);\n    };\n\n    /*  add UI64 (y) to UI64 (x) and return overflow/carry as number  */\n    var ui64_add = function (x, y) {\n        var carry = 0;\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            carry += x[i] + y[i];\n            x[i]   = Math.floor(carry % UI64_DIGIT_BASE);\n            carry  = Math.floor(carry / UI64_DIGIT_BASE);\n        }\n        return carry;\n    };\n\n    /*  multiply number (n) to UI64 (x) and return overflow/carry as number  */\n    var ui64_muln = function (x, n) {\n        var carry = 0;\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            carry += x[i] * n;\n            x[i]   = Math.floor(carry % UI64_DIGIT_BASE);\n            carry  = Math.floor(carry / UI64_DIGIT_BASE);\n        }\n        return carry;\n    };\n\n    /*  multiply UI64 (y) to UI64 (x) and return overflow/carry as UI64  */\n    var ui64_mul = function (x, y) {\n        var i, j;\n\n        /*  clear temporary result buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        for (i = 0; i < (UI64_DIGITS + UI64_DIGITS); i++)\n            zx[i] = 0;\n\n        /*  perform multiplication operation  */\n        var carry;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            /*  calculate partial product and immediately add to zx  */\n            carry = 0;\n            for (j = 0; j < UI64_DIGITS; j++) {\n                carry += (x[i] * y[j]) + zx[i + j];\n                zx[i + j] = (carry % UI64_DIGIT_BASE);\n                carry /= UI64_DIGIT_BASE;\n            }\n\n            /*  add carry to remaining digits in zx  */\n            for ( ; j < UI64_DIGITS + UI64_DIGITS - i; j++) {\n                carry += zx[i + j];\n                zx[i + j] = (carry % UI64_DIGIT_BASE);\n                carry /= UI64_DIGIT_BASE;\n            }\n        }\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i];\n        return zx.slice(UI64_DIGITS, UI64_DIGITS);\n    };\n\n    /*  AND operation: UI64 (x) &= UI64 (y)  */\n    var ui64_and = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] &= y[i];\n        return x;\n    };\n\n    /*  OR operation: UI64 (x) |= UI64 (y)  */\n    var ui64_or = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] |= y[i];\n        return x;\n    };\n\n    /*  rotate right UI64 (x) by a \"s\" bits and return overflow/carry as number  */\n    var ui64_rorn = function (x, s) {\n        var ov = ui64_zero();\n        if ((s % UI64_DIGIT_BITS) !== 0)\n            throw new Error(\"ui64_rorn: only bit rotations supported with a multiple of digit bits\");\n        var k = Math.floor(s / UI64_DIGIT_BITS);\n        for (var i = 0; i < k; i++) {\n            for (var j = UI64_DIGITS - 1 - 1; j >= 0; j--)\n                ov[j + 1] = ov[j];\n            ov[0] = x[0];\n            for (j = 0; j < UI64_DIGITS - 1; j++)\n                x[j] = x[j + 1];\n            x[j] = 0;\n        }\n        return ui64_i2n(ov);\n    };\n\n    /*  rotate right UI64 (x) by a \"s\" bits and return overflow/carry as number  */\n    var ui64_ror = function (x, s) {\n        /*  sanity check shifting  */\n        if (s > (UI64_DIGITS * UI64_DIGIT_BITS))\n            throw new Error(\"ui64_ror: invalid number of bits to shift\");\n\n        /*  prepare temporary buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        var i;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            zx[i + UI64_DIGITS] = x[i];\n            zx[i] = 0;\n        }\n\n        /*  shift bits inside zx  */\n        var k1 = Math.floor(s / UI64_DIGIT_BITS);\n        var k2 = s % UI64_DIGIT_BITS;\n        for (i = k1; i < UI64_DIGITS + UI64_DIGITS - 1; i++) {\n            zx[i - k1] =\n                ((zx[i] >>> k2) |\n                 (zx[i + 1] << (UI64_DIGIT_BITS - k2))) &\n                ((1 << UI64_DIGIT_BITS) - 1);\n        }\n        zx[UI64_DIGITS + UI64_DIGITS - 1 - k1] =\n            (zx[UI64_DIGITS + UI64_DIGITS - 1] >>> k2) &\n            ((1 << UI64_DIGIT_BITS) - 1);\n        for (i = UI64_DIGITS + UI64_DIGITS - 1 - k1 + 1; i < UI64_DIGITS + UI64_DIGITS; i++)\n            zx[i] = 0;\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i + UI64_DIGITS];\n        return zx.slice(0, UI64_DIGITS);\n    };\n\n    /*  rotate left UI64 (x) by a \"s\" bits and return overflow/carry as UI64  */\n    var ui64_rol = function (x, s) {\n        /*  sanity check shifting  */\n        if (s > (UI64_DIGITS * UI64_DIGIT_BITS))\n            throw new Error(\"ui64_rol: invalid number of bits to shift\");\n\n        /*  prepare temporary buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        var i;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            zx[i + UI64_DIGITS] = 0;\n            zx[i] = x[i];\n        }\n\n        /*  shift bits inside zx  */\n        var k1 = Math.floor(s / UI64_DIGIT_BITS);\n        var k2 = s % UI64_DIGIT_BITS;\n        for (i = UI64_DIGITS - 1 - k1; i > 0; i--) {\n            zx[i + k1] =\n                ((zx[i] << k2) |\n                 (zx[i - 1] >>> (UI64_DIGIT_BITS - k2))) &\n                ((1 << UI64_DIGIT_BITS) - 1);\n        }\n        zx[0 + k1] = (zx[0] << k2) & ((1 << UI64_DIGIT_BITS) - 1);\n        for (i = 0 + k1 - 1; i >= 0; i--)\n            zx[i] = 0;\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i];\n        return zx.slice(UI64_DIGITS, UI64_DIGITS);\n    };\n\n    /*  XOR UI64 (y) onto UI64 (x) and return x  */\n    var ui64_xor = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] ^= y[i];\n        return;\n    };\n\n    /*  this is just a really minimal UI32 functionality,\n        just sufficient enough for the MD5 and SHA1 digests!  */\n\n    /*  safely add two integers (with wrapping at 2^32)  */\n    var ui32_add = function (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n\n    /*  bitwise rotate 32-bit number to the left  */\n    var ui32_rol = function (num, cnt) {\n        return (\n              ((num <<        cnt ) & 0xFFFFFFFF)\n            | ((num >>> (32 - cnt)) & 0xFFFFFFFF)\n        );\n    };\n\n    /*  calculate the SHA-1 of an array of big-endian words, and a bit length  */\n    var sha1_core = function (x, len) {\n        /*  perform the appropriate triplet combination function for the current iteration  */\n        function sha1_ft (t, b, c, d) {\n            if (t < 20) return (b & c) | ((~b) & d);\n            if (t < 40) return b ^ c ^ d;\n            if (t < 60) return (b & c) | (b & d) | (c & d);\n            return b ^ c ^ d;\n        }\n\n        /*  determine the appropriate additive constant for the current iteration  */\n        function sha1_kt (t) {\n            return (t < 20) ?  1518500249 :\n                   (t < 40) ?  1859775393 :\n                   (t < 60) ? -1894007588 :\n                               -899497514;\n        }\n\n        /*  append padding  */\n        x[len >> 5] |= 0x80 << (24 - len % 32);\n        x[((len + 64 >> 9) << 4) + 15] = len;\n\n        var w = Array(80);\n        var a =  1732584193;\n        var b =  -271733879;\n        var c = -1732584194;\n        var d =   271733878;\n        var e = -1009589776;\n\n        for (var i = 0; i < x.length; i += 16) {\n            var olda = a;\n            var oldb = b;\n            var oldc = c;\n            var oldd = d;\n            var olde = e;\n            for (var j = 0; j < 80; j++) {\n                if (j < 16)\n                    w[j] = x[i + j];\n                else\n                    w[j] = ui32_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n                var t = ui32_add(\n                    ui32_add(ui32_rol(a, 5), sha1_ft(j, b, c, d)),\n                    ui32_add(ui32_add(e, w[j]), sha1_kt(j))\n                );\n                e = d;\n                d = c;\n                c = ui32_rol(b, 30);\n                b = a;\n                a = t;\n            }\n            a = ui32_add(a, olda);\n            b = ui32_add(b, oldb);\n            c = ui32_add(c, oldc);\n            d = ui32_add(d, oldd);\n            e = ui32_add(e, olde);\n        }\n        return [ a, b, c, d, e ];\n    };\n\n    /*  calculate the SHA-1 of an octet string  */\n    var sha1 = function (s) {\n        return a2s(\n            sha1_core(\n                s2a(s, { ibits: 8, obits: 32, obigendian: true }),\n                s.length * 8),\n            { ibits: 32, ibigendian: true });\n    };\n\n    /*  calculate the MD5 of an array of little-endian words, and a bit length  */\n    var md5_core = function (x, len) {\n        /*  basic operations the algorithm uses  */\n        function md5_cmn (q, a, b, x, s, t) {\n            return ui32_add(ui32_rol(ui32_add(ui32_add(a, q), ui32_add(x, t)), s), b);\n        }\n        function md5_ff (a, b, c, d, x, s, t) {\n            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n        }\n        function md5_gg (a, b, c, d, x, s, t) {\n            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n        }\n        function md5_hh (a, b, c, d, x, s, t) {\n            return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n        }\n        function md5_ii (a, b, c, d, x, s, t) {\n            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n        }\n\n        /*  append padding  */\n        x[len >> 5] |= 0x80 << ((len) % 32);\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n        var a =  1732584193;\n        var b =  -271733879;\n        var c = -1732584194;\n        var d =   271733878;\n\n        for (var i = 0; i < x.length; i += 16) {\n            var olda = a;\n            var oldb = b;\n            var oldc = c;\n            var oldd = d;\n\n            a = md5_ff(a, b, c, d, x[i+ 0],  7,  -680876936);\n            d = md5_ff(d, a, b, c, x[i+ 1], 12,  -389564586);\n            c = md5_ff(c, d, a, b, x[i+ 2], 17,   606105819);\n            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n            a = md5_ff(a, b, c, d, x[i+ 4],  7,  -176418897);\n            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n            b = md5_ff(b, c, d, a, x[i+ 7], 22,   -45705983);\n            a = md5_ff(a, b, c, d, x[i+ 8],  7,  1770035416);\n            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n            c = md5_ff(c, d, a, b, x[i+10], 17,      -42063);\n            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n            a = md5_ff(a, b, c, d, x[i+12],  7,  1804603682);\n            d = md5_ff(d, a, b, c, x[i+13], 12,   -40341101);\n            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n            a = md5_gg(a, b, c, d, x[i+ 1],  5,  -165796510);\n            d = md5_gg(d, a, b, c, x[i+ 6],  9, -1069501632);\n            c = md5_gg(c, d, a, b, x[i+11], 14,   643717713);\n            b = md5_gg(b, c, d, a, x[i+ 0], 20,  -373897302);\n            a = md5_gg(a, b, c, d, x[i+ 5],  5,  -701558691);\n            d = md5_gg(d, a, b, c, x[i+10],  9,    38016083);\n            c = md5_gg(c, d, a, b, x[i+15], 14,  -660478335);\n            b = md5_gg(b, c, d, a, x[i+ 4], 20,  -405537848);\n            a = md5_gg(a, b, c, d, x[i+ 9],  5,   568446438);\n            d = md5_gg(d, a, b, c, x[i+14],  9, -1019803690);\n            c = md5_gg(c, d, a, b, x[i+ 3], 14,  -187363961);\n            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n            a = md5_gg(a, b, c, d, x[i+13],  5, -1444681467);\n            d = md5_gg(d, a, b, c, x[i+ 2],  9,   -51403784);\n            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n            a = md5_hh(a, b, c, d, x[i+ 5],  4,     -378558);\n            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n            b = md5_hh(b, c, d, a, x[i+14], 23,   -35309556);\n            a = md5_hh(a, b, c, d, x[i+ 1],  4, -1530992060);\n            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n            c = md5_hh(c, d, a, b, x[i+ 7], 16,  -155497632);\n            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n            a = md5_hh(a, b, c, d, x[i+13],  4,   681279174);\n            d = md5_hh(d, a, b, c, x[i+ 0], 11,  -358537222);\n            c = md5_hh(c, d, a, b, x[i+ 3], 16,  -722521979);\n            b = md5_hh(b, c, d, a, x[i+ 6], 23,    76029189);\n            a = md5_hh(a, b, c, d, x[i+ 9],  4,  -640364487);\n            d = md5_hh(d, a, b, c, x[i+12], 11,  -421815835);\n            c = md5_hh(c, d, a, b, x[i+15], 16,   530742520);\n            b = md5_hh(b, c, d, a, x[i+ 2], 23,  -995338651);\n\n            a = md5_ii(a, b, c, d, x[i+ 0],  6,  -198630844);\n            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n            b = md5_ii(b, c, d, a, x[i+ 5], 21,   -57434055);\n            a = md5_ii(a, b, c, d, x[i+12],  6,  1700485571);\n            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n            c = md5_ii(c, d, a, b, x[i+10], 15,    -1051523);\n            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n            a = md5_ii(a, b, c, d, x[i+ 8],  6,  1873313359);\n            d = md5_ii(d, a, b, c, x[i+15], 10,   -30611744);\n            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n            a = md5_ii(a, b, c, d, x[i+ 4],  6,  -145523070);\n            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n            c = md5_ii(c, d, a, b, x[i+ 2], 15,   718787259);\n            b = md5_ii(b, c, d, a, x[i+ 9], 21,  -343485551);\n\n            a = ui32_add(a, olda);\n            b = ui32_add(b, oldb);\n            c = ui32_add(c, oldc);\n            d = ui32_add(d, oldd);\n        }\n        return [ a, b, c, d ];\n    };\n\n    /*  calculate the MD5 of an octet string  */\n    var md5 = function (s) {\n        return a2s(\n            md5_core(\n                s2a(s, { ibits: 8, obits: 32, obigendian: false }),\n                s.length * 8),\n            { ibits: 32, ibigendian: false });\n    };\n\n    /*  PCG Pseudo-Random-Number-Generator (PRNG)\n        http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf\n        This is the PCG-XSH-RR variant (\"xorshift high (bits), random rotation\"),\n        based on 32-bit output, 64-bit internal state and the formulas:\n        state = state * MUL + INC\n        output = rotate32((state ^ (state >> 18)) >> 27, state >> 59)  */\n\n    var PCG = function (seed) {\n        /*  pre-load some \"magic\" constants  */\n        this.mul   = ui64_d2i(0x58, 0x51, 0xf4, 0x2d, 0x4c, 0x95, 0x7f, 0x2d);\n        this.inc   = ui64_d2i(0x14, 0x05, 0x7b, 0x7e, 0xf7, 0x67, 0x81, 0x4f);\n        this.mask  = ui64_d2i(0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff);\n\n        /*  generate an initial internal state  */\n        this.state = ui64_clone(this.inc);\n        this.next();\n        ui64_and(this.state, this.mask);\n        seed = ui64_n2i(seed !== undefined ?\n            (seed >>> 0) : ((Math.random() * 0xffffffff) >>> 0));\n        ui64_or(this.state, seed);\n        this.next();\n    };\n    PCG.prototype.next = function () {\n        /*  save current state  */\n        var state = ui64_clone(this.state);\n\n        /*  advance internal state  */\n        ui64_mul(this.state, this.mul);\n        ui64_add(this.state, this.inc);\n\n        /*  calculate: (state ^ (state >> 18)) >> 27  */\n        var output = ui64_clone(state);\n        ui64_ror(output, 18);\n        ui64_xor(output, state);\n        ui64_ror(output, 27);\n\n        /*  calculate: state >> 59  */\n        var rot = ui64_clone(state);\n        ui64_ror(rot, 59);\n\n\t\t/*  calculate: rotate32(xorshifted, rot)  */\n        ui64_and(output, this.mask);\n        var k = ui64_i2n(rot);\n        var output2 = ui64_clone(output);\n        ui64_rol(output2, 32 - k);\n        ui64_ror(output, k);\n        ui64_xor(output, output2);\n\n        /*  return pseudo-random number  */\n        return ui64_i2n(output);\n    };\n    var pcg = new PCG();\n\n    /*  utility function: simple Pseudo Random Number Generator (PRNG)  */\n    var prng = function (len, radix) {\n        var bytes = [];\n        for (var i = 0; i < len; i++)\n            bytes[i] = (pcg.next() % radix);\n        return bytes;\n    };\n\n    /*  internal state  */\n    var time_last = 0;\n    var time_seq  = 0;\n\n    /*  the API constructor  */\n    var UUID = function () {\n        if (arguments.length === 1 && typeof arguments[0] === \"string\")\n            this.parse.apply(this, arguments);\n        else if (arguments.length >= 1 && typeof arguments[0] === \"number\")\n            this.make.apply(this, arguments);\n        else if (arguments.length >= 1)\n            throw new Error(\"UUID: constructor: invalid arguments\");\n        else\n            for (var i = 0; i < 16; i++)\n                this[i] = 0x00;\n    };\n\n    /*  inherit from a standard class which provides the\n        best UUID representation in the particular environment  */\n    /* global Uint8Array: false */\n    /* global Buffer: false */\n    if (typeof Uint8Array !== \"undefined\")\n        /*  HTML5 TypedArray (browser environments: IE10, FF, CH, SF, OP)\n            (http://caniuse.com/#feat=typedarrays)  */\n        UUID.prototype = new Uint8Array(16);\n    else if (Buffer)\n        /*  Node Buffer (server environments: Node.js, IO.js)  */\n        UUID.prototype = new Buffer(16);\n    else\n        /*  JavaScript (any environment)  */\n        UUID.prototype = new Array(16);\n    UUID.prototype.constructor = UUID;\n\n    /*  API method: generate a particular UUID  */\n    UUID.prototype.make = function (version) {\n        var i;\n        var uuid = this;\n        if (version === 1) {\n            /*  generate UUID version 1 (time and node based)  */\n\n            /*  determine current time and time sequence counter  */\n            var date = new Date();\n            var time_now = date.getTime();\n            if (time_now !== time_last)\n                time_seq = 0;\n            else\n                time_seq++;\n            time_last = time_now;\n\n            /*  convert time to 100*nsec  */\n            var t = ui64_n2i(time_now);\n            ui64_muln(t, 1000 * 10);\n\n            /*  adjust for offset between UUID and Unix Epoch time  */\n            ui64_add(t, ui64_d2i(0x01, 0xB2, 0x1D, 0xD2, 0x13, 0x81, 0x40, 0x00));\n\n            /*  compensate for low resolution system clock by adding\n                the time/tick sequence counter  */\n            if (time_seq > 0)\n                ui64_add(t, ui64_n2i(time_seq));\n\n            /*  store the 60 LSB of the time in the UUID  */\n            var ov;\n            ov = ui64_rorn(t, 8); uuid[3] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[2] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[1] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[0] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[5] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[4] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[7] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[6] = (ov & 0x0F);\n\n            /*  generate a random clock sequence  */\n            var clock = prng(2, 255);\n            uuid[8] = clock[0];\n            uuid[9] = clock[1];\n\n            /*  generate a random local multicast node address  */\n            var node = prng(6, 255);\n            node[0] |= 0x01;\n            node[0] |= 0x02;\n            for (i = 0; i < 6; i++)\n                uuid[10 + i] = node[i];\n        }\n        else if (version === 4) {\n            /*  generate UUID version 4 (random data based)  */\n            var data = prng(16, 255);\n            for (i = 0; i < 16; i++)\n                 this[i] = data[i];\n        }\n        else if (version === 3 || version === 5) {\n            /*  generate UUID version 3/5 (MD5/SHA-1 based)  */\n            var input = \"\";\n            var nsUUID = (\n                typeof arguments[1] === \"object\" && arguments[1] instanceof UUID ?\n                arguments[1] : new UUID().parse(arguments[1])\n            );\n            for (i = 0; i < 16; i++)\n                 input += String.fromCharCode(nsUUID[i]);\n            input += arguments[2];\n            var s = version === 3 ? md5(input) : sha1(input);\n            for (i = 0; i < 16; i++)\n                 uuid[i] = s.charCodeAt(i);\n        }\n        else\n            throw new Error(\"UUID: make: invalid version\");\n\n        /*  brand with particular UUID version  */\n        uuid[6] &= 0x0F;\n        uuid[6] |= (version << 4);\n\n        /*  brand as UUID variant 2 (DCE 1.1)  */\n        uuid[8] &= 0x3F;\n        uuid[8] |= (0x02 << 6);\n\n        return uuid;\n    };\n\n    /*  API method: format UUID into usual textual representation  */\n    UUID.prototype.format = function (type) {\n        var str, arr;\n        if (type === \"z85\")\n            str = z85_encode(this, 16);\n        else if (type === \"b16\") {\n            arr = Array(32);\n            a2hs(this, 0, 15, true, arr, 0);\n            str = arr.join(\"\");\n        }\n        else if (type === undefined || type === \"std\") {\n            arr = new Array(36);\n            a2hs(this,  0,  3, false, arr,  0); arr[ 8] = \"-\";\n            a2hs(this,  4,  5, false, arr,  9); arr[13] = \"-\";\n            a2hs(this,  6,  7, false, arr, 14); arr[18] = \"-\";\n            a2hs(this,  8,  9, false, arr, 19); arr[23] = \"-\";\n            a2hs(this, 10, 15, false, arr, 24);\n            str = arr.join(\"\");\n        }\n        return str;\n    };\n\n    /*  API method: format UUID into usual textual representation  */\n    UUID.prototype.toString = function (type) {\n        return this.format(type);\n    };\n\n    /*  API method: parse UUID from usual textual representation  */\n    UUID.prototype.parse = function (str, type) {\n        if (typeof str !== \"string\")\n            throw new Error(\"UUID: parse: invalid argument (type string expected)\");\n        if (type === \"z85\")\n            z85_decode(str, this);\n        else if (type === \"b16\")\n            hs2a(str, 0, 35, this, 0);\n        else if (type === undefined || type === \"std\") {\n            var map = {\n                \"nil\":     \"00000000-0000-0000-0000-000000000000\",\n                \"ns:DNS\":  \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:URL\":  \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:OID\":  \"6ba7b812-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:X500\": \"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"\n            };\n            if (map[str] !== undefined)\n                str = map[str];\n            else if (!str.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/))\n                throw new Error(\"UUID: parse: invalid string representation \" +\n                    \"(expected \\\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\\")\");\n            hs2a(str,  0,  7, this,  0);\n            hs2a(str,  9, 12, this,  4);\n            hs2a(str, 14, 17, this,  6);\n            hs2a(str, 19, 22, this,  8);\n            hs2a(str, 24, 35, this, 10);\n        }\n        return this;\n    };\n\n    /*  API method: export UUID into standard array of numbers  */\n    UUID.prototype.export = function () {\n        var arr = Array(16);\n        for (var i = 0; i < 16; i++)\n            arr[i] = this[i];\n        return arr;\n    };\n\n    /*  API method: import UUID from standard array of numbers  */\n    UUID.prototype.import = function (arr) {\n        if (!(typeof arr === \"object\" && arr instanceof Array))\n            throw new Error(\"UUID: import: invalid argument (type Array expected)\");\n        if (arr.length !== 16)\n            throw new Error(\"UUID: import: invalid argument (Array of length 16 expected)\");\n        for (var i = 0; i < 16; i++) {\n            if (typeof arr[i] !== \"number\")\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (type Number expected)\");\n            if (!(isFinite(arr[i]) && Math.floor(arr[i]) === arr[i]))\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (Number with integer value expected)\");\n            if (!(arr[i] >= 0 && arr[i] <= 255))\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (Number with integer value in range 0...255 expected)\");\n            this[i] = arr[i];\n        }\n        return this;\n    };\n\n    /*  API method: compare UUID against another one  */\n    UUID.prototype.compare = function (other) {\n        if (typeof other !== \"object\")\n            throw new Error(\"UUID: compare: invalid argument (type UUID expected)\");\n        if (!(other instanceof UUID))\n            throw new Error(\"UUID: compare: invalid argument (type UUID expected)\");\n        for (var i = 0; i < 16; i++) {\n            if (this[i] < other[i])\n                return -1;\n            else if (this[i] > other[i])\n                return +1;\n        }\n        return 0;\n    };\n\n    /*  API method: hash UUID by XOR-folding it k times  */\n    UUID.prototype.fold = function (k) {\n        if (typeof k === \"undefined\")\n            throw new Error(\"UUID: fold: invalid argument (number of fold operations expected)\");\n        if (k < 1 || k > 4)\n            throw new Error(\"UUID: fold: invalid argument (1-4 fold operations expected)\");\n        var n = 16 / Math.pow(2, k);\n        var hash = new Array(n);\n        for (var i = 0; i < n; i++) {\n            var h = 0;\n            for (var j = 0; i + j < 16; j += n)\n                h ^= this[i + j];\n            hash[i] = h;\n        }\n        return hash;\n    };\n\n    UUID.PCG = PCG;\n\n    /*  export API  */\n    return UUID;\n}));\n});\n\nfunction uuid$1(){\n  return new uuid(1).format();\n}\n\nexport { EventEmitter, createLogger, logColor, uuid$1 as uuid };\n//# sourceMappingURL=index.es.js.map\n","function ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisector(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\n\nfunction extent(values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n}\n\nfunction identity(x) {\n  return x;\n}\n\nvar array = Array.prototype;\n\nvar slice = array.slice;\n\nfunction constant(x) {\n  return function() {\n    return x;\n  };\n}\n\nfunction range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nfunction sturges(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n\nfunction bin() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    if (!Array.isArray(data)) data = Array.from(data);\n\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n\nconst EQUALS = 'EQ';\nconst GREATER_THAN = 'GT';\nconst GREATER_EQ = 'GE';\nconst LESS_THAN = 'LT';\nconst LESS_EQ = 'LE';\nconst AND = 'AND';\nconst OR = 'OR';\nconst STARTS_WITH = 'SW';\nconst NOT_STARTS_WITH = 'NOT_SW';\nconst IN = 'IN';\nconst NOT_IN = 'NOT_IN';\n\nconst SET_FILTER_DATA_COLUMNS = [\n    {name: 'name'}, \n    {name: 'count', width: 40}, \n    {name: 'totalCount', width: 40}\n];\n\nconst BIN_FILTER_DATA_COLUMNS = [\n    {name: 'bin'}, \n    {name: 'count'}, \n    {name: 'bin-lo'},\n    {name: 'bin-hi'}\n];\n\n\nfunction getFilterColumn(column) {\n    return column.isGroup ? column.columns[0] : column;\n}\nfunction functor(columnMap, filter) {\n    //TODO convert filter to include colIdx ratherthan colName, so we don't have to pass cols\n    switch (filter.type) {\n    case IN: return testInclude(columnMap, filter);\n    case NOT_IN: return testExclude(columnMap, filter);\n    case EQUALS: return testEQ(columnMap, filter);\n    case GREATER_THAN: return testGT(columnMap, filter);\n    case GREATER_EQ: return testGE(columnMap, filter);\n    case LESS_THAN: return testLT(columnMap, filter);\n    case LESS_EQ: return testLE(columnMap, filter);\n    case STARTS_WITH: return testSW(columnMap, filter);\n    case NOT_STARTS_WITH: return testSW(columnMap, filter, true);\n    case AND: return testAND(columnMap, filter);\n    case OR: return testOR(columnMap, filter);\n    default:\n        console.log(`unrecognized filter type ${filter.type}`);\n        return () => true;\n    }\n}\n\nfunction testAND(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.every(fn => fn(row));\n}\n\nfunction testOR(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.some(fn => fn(row));\n}\n\nfunction testSW(cols, f, inversed = false) {\n    const value = f.value.toLowerCase();\n    return inversed\n        ? row => row[cols[f.colName]].toLowerCase().indexOf(value) !== 0\n        : row => row[cols[f.colName]].toLowerCase().indexOf(value) === 0;\n   \n}\n\nfunction testGT(cols, f) {\n    return row => row[cols[f.colName]] > f.value;\n}\n\nfunction testGE(cols, f) {\n    return row => row[cols[f.colName]] >= f.value;\n}\n\nfunction testLT(cols, f) {\n    return row => row[cols[f.colName]] < f.value;\n}\n\nfunction testLE(cols, f) {\n    return row => row[cols[f.colName]] <= f.value;\n}\n\nfunction testInclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) !== -1;\n}\n\n// faster to convert values to a keyed map\nfunction testExclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) === -1;\n}\n\nfunction testEQ(cols, f) {\n    return row => row[cols[f.colName]] === f.value;\n}\n\nfunction shouldShowFilter(filterColumnName, column) {\n    const filterColumn = getFilterColumn(column);\n    if (filterColumn.isGroup) {\n        return filterColumn.columns.some(col => col.name === filterColumnName);\n    } else {\n        return filterColumnName === filterColumn.name;\n    }\n}\n\nfunction includesNoValues(filter) {\n    // TODO make sure we catch all cases...\n    if (!filter){\n        return false;\n    } else if (filter.type === IN && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === AND && filter.filters.some(f => includesNoValues(f))){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction includesAllValues(filter) {\n    if (!filter){\n        return false;\n    } else if (filter.type === NOT_IN && filter.values.length === 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// does f2 only narrow the resultset from f1\nfunction extendsFilter(f1=null, f2=null) {\n    // ignore filters which are identical\n    // include or exclude filters which add values\n    if (f2 === null){\n        return false\n    } else if (f1 === null) {\n        return true;\n    }\n    if (f1.colName && f1.colName === f2.colName) {\n        if (f1.type === f2.type) {\n            switch (f1.type) {\n            case IN:\n                return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n            case NOT_IN: \n                return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n            case STARTS_WITH: return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n                // more cases here such as GT,LT\n            default:\n            }\n        }\n\n    } else if (f1.colname && f2.colName) {\n        // different columns,always false\n        return false;\n    } else if (f2.type === AND && extendsFilters(f1, f2)) {\n        return true;\n    }\n\n    // safe option is to assume false, causing filter to be re-applied to base data\n    return false;\n}\n\nconst byColName = (a, b) => a.colName === b.colName ? 0 : a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1, f2) {\n    if (f1.colName) {\n        const matchingFilter = f2.filters.find(f => f.colName === f1.colName);\n        return filterEquals(matchingFilter, f1, true);\n    } else if (f1.filters.length === f2.filters.length) {\n        // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n        // then we are still extending the filter (i.e. narrowing the resultset)\n        const a = f1.filters.sort(byColName);\n        const b = f2.filters.slice().sort(byColName);\n\n        for (let i = 0; i < a.length; i++) {\n            if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (f2.filters.length > f1.filters.length){\n        return f1.filters.every(filter1 => {\n            const filter2 = f2.filters.find(f => f.colName === filter1.colName);\n            return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n        });\n    }\n}\n\nfunction addFilter(existingFilter, filter) {\n\n    if (includesNoValues(filter)){\n        const {colName} = filter;\n        existingFilter = removeFilterForColumn(existingFilter, {name:colName});\n    } else if (includesAllValues(filter)){\n        // A filter that returns all values is a way to remove filtering for this column \n        return removeFilterForColumn(existingFilter, {name: filter.colName});\n    }\n\n    if (!existingFilter) {\n        return filter;\n    } else if (!filter) {\n        return existingFilter;\n    }\n   \n    if (existingFilter.type === AND && filter.type === AND) {\n        return { type: 'AND', filters: combine(existingFilter.filters, filter.filters) };\n    } else if (existingFilter.type === 'AND') {\n        const filters = replaceOrInsert(existingFilter.filters, filter);\n        return filters.length > 1\n            ? { type: 'AND', filters  }\n            : filters[0];\n    } else if (filter.type === 'AND') {\n        return { type: 'AND', filters: filter.filters.concat(existingFilter) };\n    } else if (filterEquals(existingFilter, filter, true)) {\n        return filter;\n    } else if (sameColumn(existingFilter, filter)){\n        return merge(existingFilter, filter);\n    } else {\n        return { type: 'AND', filters: [existingFilter, filter] };\n    }\n}\n\n// If we add an IN filter and there is an existing NOT_IN, we would always expect the IN\n// values to exist in the NOT_IN set (as long as user interaction is driving the filtering)\nfunction replaceOrInsert(filters, filter) {\n    const {type, colName, values} = filter;\n    if (type === IN) {\n        // see if we have a NOT_IN entry\n        let idx = filters.findIndex(f => f.type === NOT_IN && f.colName === colName);\n        if (idx !== -1){\n            const {values: existingValues} = filters[idx];\n            if (values.every(value => existingValues.indexOf(value) !== -1)){\n                if (values.length === existingValues.length){\n                    // we simply remove the existing NOT_IN filter ...\n                    return filters.filter((f, i) => i !== idx);\n                } else {\n                    // ... or strip the IN values from the NOT_IN values\n                    let newValues = existingValues.filter(value => !values.includes(value));\n                    return filters.map((filter,i) => i === idx ? {...filter, values: newValues}: filter)\n\n                }\n            }\n            else if (values.some(value => existingValues.indexOf(value) !== -1)){\n                console.log(`partial overlap between IN and NOT_IN`);\n\n            }\n        }\n\n\n        idx = filters.findIndex(f => f.type === IN && f.colName === filter.colName);\n        if (idx !== -1) {\n            return filters.map((f, i) => i === idx ? merge(f, filter) : f);\n        }\n    }\n\n    return filters.concat(filter);\n}\n\nfunction merge(f1, f2){\n    const {type: t1} = f1;\n    const {type: t2} = f2;      \n    const sameType = t1 === t2 ? t1 : '';\n\n    if (includesNoValues(f2)){\n        return f2;\n    } else if ((t1 === IN && t2 === NOT_IN) || (t1 === NOT_IN && t2 === IN)){\n        // do the two sets cancel each other out ?\n        if (f1.values.length === f2.values.length && f1.values.every(v => f2.values.includes(v))){  \n            // DOn't think this is right\n            return null;\n        } else if (t1 === NOT_IN){\n            if (f2.values.every(v => f1.values.includes(v))){\n                return {\n                    ...f1,\n                    values: f1.values.filter(v => !f2.values.includes(v))\n                }\n            }\n        }\n    } else if (sameType === IN || sameType === NOT_IN){\n        return {\n            ...f1,\n            values: f1.values.concat(f2.values.filter(v => !f1.values.includes(v)))\n        }\n    } else if (sameType === STARTS_WITH){\n        return {\n            type: OR,\n            filters: [f1, f2]\n        }\n    } else if (sameType === NOT_STARTS_WITH){\n        return {\n            type: AND,\n            filters: [f1, f2]\n        }\n\n    }\n\n    return f2;\n\n}\n\nfunction combine(existingFilters, replacementFilters) {\n\n    // TODO need a safer REGEX here\n    function equivalentType({ type: t1 }, { type: t2 }) {\n        return (t1 === t2) || (t1[0] === t2[0]);\n    }\n\n    const replaces = (existingFilter, replacementFilter) => {\n        return existingFilter.colName === replacementFilter.colName &&\n            equivalentType(existingFilter, replacementFilter);\n    };\n\n    const stillApplicable = existingFilter => replacementFilters.some(\n        replacementFilter => replaces(existingFilter, replacementFilter)) === false;\n\n    return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nfunction splitFilterOnColumn(filter, columnName) {\n    if (!filter){\n        return [null,null];\n    } else if (filter.colName === columnName) {\n        return [filter,null];\n    } else if (filter.type !== 'AND') {\n        return [null, filter];\n    } else {\n        const [[columnFilter=null], filters] = partition(filter.filters, f => f.colName === columnName);\n        return filters.length === 1\n            ? [columnFilter,filters[0]]\n            : [columnFilter, { type: 'AND', filters }];\n    }\n}\n\nconst overrideColName = (filter, colName) => {\n    const {type} = filter;\n    if (type === AND || type === OR){\n        return {\n            type,\n            filters: filter.filters.map(f => overrideColName(f, colName))\n        }\n    } else {\n        return {...filter, colName}\n    }\n};\n\nfunction extractFilterForColumn(filter, columnName) {\n    if (!filter) {\n        return null;\n    }\n    const { type, colName } = filter;\n    switch (type) {\n        case AND: \n        case OR: \n            return collectFiltersForColumn(type, filter.filters, columnName);\n\n        default:\n            return colName === columnName ? filter : null;\n    }\n}\n\nfunction collectFiltersForColumn(type, filters, columName){\n    const results = [];\n    filters.forEach(filter => {\n        const ffc = extractFilterForColumn(filter, columName);\n        if (ffc !== null){\n            results.push(ffc);\n        }\n    });\n    if (results.length === 1){\n        return results[0];\n    } else {\n        return {\n            type,\n            filters: results\n        }\n    }\n}\n\nfunction includesColumn(filter, column) {\n    if (!filter) {\n        return false;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case AND: return filters.some(f => includesColumn(f, column));\n    default: return colName === column.name;\n    }\n}\n\nfunction removeFilterForColumn(sourceFilter, column) {\n    const colName = column.name;\n    if (!sourceFilter){\n        return null;\n    } else if (sourceFilter.colName === colName) {\n        return null;\n    } else if (sourceFilter.type === AND || sourceFilter.type === OR) {\n        const {type, filters} = sourceFilter;\n        const otherColFilters = filters.filter(f => f.colName !== colName);\n        switch(otherColFilters.length){\n            case 0: return null;\n            case 1: return otherColFilters[0];\n            default: return { type, otherColFilters } \n        }\n    } else {\n        return sourceFilter;\n    }\n}\n\nconst sameColumn = (f1, f2) => f1.colName === f2.colName;\n\nfunction filterEquals(f1, f2, strict = false) {\n    if (f1 && f1){\n        const isSameColumn = sameColumn(f1,f2);\n        if (!strict) {\n            return isSameColumn;\n        } else {\n            return isSameColumn &&\n                f1.type === f2.type && \n                f1.mode === f2.mode &&\n                f1.value === f2.value &&\n                sameValues(f1.values, f2.values);\n        }\n    } else {\n        return false;\n    }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1, f2) {\n    if (f1.type === IN && f2.type === IN) {\n        return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n    } else if (f1.type === NOT_IN && f2.type === NOT_IN) {\n        return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n    } else {\n        return false;\n    }\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll(superList, subList) {\n    for (let i = 0, len = subList.length; i < len; i++) {\n        if (superList.indexOf(subList[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues(arr1, arr2) {\n    if (arr1 === arr2) {\n        return true;\n    } else if (arr1.length === arr2.length) {\n        const a = arr1.slice().sort();\n        const b = arr2.slice().sort();\n        return a.join('|') === b.join('|');\n    }\n    return false;\n}\n\nfunction partition(list, test1, test2=null) {\n    const results1 = [];\n    const misses = [];\n    const results2 = test2===null ? null : [];\n\n    for (let i = 0; i < list.length; i++) {\n        if (test1(list[i])) {\n            results1.push(list[i]);\n        } else if (test2 !== null && test2(list[i])) {\n            results2.push(list[i]);\n        } else {\n            misses.push(list[i]);\n        }\n    }\n\n    return test2 === null\n        ? [results1, misses]\n        : [results1, results2, misses];\n}\n\nconst SORT_ASC = 'asc';\n\nconst setFilterColumnMeta = metaData(SET_FILTER_DATA_COLUMNS);\nconst binFilterColumnMeta = metaData(BIN_FILTER_DATA_COLUMNS);\n\nfunction mapSortCriteria(sortCriteria, columnMap) {\n    return sortCriteria.map(s => {\n        if (typeof s === 'string') {\n            return [columnMap[s], 'asc'];\n        } else if (Array.isArray(s)) {\n            const [columnName, sortDir] = s;\n            return [columnMap[columnName], sortDir || SORT_ASC];\n        } else {\n            throw Error('columnUtils.mapSortCriteria invalid input');\n        }\n\n    });\n}\n\nconst toKeyedColumn = (column, key) =>\n    typeof column === 'string'\n        ? { key, name: column }\n        : typeof column.key === 'number'\n            ? column\n            : {...column, key};\n\nconst toColumn = column =>\n    typeof column === 'string'\n        ? { name: column }\n        : column;\n\nfunction buildColumnMap(columns){\n    if (columns){\n        return columns.reduce((map, column, i) => {\n            if (typeof column === 'string'){\n                map[column] = i;\n            } else if (typeof column.key === 'number') {\n                map[column.name] = column.key;\n            } else {\n                map[column.name] = i;\n            }\n            return map;\n        },{})\n    } else {\n        return null;\n    }\n}\n\nfunction projectColumns(map, columns, meta){\n    const length = columns.length;\n    const {IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n    return (startIdx, selectedRows=[]) => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[RENDER_IDX] = 0;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = 0;\n        return out;\n    }\n}\n\nfunction projectColumnsFilter(map, columns, meta, filter){\n    const length = columns.length;\n    const {IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n\n    // this is filterset specific where first col is always value\n    const fn = filter ? functor(map, overrideColName(filter, 'name'))  : () => true;\n    return startIdx => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[RENDER_IDX] = 0;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = fn(row) ? 1 : 0;\n\n        return out;\n    }\n}\n\nfunction getFilterType(column){\n    return column.filter || getDataType(column);\n}\n\n// {name: 'Price', 'type': {name: 'price'}, 'aggregate': 'avg'},\n// {name: 'MarketCap', 'type': {name: 'number','format': 'currency'}, 'aggregate': 'sum'},\n\nfunction getDataType({type=null}){\n    if (type === null){\n        return 'set';\n    } else if (typeof type === 'string'){\n        return type;\n    } else {\n        switch(type.name){\n            case 'price':\n                return 'number';\n            default:\n                return type.name;\n        }\n    }\n\n}\n\n//TODO cache result by length\nfunction metaData(columns){\n    const start = Math.max(...columns.map((column, idx) => typeof column.key === 'number' ? column.key : idx));\n    return {\n        IDX: start + 1,\n        RENDER_IDX: start + 2,\n        DEPTH: start + 3,\n        COUNT: start + 4,\n        KEY: start + 5,\n        SELECTED: start + 6,\n        PARENT_IDX: start + 7,\n        IDX_POINTER: start + 8,\n        FILTER_COUNT: start + 9,\n        NEXT_FILTER_IDX: start + 10,\n        count: start + 11\n    }\n}\n\nconst DataTypes = {\n    ROW_DATA: 'rowData',\n    FILTER_DATA: 'filterData',\n    FILTER_BINS: 'filterBins'\n};\n\nconst ASC = 'asc';\nconst DSC = 'dsc';\n\nconst EMPTY_MAP = {};\n\nfunction sortableFilterSet(filterSet){\n    if (filterSet.length === 0){\n        return filterSet;\n    } else if (Array.isArray(filterSet[0])){\n        return filterSet;\n    } else {\n        return filterSet.map(idx => [idx,null]);\n    }\n}\n\nfunction sortExtend(sortSet, rows, sortCols, newSortCols, columnMap){\n    sort2ColsAdd1(sortSet, rows, newSortCols, columnMap);\n}\n\nfunction sort(sortSet,rows,sortCols,columnMap){\n    const sortCriteria = mapSortCriteria(sortCols, columnMap);\n    const count = sortCriteria.length;\n    const sortFn = count === 1 ? sort1 : count === 2 ? sort2 : count === 3 ? sort3 : sortAll;\n    sortFn(sortSet,rows,sortCriteria);\n}\n\nfunction sort2ColsAdd1(sortSet, rows, sortCols, columnMap){\n    const len = sortSet.length;\n    const sortCriteria = mapSortCriteria(sortCols, columnMap);\n    const [colIdx2] = sortCriteria[1];\n    for (let i=0;i<len;i++){\n        sortSet[i][2] = rows[sortSet[i][0]][colIdx2];\n    }\n    sortSet.sort((a,b) => {\n        return a[1] > b[1] ? 1 : b[1] > a[1] ? -1\n            : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n    });\n}\n\nfunction sort1(sortSet,rows,[[colIdx, direction]]){\n    const len = sortSet.length;\n    for (let i=0;i<len;i++){\n        const idx = sortSet[i][0];\n        sortSet[i][1] = rows[idx][colIdx];\n    }\n    if (direction === ASC){\n        sortSet.sort((a,b) => {\n            return a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : 0;\n        });\n    } else {\n        sortSet.sort((a,b) => {\n            return a[1] > b[1] ? -1 : b[1] > a[1] ? 1 : 0;\n        });\n    }\n}\n\nfunction sort2(sortSet,rows,sortCriteria){\n    const len = rows.length;\n    const [colIdx1] = sortCriteria[0];\n    const [colIdx2] = sortCriteria[1];\n    for (let i=0;i<len;i++){\n        sortSet[i][0] = i;\n        sortSet[i][1] = rows[i][colIdx1];\n        sortSet[i][2] = rows[i][colIdx2];\n    }\n    sortSet.sort((a,b) => {\n        return a[1] > b[1] ? 1 : b[1] > a[1] ? -1\n            : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n    });\n}\n\nfunction sort3(/*sortSet,rows,sortCriteria*/){\n\n}\nfunction sortAll(/*sortSet,rows,sortCriteria*/){\n\n}\n\nfunction sortByToMap(sortCriteria=null){\n    return sortCriteria === null\n        ? EMPTY_MAP\n        : sortCriteria.reduce((map, col, i) => {\n            if (typeof col === 'string') {\n                map[col] = i + 1;\n            } else {\n                const [colName, sortDir] = col;\n                map[colName] = sortDir === ASC ? (i + 1) : -1 * (i + 1);\n            }\n            return map;\n        }, {});\n\n}\n\nfunction sortReversed(cols1, cols2, colCount=cols1.length){\n    if (cols1 && cols2 && cols1.length > 0 && cols2.length === colCount){\n        for (let i=0;i<cols1.length; i++){\n            let [col1, direction1=ASC] = cols1[i];\n            let [col2, direction2=ASC] = cols2[i];\n            if (col1 !== col2 || direction1 === direction2){\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nfunction GROUP_ROW_TEST(group, row, [colIdx, direction]) {\n    if (group === row) {\n        return 0;\n    } else {\n        let a1 = direction === 'dsc' ? row[colIdx] : group[colIdx];\n        let b1 = direction === 'dsc' ? group[colIdx] : row[colIdx];\n        if (b1 === null || a1 > b1) {\n            return 1;\n        } else if (a1 == null || a1 < b1) {\n            return -1;\n        }\n    }\n}\n\nfunction ROW_SORT_TEST(a, b, [colIdx, direction]) {\n    if (a === b) {\n        return 0;\n    } else {\n        let a1 = direction === 'dsc' ? b[colIdx] : a[colIdx];\n        let b1 = direction === 'dsc' ? a[colIdx] : b[colIdx];\n        if (b1 === null || a1 > b1) {\n            return 1;\n        } else if (a1 == null || a1 < b1) {\n            return -1;\n        }\n    }\n}\n\n// sort null as low. not high\nfunction sortBy(cols, test=ROW_SORT_TEST) {\n    return function (a, b) {\n        for (let i = 0, result = 0, len=cols.length; i < len; i++) {\n            if (result = test(a, b, cols[i])) {\n                return result;\n            }\n        }\n        return 0;\n    };\n}\n\n// sorter is the sort comparator used to sort rows, we want to know\n// where row would be positioned in this sorted array. Return the\n// last valid position.\nfunction sortPosition(rows, sorter, row, positionWithinRange = 'last-available') {\n\n    function selectFromRange(pos) {\n\n        const len = rows.length;\n        const matches = p => sorter(rows[p], row) === 0;\n\n        //TODO this will depend on the sort direction\n        if (positionWithinRange === 'last-available') {\n            while (pos < len && matches(pos)) {\n                pos += 1;\n            }\n        } else if (positionWithinRange === 'first-available') {\n            while (pos > 0 && matches(pos - 1)) {\n                pos -= 1;\n            }\n        }\n\n        return pos;\n\n    }\n\n    function find(lo, hi) {\n\n        let mid = lo + Math.floor((hi - lo) / 2);\n        let pos = sorter(rows[mid], row);\n\n        if (lo === mid) {\n            return selectFromRange(pos >= 0 ? lo : hi);\n        }\n        if (pos >= 0) {\n            hi = mid;\n        } else {\n            lo = mid;\n        }\n        return find(lo, hi);\n    }\n\n    if (rows.length === 0){\n        return 0;\n    } else {\n        return find(0, rows.length);\n    }\n\n}\n\nconst NULL_RANGE = {lo: 0,hi: 0};\n\n// If the requested range overlaps the last sent range, we only need send the\n// newly exposed section of the range. The client will manage dropping off\n// the expired section.\n//\n// |----------------------------------| _range\n//  ++++++|----------------------------------| prevRange\n//  \n//\n//\n//  |------------------------------------| _range\n//  |----------------------------------|+  prevRange\n//TODO do we still need these calls to getFullRange ?\nfunction getDeltaRange(oldRange, newRange){\n    const {lo: oldLo, hi: oldHi} = oldRange /*getFullRange(oldRange)*/;\n    const {lo: newLo, hi: newHi} = newRange /*getFullRange(newRange)*/;\n\n    if (newLo >= oldLo && newHi <= oldHi){\n        // reduced range, no delta\n        return {lo: newHi, hi: newHi};\n\n    } else if (newLo >= oldHi || newHi < oldLo){\n        return {lo: newLo, hi: newHi};\n    } else if (newLo === oldLo && newHi === oldHi){\n        return {lo: oldHi,hi: oldHi};\n    } else {\n        return {\n            lo: newLo < oldLo ? newLo: oldHi,\n            hi: newHi > oldHi ? newHi: oldLo\n        };\n    }\n}\n\nfunction resetRange({lo,hi,bufferSize=0}){\n    return {\n        lo: 0,\n        hi: hi-lo,\n        bufferSize,\n        reset: true\n    };\n}\n\nfunction getFullRange({lo,hi,bufferSize=0}){\n    return {\n        lo: Math.max(0, lo - bufferSize),\n        hi: hi + bufferSize\n    };\n}\n\nfunction withinRange(range, index, offset=0) {\n    return index-offset >= range.lo && index-offset < range.hi;\n}\n\nconst SAME = 0;\nconst FWD = 2;\nconst BWD = 4;\nconst CONTIGUOUS = 8;\nconst OVERLAP = 16;\nconst REDUCE = 32;\nconst EXPAND = 64;\nconst NULL = 128;\n\nconst RangeFlags = {\n    SAME,\n    FWD,\n    BWD,\n    CONTIGUOUS,\n    OVERLAP,\n    REDUCE,\n    EXPAND,\n    NULL\n};\n\nRangeFlags.GAP = ~(CONTIGUOUS | OVERLAP | REDUCE);\n\nfunction compareRanges(range1, range2){\n    if (range2.lo === 0 && range2.hi === 0){\n        return NULL;\n    } else if (range1.lo === range2.lo && range1.hi === range2.hi){\n        return SAME;\n    } else if (range2.hi > range1.hi){\n        if (range2.lo > range1.hi){\n            return FWD;\n        } else if (range2.lo === range1.hi){\n            return FWD + CONTIGUOUS;\n        } else if (range2.lo >= range1.lo){\n            return FWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo < range1.lo){\n        if (range2.hi < range1.lo){\n            return BWD;\n        } else if (range2.hi === range1.lo){\n            return BWD + CONTIGUOUS;\n        } else if (range2.hi > range1.lo){\n            return BWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo > range1.lo) {\n        return REDUCE + FWD;\n    } else {\n        return REDUCE + BWD\n    }\n}\n\nconst DEFAULT_OPTIONS = {\n    startIdx: 0,\n    rootIdx: null,\n    rootExpanded: true,\n    baseGroupby: []\n};\n\nfunction lowestIdxPointer(groups, IDX, DEPTH, start, depth){\n    let result = Number.MAX_SAFE_INTEGER;\n    for (let i=start; i<groups.length; i++){\n        const group = groups[i];\n        const absDepth = Math.abs(group[DEPTH]);\n\n        if (absDepth > depth){\n            break;\n        } else if (absDepth === depth) {\n            const idx = group[IDX];\n            if (typeof idx === 'number' && idx < result){\n                result = idx;\n            }\n        }\n    }\n\n    return result === Number.MAX_SAFE_INTEGER ? undefined : result;\n\n}\n\nfunction getCount(groupRow, PRIMARY_COUNT, FALLBACK_COUNT){\n    return typeof groupRow[PRIMARY_COUNT] === 'number'\n        ? groupRow[PRIMARY_COUNT]\n        : groupRow[FALLBACK_COUNT];\n}\n\nclass SimpleTracker {\n    constructor(levels){\n        this.levels = Array(levels).fill(0).reduce((acc,el,i) => {\n            acc[i+1] = {key: null, pos: null, pPos: null};\n            return acc;\n        },{});\n    }\n    set(depth,pos,groupKey){\n        if (this.levels){\n            const level = this.levels[Math.abs(depth)];\n            if (level && level.key !== groupKey){\n                if (level.key !== null){\n                    level.pPos = level.pos;\n                }\n                level.key = groupKey;\n                level.pos = pos;\n            }\n        }\n    }\n    \n    hasParentPos(level){\n        return this.levels[level+1] && this.levels[level+1].pos !== null\n    }\n    \n    parentPos(level){\n        return this.levels[level+1].pos\n    }\n    \n    hasPreviousPos(level){\n        return this.levels[level] && this.levels[level].pPos !== null\n    }\n    \n    previousPos(level){\n        return this.levels[level].pPos;\n    }\n}\n\nclass GroupIdxTracker {\n    constructor(levels){\n        this.idxAdjustment = 0;\n        this.maxLevel = levels+1;\n        this.levels = levels > 0\n            ? Array(levels).fill(0).reduce((acc,el,i) => {\n                acc[i+2] = {key: null, current: 0, previous: 0};\n                return acc;\n            },{})\n            : null;\n    }\n\n    increment(count){\n        this.idxAdjustment += count;\n        if (this.levels){\n            for (let i=2; i<this.maxLevel+1;i++){\n                this.levels[i].current += count;\n            }\n        }\n    }\n\n    previous(level){\n        return (this.levels && this.levels[level] && this.levels[level].previous) || 0\n    }\n\n    hasPrevious(level){\n        return this.previous(level) > 0;\n    }\n\n    get(idx){\n        return this.levels === null ? null: this.levels[idx]\n    }\n\n    set(depth,groupKey){\n        if (this.levels){\n            const level = this.levels[depth];\n            if (level && level.key !== groupKey){\n                if (level.key !== null){\n                    level.previous += level.current;\n                    level.current = 0;\n                }\n                level.key = groupKey;\n            }\n        }\n    }\n}\n\nconst itemIsNumeric = item => !isNaN(parseInt(item,10));\nconst numerically = (a,b) => parseInt(a)-parseInt(b);\n\nfunction sortKeys(o){\n    const keys = Object.keys(o);\n    if (keys.every(itemIsNumeric)){\n        return keys.sort(numerically)\n    } else {\n        return keys.sort()\n    }\n}\n\nfunction fillNavSetsFromGroups(groups, sortSet, sortIdx=0, filterSet=null, filterIdx, filterLen){\n    const keys = sortKeys(groups);\n    const filtered = filterSet !== null;\n    const filterIndices = filtered ? filterSet.slice(filterIdx,filterLen) : null;\n    for (let i = 0 ; i<keys.length;i++){\n        const groupedRows = groups[keys[i]];\n        if (Array.isArray(groupedRows)){\n            for (let j=0,len=groupedRows.length;j<len;j++){\n                const rowIdx = groupedRows[j];\n                sortSet[sortIdx] = rowIdx;\n                sortIdx += 1;\n                // this could be prohibitively slow (the includes test) ...\n                if (filtered && filterIndices.includes(rowIdx)){\n                    filterSet[filterIdx] = rowIdx;\n                    filterIdx += 1;\n                }\n            }\n        } else {\n            sortIdx = fillNavSetsFromGroups(groupedRows, sortSet, sortIdx);\n        }\n    }\n    return sortIdx;\n}\n\n// WHY is param order different from groupLeafRows\nfunction groupRows(rows, sortSet, columns, columnMap, groupby, options = DEFAULT_OPTIONS) {\n    const { startIdx = 0, length=rows.length, rootIdx = null, baseGroupby = [], groups=[], rowParents=null,\n        filterLength, filterSet, filterFn: filter } = options;\n    let {groupIdx=-1, filterIdx} = options;\n\n    const aggregations = findAggregatedColumns(columns, columnMap, groupby);\n    const groupedLeafRows = groupLeafRows(sortSet, rows, groupby, startIdx, length);\n    fillNavSetsFromGroups(groupedLeafRows, sortSet, startIdx, filterSet, filterIdx, filterLength);\n\n    const levels = groupby.length;\n    const currentGroups = Array(levels).fill(null);\n    const { IDX, DEPTH, FILTER_COUNT, NEXT_FILTER_IDX } = metaData(columns);\n\n    let parentIdx = rootIdx;\n    let leafCount = 0;\n\n    for (let i = startIdx, len=startIdx+length; i < len; i++){\n        const rowIdx = sortSet[i];\n        const row = rows[rowIdx];\n\n        for (let level = 0; level < levels; level++) {\n            const [columnIdx] = groupby[level];\n            const currentGroup = currentGroups[level];\n            const groupValue = row[columnIdx];\n            // as soon as we identify a group change, each group at that level and below\n            // is then aggregated and new group(s) initiated. \n            if (currentGroup === null || currentGroup[columnIdx] !== groupValue) {\n                if (currentGroup !== null) {\n                    // as soon as we know we're regrouping, aggregate the open groups, in reverse order\n                    for (let ii = levels - 1; ii >= level; ii--) {\n                        const group = currentGroups[ii];\n                        aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n                        if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0){\n                            group[NEXT_FILTER_IDX] = filterIdx;\n                            filterIdx += group[FILTER_COUNT];\n                        }\n                    }\n\n                    leafCount = 0;\n                }\n                for (let ii = level; ii < levels; ii++) {\n                    groupIdx += 1;\n                    parentIdx = ii === 0 ? rootIdx : currentGroups[ii - 1][IDX];\n                    const depth = levels - ii;\n                    // for first-level groups, row pointer is a pointer into the sortSet\n                    const childIdx = depth === 1\n                        ? i\n                        : groupIdx+1;\n\n                    const groupRow = currentGroups[ii] = GroupRow(row, depth, groupIdx, childIdx, parentIdx, groupby, columns, columnMap, baseGroupby);\n                    groups.push(groupRow);\n                }\n                break; // do not continue looping once we identify the change point\n            }\n        }\n        rowParents && (rowParents[rowIdx] = groupIdx);\n        leafCount += 1;\n    }\n\n    for (let i = levels - 1; i >= 0; i--) {\n        if (currentGroups[i] !== null){\n            const group = currentGroups[i];\n            aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n            if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0){\n                group[NEXT_FILTER_IDX] = filterIdx;\n            }\n        }\n    }\n    return groups;\n\n}\n\n// Checks very specifically for new cols added at end \nfunction groupbyExtendsExistingGroupby(groupBy, existingGroupBy) {\n    return (groupBy.length > existingGroupBy.length &&\n        existingGroupBy.every((g, i) => g[0] === groupBy[i][0]));\n}\n\n// doesn't care from which position col is removed, as long as it is not the first\nfunction groupbyReducesExistingGroupby(groupby, existingGroupby) {\n    return (existingGroupby.length > groupby.length &&\n        groupby[0][0] === existingGroupby[0][0] &&\n        groupby.every(([key]) => existingGroupby.find(([key2]) => key2 === key)));\n}\n\nfunction groupbySortReversed(groupBy, existingGroupBy) {\n    const [col] = findSortedCol(groupBy, existingGroupBy);\n    return col !== null;\n}\n\nfunction findDoomedColumnDepths(groupby, existingGroupby) {\n    const count = existingGroupby.length;\n    return existingGroupby.reduce(\n        (results, [colIdx], idx) => {\n            if (!groupby.some(group => group[0] === colIdx)) {\n                results.push(count - idx);\n            }\n            return results;\n        }, []);\n}\n\nfunction findSortedCol(groupby, existingGroupby) {\n    let results = [null];\n    let len1 = groupby && groupby.length;\n    let len2 = existingGroupby && existingGroupby.length;\n    if (len1 && len2 && len1 === len2) {\n\n        for (let i = 0; i < len1; i++) {\n            if (groupby[i][0] !== existingGroupby[i][0]) {\n                return results;\n            } else if (groupby[i][1] !== existingGroupby[i][1]) {\n                results[0] = i;\n                results[1] = len1 - i;\n            }\n        }\n    }\n    return results;\n}\n\nfunction byKey([key1], [key2]) {\n    return key1 > key2 ? 1 : key2 > key1 ? -1 : 0;\n}\n\nconst EMPTY = {};\nfunction getGroupStateChanges(groupState, existingGroupState = null, baseKey = '', groupIdx = 0) {\n    const results = [];\n    const entries = Object.entries(groupState);\n\n    entries.forEach(([key, value]) => {\n        if (value && (existingGroupState === null || !existingGroupState[key])) {\n            results.push([baseKey + key, groupIdx, true]);\n            if (value !== null && typeof value === 'object' && Object.keys(value).length > 0) {\n                const diff = getGroupStateChanges(value, EMPTY, baseKey + key + '/', groupIdx + 1);\n                if (diff.length) {\n                    results.push(...diff);\n                }\n            }\n        } else if (value) {\n            const diff = getGroupStateChanges(value, existingGroupState[key], baseKey + key + '/', groupIdx + 1);\n            if (diff.length) {\n                results.push(...diff);\n            }\n        }\n    });\n\n    if (existingGroupState !== null && typeof existingGroupState === 'object') {\n        Object.entries(existingGroupState).forEach(([key, value]) => {\n            if (value && !groupState[key]) {\n                results.push([baseKey + key, groupIdx, false]);\n            }\n        });\n    }\n\n    return results.sort(byKey);\n}\n\n// should be called toggleColumnInGroupBy\nfunction updateGroupBy(existingGroupBy = null, column/*, replace = false*/) {\n    console.log(``);\n    if (existingGroupBy === null) {\n        return [[column.name, ASC]];\n    } else {\n        return indexOfCol(column.name, existingGroupBy) === -1\n            ? existingGroupBy.concat([[column.name, ASC]])\n            : existingGroupBy.length === 1\n                ? null\n                : existingGroupBy.filter(([colName]) => colName !== column.name);\n    }\n}\n\nfunction indexOfCol(key, cols = null) {\n    if (cols !== null) {\n        for (let i = 0; i < cols.length; i++) {\n            // check both while we transition from groupBy to extendedGroupby\n            // groupBy = [colName, dir] extendedGroupby = [colIdx, dir,colName]\n            const [col1, , col2] = cols[i];\n            if (col1 === key || col2 === key) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\n// export function countNestedRows(rows, idx, depth) {\n//     const DEPTH = Data.DEPTH_FIELD;\n//     let count = 0;\n//     for (let i = idx, len = rows.length;\n//         i < len && Math.abs(rows[i][DEPTH]) < depth;\n//         i++) {\n//         count += 1;\n//     }\n//     return count;\n// }\n\n// TBC\n// export function countGroupMembers(groupedRows) {\n//     const results = [];\n//     const groups = [];\n//     let currentGroup = null;\n\n//     for (let i = 0; i < groupedRows.length; i++) {\n//         let [, depth] = groupedRows[i];\n//         if (depth === LEAF_DEPTH) {\n//             currentGroup.count += 1;\n//         } else {\n//             depth = Math.abs(depth);\n//             while (currentGroup && depth >= currentGroup.depth) {\n//                 const completedGroup = groups.shift();\n//                 const group = results[completedGroup.i];\n//                 if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//                     const newGroup = group.slice();\n//                     newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//                     results[completedGroup.i] = newGroup;\n//                 }\n//                 groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//                 ([currentGroup] = groups);\n//             }\n\n//             currentGroup = { i, depth, count: 0 };\n//             groups.unshift(currentGroup);\n//         }\n\n//         results[i] = groupedRows[i];\n\n//     }\n\n//     while (currentGroup) {\n//         const completedGroup = groups.shift();\n//         const group = results[completedGroup.i];\n//         if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//             const newGroup = group.slice();\n//             newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//             results[completedGroup.i] = newGroup;\n//         }\n//         groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//         ([currentGroup] = groups);\n//     }\n\n//     return results;\n// }\n\nfunction allGroupsExpanded(groups, group, {DEPTH, PARENT_IDX}){\n\n    do {\n        if (group[DEPTH] < 0){\n            return false;\n        }\n        group = groups[group[PARENT_IDX]];\n\n    } while (group)\n    \n    return true;\n}\n\nfunction adjustGroupIndices(groups, grpIdx, {IDX, DEPTH, IDX_POINTER, PARENT_IDX}, adjustment=1){\n    for (let i=0;i<groups.length;i++){\n        if (groups[i][IDX] >= grpIdx){\n            groups[i][IDX] += adjustment;\n            if (Math.abs(groups[i][DEPTH]) > 1){\n                groups[i][IDX_POINTER] += adjustment;\n            }\n            let parentIdx = groups[i][PARENT_IDX];\n            if (parentIdx !== null && parentIdx >= grpIdx){\n                groups[i][PARENT_IDX] += adjustment;\n            }\n        }\n    }\n}\n\nfunction adjustLeafIdxPointers(groups, insertionPoint, {DEPTH, IDX_POINTER}, adjustment=1){\n    for (let i=0;i<groups.length;i++){\n        if (Math.abs(groups[i][DEPTH]) === 1 && groups[i][IDX_POINTER] >= insertionPoint){\n            groups[i][IDX_POINTER] += adjustment;\n        }\n    }\n}\n\nfunction findGroupPositions(groups, groupby, row) {\n\n    const positions = [];\n\n    out: for (let i = 0; i < groupby.length; i++) {\n        const sorter = sortBy(groupby.slice(0, i + 1), GROUP_ROW_TEST);\n        const position = sortPosition(groups, sorter, row, 'first-available');\n        const group = groups[position];\n        // if all groups are missing and insert position is end of list ...\n        if (group === undefined) {\n            break;\n        }\n        // position is confirmed if all groupCol values in this comparison match values of row \n        // and other groupCol values  are null\n        for (let j = 0; j < groupby.length; j++) {\n            const colIdx = groupby[j][0];\n            const colValue = group[colIdx];\n            if (j > i) {\n                if (colValue !== null) {\n                    break out;\n                }\n            } else if (colValue !== row[colIdx]) {\n                break out;\n            }\n\n        }\n        positions.push(position);\n    }\n\n    return positions;\n\n}\n\nconst expandRow = (groupCols, row, meta) => {\n    const r = row.slice();\n    r[meta.IDX] = 0;\n    r[meta.DEPTH] = 0; \n    r[meta.COUNT] = 0;\n    r[meta.KEY] = buildGroupKey(groupCols, row);\n    r[meta.SELECTED] = 0;\n    return r;\n};\n\nfunction buildGroupKey(groupby, row){\n    const extractKey = ([idx]) => row[idx];\n    return groupby.map(extractKey).join('/');\n}\n\n// Do we have to take columnMap out again ?\nfunction GroupRow(row, depth, idx, childIdx, parentIdx, groupby, columns, columnMap, baseGroupby = []) {\n\n    const { IDX, DEPTH, COUNT, KEY, SELECTED, PARENT_IDX, IDX_POINTER, count } = metaData(columns);\n    const group = Array(count);\n    const groupIdx = groupby.length - depth;\n    let colIdx;\n\n    for (let i = 0; i < columns.length; i++) {\n        const column = columns[i];\n        const key = columnMap[column.name];\n        if (column.aggregate) { // implies we can't group on aggregate columns, does the UI know that ?\n            group[key] = 0;\n        } else if ((colIdx = indexOfCol(key, groupby)) !== -1 && colIdx <= groupIdx) {\n            group[key] = row[key];\n        } else {\n            group[key] = null;\n        }\n    }\n\n    for (let i = 0; i < baseGroupby.length; i++) {\n        const [colIdx] = baseGroupby[i];\n        group[colIdx] = row[colIdx];\n    }\n\n    const extractKey = ([idx]) => row[idx];\n    const buildKey = groupby => groupby.map(extractKey).join('/');\n    //TODO build the composite key for the grouprow\n    const baseKey = baseGroupby.length > 0\n        ? buildKey(baseGroupby) + '/'\n        : '';\n    const groupKey = buildKey(groupby.slice(0, groupIdx + 1));\n\n    group[IDX] = idx;\n    group[DEPTH] = -depth;\n    group[COUNT] = 0;\n    group[KEY] = baseKey + groupKey;\n    group[SELECTED] = 0;\n    group[IDX_POINTER] = childIdx;\n    group[PARENT_IDX] = parentIdx;\n\n    return group;\n\n}\n\nfunction groupLeafRows(sortSet, leafRows, groupby, startIdx=0, length=sortSet.length) {\n    const groups = {};\n    const levels = groupby.length;\n    const lastLevel = levels - 1;\n    for (let i=startIdx, len=startIdx+length; i < len; i++) {\n        const idx = sortSet[i];\n        const leafRow = leafRows[idx];\n        let target = groups;\n        let targetKey;\n        let key;\n        for (let level = 0; level < levels; level++) {\n            const [colIdx] = groupby[level];\n            key = leafRow[colIdx];\n            targetKey = target[key];\n            if (targetKey && level === lastLevel) {\n                targetKey.push(idx);\n            } else if (targetKey) {\n                target = targetKey;\n            } else if (!targetKey && level < lastLevel) {\n                target = (target[key] = {});\n            } else if (!targetKey) {\n                target[key] = [idx];\n            }\n        }\n    }\n    return groups;\n}\n\nfunction splitGroupsAroundDoomedGroup(groupby, doomed) {\n    const lastGroupIsDoomed = doomed === 1;\n    const doomedIdx = groupby.length - doomed;\n    const preDoomedGroupby = [];\n    const postDoomedGroupby = [];\n\n    groupby.forEach((col, i) => {\n        if (i < doomedIdx) {\n            preDoomedGroupby.push(col);\n        } else if (i > doomedIdx) {\n            postDoomedGroupby.push(col);\n        }\n    });\n\n    return [lastGroupIsDoomed, preDoomedGroupby, postDoomedGroupby];\n}\n\nfunction decrementDepth(depth) {\n    return (Math.abs(depth) - 1) * (depth < 0 ? -1 : 1);\n}\n\nfunction incrementDepth(depth) {\n    return (Math.abs(depth) + 1) * (depth < 0 ? -1 : 1);\n}\n\nfunction findAggregatedColumns(columns, columnMap, groupby) {\n    return columns.reduce((aggregations, column) => {\n        if (column.aggregate && indexOfCol(column.name, groupby) === -1) {\n            const key = columnMap[column.name];\n            aggregations.push([key, column.aggregate]);\n        }\n        return aggregations;\n    }, []);\n}\n\nfunction aggregateGroup(groups, grpIdx, sortSet, rows, columns, aggregations) {\n\n    const {DEPTH, COUNT} = metaData(columns);\n    const groupRow = groups[grpIdx];\n    let depth = groupRow[DEPTH];\n    let absDepth = Math.abs(depth);\n    let count = 0;\n    let idx = grpIdx;\n\n    // find the last nested group and work back - first build aggregates for level 1 groups,\n    // then use those to aggregate to level 2 etc.\n    while (idx < groups.length - 1 && Math.abs(groups[idx+1][DEPTH]) < absDepth){\n        idx += 1;\n        count += 1;\n    }\n\n    for (let i=grpIdx+count; i >= grpIdx; i--){\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n            const [colIdx] = aggregations[aggIdx];\n            groups[i][colIdx] = 0;\n        }\n        aggregate(groups[i], groups, sortSet, rows, columns, aggregations, groups[i][COUNT]);\n    }\n\n}\n\nfunction aggregate(groupRow, groupRows, sortSet, rows, columns, aggregations, leafCount, filter=null) {\n\n    const {DEPTH, COUNT, FILTER_COUNT} = metaData(columns);\n    const { IDX_POINTER } = metaData(columns);\n    let absDepth = Math.abs(groupRow[DEPTH]);\n    let count = 0;\n    let filteredCount = filter === null ? undefined : 0;\n\n    if (absDepth === 1) {\n        // The first group accumulates aggregates from the raw data...\n        let start = groupRow[IDX_POINTER];\n        let end = start + leafCount;\n        count = leafCount;\n        for (let i = start; i < end; i++) {\n            const row = rows[sortSet[i]];\n            const included = filter === null || filter(row);\n            if (filter && included){\n                filteredCount += 1;\n            }\n            if (filter === null || included){\n                for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n                    const [colIdx] = aggregations[aggIdx];\n                    groupRow[colIdx] += row[colIdx];\n                }\n            }\n        }\n    } else {\n        // higher-level groups aggregate from child-groups ...\n        // we cannot blindly use the grpIndex of the groupRow, as we may be dealing with a smaller subset\n        // of groupRows, e,g, when inserting a new row and creating the missing groups\n        const startIdx = groupRows.indexOf(groupRow) + 1;\n        for (let i=startIdx;i<groupRows.length;i++){\n            const nestedGroupRow = groupRows[i];\n            const nestedRowDepth = nestedGroupRow[DEPTH];\n            const nestedRowCount = nestedGroupRow[COUNT];\n            const absNestedRowDepth = Math.abs(nestedRowDepth);\n            if (absNestedRowDepth >= absDepth){\n                break;\n            } else if (absNestedRowDepth === absDepth - 1) {\n                for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n                    const [colIdx, method] = aggregations[aggIdx];\n                    if (method === 'avg') {\n                        groupRow[colIdx] += nestedGroupRow[colIdx] * nestedRowCount;\n                    } else {\n                        groupRow[colIdx] += nestedGroupRow[colIdx];\n                    }\n                }\n                count += nestedRowCount;\n            }\n        }\n    }\n\n    for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n        const [colIdx, method] = aggregations[aggIdx];\n        if (method === 'avg') {\n            groupRow[colIdx] = groupRow[colIdx] / count;\n        }\n    }\n\n    groupRow[COUNT] = count;\n    groupRow[FILTER_COUNT] = filteredCount;\n\n}\n\nfunction isEmptyRow(row){\n    return row[0] === undefined;\n}\n\nfunction addRowsToIndex(rows, index, indexField){\n    for (let idx = 0, len=rows.length; idx < len; idx++) {\n        index[rows[idx][indexField]] = idx;\n    }\n    return index;\n}\n\nfunction update(rows, range, updates, {IDX}) {\n    const results = rows.slice();\n\n    for (let i = 0; i < updates.length; i++) {\n        const [idx, ...fieldUpdates] = updates[i];\n        // slow, refactor for performance\n\n        let row;\n        for (let ii = 0; ii < rows.length; ii++) {\n            if (rows[ii][IDX] === idx) {\n                row = rows[ii].slice();\n                // updates = [colIdx, oldValue, newValue]*\n                for (let j = 0; j < fieldUpdates.length; j += 3) {\n                    row[fieldUpdates[j]] = fieldUpdates[j + 2];\n                }\n                results[ii] = row;\n\n                break;\n\n            }\n        }\n    }\n\n    return results;\n}\n\n\n// export so we can test - see if we can't use rewire\n// Called when client calls setRange, locally cached data is immediately\n// trimmed to new range and missing data filled with empty rows. \nfunction purgeAndFill({range:{lo, hi}, rows, offset = 0}, meta) {\n\n    const {IDX} = meta;\n    const results = [];\n    const len = rows.length;\n    const low = lo + offset;\n    const high = hi + offset;\n\n    let row;\n    let firstRowIdx = -1;\n\n\n    // 1) do we need any fills at the beginning ? \n    while (row === undefined && firstRowIdx < len) {\n        firstRowIdx += 1;\n        row = rows[firstRowIdx];\n    }\n\n    let idx = row ? row[IDX] : high;\n\n    const end = Math.min(idx, high);\n    for (let i = low; i < end; i++) {\n        results.push(emptyRow(i, meta));\n    }\n\n    if (end === high) {\n        // we're done if we've already filled the results\n        return results;\n    }\n\n    // 2) existing rows that still fall within range go into results\n    for (let i = firstRowIdx; i < len; i++) {\n        row = rows[i];\n        if (row) {\n            idx = row[IDX];\n            if (idx >= low && idx < high) {\n                results.push(row);\n            }\n        } else {\n            //onsole.log(`rowUtils.purgeAndFill gap at ${i}`);\n            results.push(emptyRow(i, meta));\n        }\n    }\n\n    // 3) pad results to end of range\n    const start = Math.max(idx + 1, low);\n    for (let i = start; i < high; i++) {\n        results.push(emptyRow(i, meta));\n    }\n\n    return results;\n\n}\n\n// TODO create a pool of these and reuse them\nfunction emptyRow(idx, {IDX, count}){\n    const row = Array(count);\n    row[IDX] = idx;\n    return row;\n}\n\n\n// New data is merged into local cache\nfunction mergeAndPurge({range:{lo, hi}, rows, offset = 0}, newRows, size, meta) {\n    // console.groupCollapsed(`mergeAndPurge  existing range: ${lo} - ${hi} \n    //  old   rows: [${rows.length ? rows[0][0]: null} - ${rows.length ? rows[rows.length-1][0]: null}]\n    //  new   rows: [${newRows.length ? newRows[0][0]: null} - ${newRows.length ? newRows[newRows.length-1][0]: null}]\n    //     `);\n    const {IDX} = meta;\n    const results = [];\n    const low = lo + offset;\n    const high = Math.min(hi + offset, size + offset);\n\n    let idx;\n    let row;\n\n    for (let i = 0; i < rows.length; i++) {\n        if (row = rows[i]) {\n            idx = row[IDX];\n            if (idx >= low && idx < high) {\n                results[idx - low] = rows[i];\n            }\n        }\n    }\n\n    for (let i = 0; i < newRows.length; i++) {\n        if (row = newRows[i]) {\n            idx = row[IDX];\n\n            if (idx >= low && idx < high) {\n                results[idx - low] = newRows[i];\n            }\n        }\n    }\n\n    // make sure the resultset contains entries for the full range\n    // TODO make this more efficient\n    const rowCount = hi - lo;\n    for (let i=0;i<rowCount;i++){\n        if (results[i] === undefined){\n            results[i] = emptyRow(i+low, meta);\n        }\n    }\n    // console.log(`results ${JSON.stringify(results,null,2)}`);\n    // console.groupEnd();\n    return results;\n\n}\n\nconst MAX_LISTENERS = 10;\n\nclass EventEmitter {\n\n    constructor() {\n        this._events = {};\n        this._maxListeners = MAX_LISTENERS;\n    }\n\n    addListener(type, listener) {\n        let m;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (this._events.newListener) {\n            this.emit('newListener', type, listener);\n        }\n\n        if (!this._events[type]) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        } else if (Array.isArray(this._events[type])) {\n            // If we've already got an array, just append.\n            this._events[type].push(listener);\n        } else {\n            // Adding the second element, need to change to array.\n            this._events[type] = [this._events[type], listener];\n        }\n\n        // Check for listener leak\n        if (Array.isArray(this._events[type]) && !this._events[type].warned) {\n            if (!isUndefined(this._maxListeners)) {\n                m = this._maxListeners;\n            } else {\n                m = MAX_LISTENERS;\n            }\n\n            if (m && m > 0 && this._events[type].length > m) {\n                this._events[type].warned = true;\n                console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                this._events[type].length);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeListener(type, listener) {\n        let list, position, length, i;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events || !this._events[type]) {\n            return this;\n        }\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n\n        } else if (Array.isArray(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0) {\n                return this;\n            }\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeAllListeners(type) {\n\n        if (!this._events) {\n            return this;\n        }\n\n        const listeners = this._events[type];\n\n        if (isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else if (listeners) {\n            // LIFO order\n            while (listeners.length) {\n                this.removeListener(type, listeners[listeners.length - 1]);\n            }\n        }\n        delete this._events[type];\n\n        return this;\n\n    }\n\n    emit(type, ...args) {\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // If there is no 'error' event listener then throw.\n        if (type === 'error') {\n            if (!this._events.error ||\n                (isObject(this._events.error) && !this._events.error.length)) {\n                const err = arguments[1];\n                if (err instanceof Error) {\n                    throw err; // Unhandled 'error' event\n                } else {\n                    // At least give some kind of context to the user\n                    throw new Error('Uncaught, unspecified \"error\" event. (' + err + ')');\n                }\n            }\n        }\n\n        const handler = this._events[type];\n\n        if (isUndefined(handler)) {\n            return false;\n        }\n\n        if (isFunction(handler)) {\n            switch (args.length) {\n                // fast cases\n                case 0:\n                    handler.call(this);\n                    break;\n                case 1:\n                    handler.call(this, type, args[0]);\n                    break;\n                case 2:\n                    handler.call(this, type, args[0], args[1]);\n                    break;\n                // slower\n                default:\n                    handler.call(this, type, ...args);\n            }\n        } else if (Array.isArray(handler)) {\n            handler.slice().forEach(listener => listener.call(this, type, ...args));\n        }\n\n        return true;\n\n    }\n\n    once(type, listener) {\n\n        const handler = (evtName, message) => {\n            this.removeListener(evtName, handler);\n            listener(evtName, message);\n        };\n\n        this.on(type, handler);\n\n    }\n\n    on(type, listener) {\n        return this.addListener(type, listener);\n    }\n\n}\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\n\nconst logColor = {\n  plain : 'color: black; font-weight: normal',\n  blue : 'color: blue; font-weight: bold',\n  brown : 'color: brown; font-weight: bold',\n  green : 'color: green; font-weight: bold',\n};\n\nconst {plain} = logColor;\nconst createLogger = (source, labelColor=plain, msgColor=plain) => ({\n  log: (msg, args='') => console.log(`[${Date.now()}]%c[${source}] %c${msg}`,labelColor, msgColor, args),\n  warn: (msg) => console.warn(`[${source}] ${msg}`)\n});\n\n/*global fetch */\n\nconst defaultUpdateConfig = {\n    applyUpdates: false,\n    applyInserts: false,\n    interval: 500\n};\n\nclass Table extends EventEmitter {\n\n    constructor(config){\n        super();\n\n        const {name, columns=null, primaryKey, dataPath, data, updates = {}} = config;\n\n        this.name = name;\n        this.primaryKey = primaryKey;\n        this.columns = columns;\n        this.keys = {};\n        this.index = {};\n        this.rows = [];\n        this.updateConfig = {\n            ...defaultUpdateConfig,\n            ...updates\n        };\n        this.columnMap = buildColumnMap(columns);\n        this.columnCount = 0;\n        this.status = null;\n\n        // console.log(`Table \n        //     columns = ${JSON.stringify(columns,null,2)}\n        //     columnMap = ${JSON.stringify(this.columnMap,null,2)}    \n        //     `)\n\n\n        if (data){\n            this.parseData(data);\n        } else if (dataPath){\n            this.loadData(dataPath);\n        }\n\n        this.installDataGenerators(config);\n    }\n\n    // ...updates = one or more pairs of (colIdx, colValue)\n    update(rowIdx, ...updates){\n        //onsole.log(`Table.update ${this.name} idx: ${rowIdx}  ${JSON.stringify(updates)}` );\n        const results = [];\n        let row = this.rows[rowIdx];\n        for (let i=0;i<updates.length;i+=2){\n            const colIdx = updates[i];\n            const value = updates[i+1];\n            results.push(colIdx, row[colIdx], value);\n            row[colIdx] = value;\n        }\n        this.emit('rowUpdated', rowIdx, results);\n    }\n\n    insert(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const idx = this.rows.length;\n        let row = this.rowFromData(idx, data, columnnameList);\n        this.rows.push(row);\n        this.emit('rowInserted', idx, row);\n    }\n\n    remove(key){\n        if (this.keys[key]){\n            const index = this.indices[key];\n            delete this.keys[key];\n            delete this.indices[key];\n            this.rows.splice(index,1);\n\n            for (let k in this.indices){\n                if (this.indices[k] > index){\n                    this.indices[k] -= 1;\n                }\n            }\n\n            this.emit('rowRemoved', this.name, key);\n\n        }\n    }\n\n    clear(){\n\n    }\n\n    toString(){\n        const out = ['\\n' + this.name];\n        out.splice.apply(out, [1,0].concat(this.rows.map(function(row){return row.toString();})));\n        return out.join('\\n');\n    }\n\n    async loadData(url){\n        fetch(url,{\n\n        })\n            .then(data => data.json())\n            .then(json => {\n                console.log(`Table.loadData: got ${json.length} rows`);\n                this.parseData(json);\n            })\n            .catch(err => {\n                console.error(err);\n            });\n\n    }\n\n    parseData(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const rows = [];\n        for (let i=0;i<data.length;i++){\n            let row = this.rowFromData(i, data[i], columnnameList);\n            rows.push(row);\n        }\n        this.rows = rows;\n\n        if (this.columns === null){\n            this.columns = columnsFromColumnMap(this.inputColumnMap);\n            this.columnMap = buildColumnMap(this.columns);\n        }\n        this.status = 'ready';\n        this.emit('ready');\n        if (this.updateConfig && this.updateConfig.applyUpdates !== false){\n            setTimeout(() => {\n                this.applyUpdates();\n            },1000);\n        }\n        // move this\n        if (this.updateConfig && this.updateConfig.applyInserts !== false){\n            setTimeout(() => {\n                this.applyInserts();\n            },10000);\n        }\n    }\n\n    rowFromData(idx, data, columnnameList){\n        // 2 metadata items for each row, the idx and unique key\n        const {index, primaryKey=null, columnMap: map} = this;\n\n        if (Array.isArray(data)){\n            const key = data[map[this.primaryKey]];\n            index[key] = idx;\n            return [...data, idx, key];\n        } else {\n            // This allows us to load data from objects as rows, without predefined columns, where\n            // not every row may have every column. How would we handle primary key ?\n            const columnMap = map || (this.columnMap = {});\n            const colnames = columnnameList || Object.getOwnPropertyNames(data);\n            const row = [idx];\n            let colIdx;\n            let key;\n\n            for (let i=0; i<colnames.length; i++){\n                const name = colnames[i];\n                const value = data[name];\n                if ((colIdx = columnMap[name]) === undefined){\n                    colIdx = columnMap[name] = this.columnCount++;\n                }\n                row[colIdx] = value;\n                // If we don't know the primary key, assume it is the first column for now\n                if ((name === primaryKey) || (primaryKey === null && i === 0)){\n                    key = value;\n                    index[value] = idx;\n                }\n            }\n            // doesn't this risk pushing the metadata into the wrong slots if not every row has every \n            // field\n            row.push(idx, key);\n            return row;\n        }\n    }\n\n    //TODO move all these methods into an external helper\n    applyInserts(){\n\n        const idx = this.rows.length;\n        const newRow = this.createRow(idx);\n        if (newRow){\n            this.insert(newRow);\n        } else {\n            console.log(`createRow did not return a new row`);\n        }\n\n        setTimeout(() => this.applyInserts(),5000);\n\n    }\n\n    applyUpdates(){\n        const {rows} = this;\n        // const count = Math.round(rows.length / 50);\n        const count = 100;\n\n        for (let i=0; i<count; i++){\n            const rowIdx = getRandomInt(rows.length - 1);\n            const update = this.updateRow(rowIdx, this.rows[rowIdx], this.columnMap);\n            if (update){\n                this.update(rowIdx, ...update);\n            }\n        }\n\n        setTimeout(() => this.applyUpdates(),this.updateConfig.interval);\n\n    }\n\n    createRow(idx){\n        console.warn(`createRow ${idx} must be implemented as a plugin`);\n    }\n\n    updateRow(/*idx, row, columnMap*/){\n        return null;\n    }\n\n    async installDataGenerators(/*config*/){\n        //console.warn(`installDataGenerators must be implemented by a more specific subclass`);\n    }\n\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction columnsFromColumnMap(columnMap){\n\n    const columnNames = Object.getOwnPropertyNames(columnMap);\n\n    return columnNames\n        .map(name => ({name, key: columnMap[name]}))\n        .sort(byKey$1)\n        .map(({name}) => ({name}));\n\n}\n\nfunction byKey$1(col1, col2){\n    return col1.key - col2.key;\n}\n\nconst CHECKBOX = 'checkbox';\nconst SINGLE_ROW = 'single-row';\nconst MULTIPLE_ROW = 'multiple-row';\n\nconst SelectionModelType = {\n  Checkbox: CHECKBOX,\n  SingleRow: SINGLE_ROW,\n  MultipleRow: MULTIPLE_ROW\n};\n\nconst {Checkbox, SingleRow, MultipleRow} = SelectionModelType;\n\nconst EMPTY$1 = [];\n\nclass SelectionModel {\n\n    constructor(selectionModelType=MultipleRow){\n      this.modelType = selectionModelType;\n    }\n\n    select({rows:selection, lastTouchIdx}, idx, rangeSelect, keepExistingSelection){\n        \n        let selected, deselected;\n\n        if (this.modelType === SingleRow){\n            [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n            lastTouchIdx = idx;\n        } else if (rangeSelect){\n            [selection, selected, deselected] = this.handleRangeSelection(selection, lastTouchIdx, idx);\n        } else if (keepExistingSelection || this.modelType === Checkbox){\n            [selection, selected, deselected] = this.handleIncrementalSelection(selection, idx);\n            lastTouchIdx = idx;\n        } else {\n            [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n            lastTouchIdx = idx;\n        }\n\n        return {\n          focusedIdx: idx,\n          lastTouchIdx,\n          rows: selection,\n          selected,\n          deselected\n        };\n\n    }\n\n    handleRegularSelection(selected, idx){\n        const pos = selected.indexOf(idx);\n        if (pos === -1){\n            const selection = [idx];\n            return [selection, selection, selected];\n        } else if (selected.length === 1){\n            return [EMPTY$1, EMPTY$1, selected];\n        } else {\n          return [EMPTY$1, EMPTY$1, remove(selected,idx)];\n        }\n    }\n\n    handleIncrementalSelection(selected, idx){\n        const pos = selected.indexOf(idx);\n        const len = selected.length;\n        const selection = [idx];\n\n        if (pos === -1){\n          if (len === 0){\n              return [selection, selection,EMPTY$1];\n            } else {\n                return [insert(selected,idx), selection, EMPTY$1];\n            }\n        } else {\n            if (len === 1){\n                return [EMPTY$1, EMPTY$1, selected];\n            } else {\n                return [remove(selected,idx), EMPTY$1, selection];\n            }\n        }\t\t\n    }\n\n    handleRangeSelection(selected, lastTouchIdx, idx){\n\n        const pos = selected.indexOf(idx);\n        const len = selected.length;\n\n        if (pos === -1){\n\n            if (len === 0){\n                const selection = makeRange(0,idx);\n                return [selection, selection, EMPTY$1];\n            } else if (len === 1){\n                const selection = makeRange(selected[0],idx);\n                selected = selected[0] < idx\n                  ? selection.slice(1)\n                  : selection.slice(0,-1);\n                return [selection, selected, EMPTY$1];\n            } else {\n                const selection = applyRange(selected,lastTouchIdx,idx);\n                return [selection, selection.filter(i => !selected.includes(i)), EMPTY$1];\n            }\n        }\n    }\n\n}\nfunction applyRange(arr, lo, hi){\n\n    if (lo > hi) {[lo, hi] = [hi, lo];}\n\n    const ranges = getRanges(arr);\n    const newRange = new Range(lo,hi);\n    let newRangeAdded = false;\n    const ret = [];\n\n    for (let i=0;i<ranges.length;i++){\n        const range = ranges[i];\n\n        if (!range.overlaps(newRange)){\n            if (range.start < newRange.start){\n                for (let idx=range.start;idx<=range.end;idx++){\n                    ret.push(idx);\n                }\n            } else {\n                for (let idx=newRange.start;idx<=newRange.end;idx++){\n                    ret.push(idx);\n                }\n                newRangeAdded = true;\n                for (let idx=range.start;idx<=range.end;idx++){\n                    ret.push(idx);\n                }\n            }\n        } else if (!newRangeAdded){\n            for (let idx=newRange.start;idx<=newRange.end;idx++){\n                ret.push(idx);\n            }\n            newRangeAdded = true;\n        }\n    }\n\n    if (!newRangeAdded){\n        for (let idx=newRange.start;idx<=newRange.end;idx++){\n            ret.push(idx);\n        }\n    }\n\n    return ret;\n}\n\nfunction getRanges(arr){\n\n    const ranges = [];\n    let range;\n\n    for (let i=0;i<arr.length;i++){\n        if (range && range.touches(arr[i])){\n            range.extend(arr[i]);\n        } else {\n            ranges.push(range = new Range(arr[i]));\n        }\n    }\n\n    return ranges;\n\n}\n\nclass Range {\n\n    constructor(start, end=start){\n        this.start = start;\n        this.end = end;\n    }\n\n    extend(idx){\n        if (idx >= this.start && idx > this.end){\n            this.end = idx;\n        }\n    }\n\n    touches(idx){\n        return this.end === idx-1;\n    }\n\n    overlaps(that){\n        return !(this.end < that.start || this.start > that.end);\n    }\n\n    contains(idx){\n        return this.start <= idx && this.end >= idx;\n    }\n\n    toString(){\n        return `[${this.start}:${this.end}]`;\n    }\n}\n\nfunction makeRange(lo, hi){\n    if (lo > hi) {[lo, hi] = [hi, lo];}\n\n    const range = [];\n    for (let idx=lo;idx<=hi;idx++){\n        range.push(idx);\n    }\n    return range;\n}\n\nfunction remove(arr, idx){\n    const ret = [];\n    for (let i=0;i<arr.length;i++){\n        if (idx !== arr[i]){\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\n\nfunction insert(arr, idx){\n    const ret = [];\n    for (let i=0;i<arr.length;i++){\n        if (idx !== null && idx < arr[i]){\n            ret.push(idx);\n            idx = null;\n        }\n        ret.push(arr[i]);\n    }\n    if (idx !== null){\n        ret.push(idx);\n    }\n    return ret;\n\n}\n\n/**\n * Keep all except for groupRowset in this file to avoid circular reference warnings\n */\n\nconst SINGLE_COLUMN = 1;\n\nconst NO_OPTIONS = {\n    filter: null\n};\n\nclass BaseRowSet {\n\n    constructor(table, columns, offset = 0) {\n        this.table = table;\n        this.offset = offset;\n        this.baseOffset = offset;\n        this.range = NULL_RANGE;\n        this.columns = columns;\n        this.currentFilter = null;\n        this.filterSet = null;\n        this.columnMap = table.columnMap;\n        this.meta = metaData(columns);\n        this.data = table.rows;\n        this.selected = {rows: [], focusedIdx: -1, lastTouchIdx: -1};\n        this.selectionModel = new SelectionModel();\n    }\n\n    // used by binned rowset\n    get filteredData() {\n        if (this.filterSet) {\n            return this.filterSet;\n        } else {\n            const { IDX } = this.meta;\n            return this.data.map(row => row[IDX])\n        }\n    }\n\n    get filterCount(){\n        return this.filterSet\n            ? this.filterSet.length\n            : this.data.length;\n    }\n\n    setRange(range=this.range, useDelta = true) {\n\n        const { lo, hi } = useDelta ? getDeltaRange(this.range, range) : getFullRange(range);\n        const resultset = this.slice(lo, hi);\n        this.range = range;\n        return {\n            rows: resultset,\n            range,\n            size: this.size,\n            offset: this.offset\n        };\n    }\n\n    currentRange() {\n        const { lo, hi } = this.range;\n        const resultset = this.slice(lo, hi);\n        return {\n            rows: resultset,\n            range: this.range,\n            size: this.size,\n            offset: this.offset\n        };\n    }\n\n    select(idx, rangeSelect, keepExistingSelection){\n        console.log(`RowSet.select ${idx} rangeSelect:${rangeSelect}, keepExistingSelection: ${keepExistingSelection}`);\n        \n        const {selected, deselected, ...selectionState} = this.selectionModel.select(\n            this.selected,\n            idx,\n            rangeSelect,\n            keepExistingSelection\n        );\n        \n        this.selected = selectionState;\n\n        return {selected, deselected};\n    }\n\n    selectNavigationSet(useFilter) {\n        const { COUNT, IDX_POINTER, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        return useFilter\n            ? [this.filterSet, NEXT_FILTER_IDX, FILTER_COUNT]\n            : [this.sortSet, IDX_POINTER, COUNT];\n    }\n\n    //TODO cnahge to return a rowSet, same as getDistinctValuesForColumn\n    getBinnedValuesForColumn(column) {\n        const key = this.columnMap[column.name];\n        const { data: rows, filteredData } = this;\n        const numbers = filteredData.map(rowIdx => rows[rowIdx][key]);\n        const data = bin().thresholds(20)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n\n        const table = new Table({ data, primaryKey: 'bin', columns: BIN_FILTER_DATA_COLUMNS });\n        const filterRowset = new BinFilterRowSet(table, BIN_FILTER_DATA_COLUMNS, column.name);\n        return filterRowset;\n    }\n\n    getDistinctValuesForColumn(column) {\n        const { data: rows, columnMap, currentFilter } = this;\n        const colIdx = columnMap[column.name];\n        const resultMap = {};\n        const data = [];\n        const dataRowCount = rows.length;\n        const [/*columnFilter*/, otherFilters] = splitFilterOnColumn(currentFilter, column);\n        // this filter for column that we remove will provide our selected values   \n        let dataRowAllFilters = 0;\n\n        if (otherFilters === null) {\n            let result;\n            for (let i = 0; i < dataRowCount; i++) {\n                const val = rows[i][colIdx];\n                if (result = resultMap[val]) {\n                    result[2] = ++result[1];\n                } else {\n                    result = [val, 1, 1];\n                    resultMap[val] = result;\n                    data.push(result);\n                }\n            }\n            dataRowAllFilters = dataRowCount;\n        } else {\n\n            const fn = functor(columnMap, otherFilters);\n            let result;\n\n            for (let i = 0; i < dataRowCount; i++) {\n                const row = rows[i];\n                const val = row[colIdx];\n                const isIncluded = fn(row) ? 1 : 0;\n                if (result = resultMap[val]) {\n                    result[1] += isIncluded;\n                    result[2]++;\n                } else {\n                    result = [val, isIncluded, 1];\n                    resultMap[val] = result;\n                    data.push(result);\n                }\n                dataRowAllFilters += isIncluded;\n            }\n        }\n\n        //TODO primary key should be indicated in columns\n        const table = new Table({ data, primaryKey: 'name', columns: SET_FILTER_DATA_COLUMNS });\n        return new SetFilterRowSet(table, SET_FILTER_DATA_COLUMNS, column.name, dataRowAllFilters, dataRowCount);\n\n    }\n}\n\n//TODO should range be baked into the concept of RowSet ?\nclass RowSet extends BaseRowSet {\n\n    // TODO stream as above\n    static fromGroupRowSet({ table, columns, offset, currentFilter: filter }) {\n        return new RowSet(table, columns, offset, {\n            filter\n        });\n    }\n    //TODO consolidate API of rowSet, groupRowset\n    constructor(table, columns, offset = 0, { filter = null } = NO_OPTIONS) {\n        super(table, columns, offset);\n        this.project = projectColumns(table.columnMap, columns, this.meta);\n        this.sortCols = null;\n        this.sortReverse = false;\n        this.sortSet = this.buildSortSet();\n        this.filterSet = null;\n        this.sortRequired = false;\n        if (filter) {\n            this.currentFilter = filter;\n            this.filter(filter);\n        }\n\n    }\n\n    buildSortSet() {\n        const len = this.data.length;\n        const arr = Array(len);\n        for (let i = 0; i < len; i++) {\n            arr[i] = [i, null, null];\n        }\n        return arr;\n    }\n\n    slice(lo, hi) {\n        const {selectedSet} = this;\n        if (this.filterSet) {\n            const filteredData = this.filterSet.slice(lo, hi);\n            const filterMapper = typeof filteredData[0] === 'number'\n                ? idx => this.data[idx]\n                : ([idx]) => this.data[idx];\n            return filteredData\n                .map(filterMapper)\n                .map(this.project(lo + this.offset, selectedSet));\n        } else if (this.sortCols) {\n            const sortSet = this.sortSet;\n            const results = [];\n            for (let i = lo, rows = this.data, len = rows.length; i < len && i < hi; i++) {\n                const idx = this.sortReverse\n                    ? sortSet[len - i - 1][0]\n                    : sortSet[i][0];\n                const row = rows[idx];\n                results.push(row);\n            }\n            return results.map(this.project(lo + this.offset, selectedSet));\n        } else {\n            return this.data.slice(lo, hi).map(this.project(lo + this.offset, selectedSet));\n        }\n    }\n\n    // deprecated\n    get size() {\n        return this.filterSet === null\n            ? this.data.length\n            : this.filterSet.length\n    }\n\n    get first() {\n        return this.data[0];\n    }\n    get last() {\n        return this.data[this.data.length - 1];\n    }\n    get rawData() {\n        return this.data;\n    }\n\n    setStatus(status) {\n        this.status = status;\n    }\n\n    addRows(rows) {\n        addRowsToIndex(rows, this.index, this.meta.IDX);\n        this.data = this.data.concat(rows);\n    }\n\n    sort(sortCols) {\n\n        const sortSet = this.currentFilter === null\n            ? this.sortSet\n            : this.filterSet = sortableFilterSet(this.filterSet);\n\n        this.sortRequired = this.currentFilter !== null;\n\n        if (sortReversed(this.sortCols, sortCols, SINGLE_COLUMN)) {\n            this.sortReverse = !this.sortReverse;\n        } else if (this.sortCols !== null && groupbyExtendsExistingGroupby(sortCols, this.sortCols)) {\n            this.sortReverse = false;\n            sortExtend(sortSet, this.data, this.sortCols, sortCols, this.columnMap);\n        } else {\n            this.sortReverse = false;\n            sort(sortSet, this.data, sortCols, this.columnMap);\n        }\n\n        this.sortCols = sortCols;\n\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        if (this.sortRequired) {\n            this.sort(this.sortCols);\n        }\n    }\n\n    filter(filter) {\n        const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n        const fn = filter && functor(this.columnMap, filter);\n        const { data: rows } = this;\n        let [navSet] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet);\n        const newFilterSet = [];\n\n        for (let i = 0; i < navSet.length; i++) {\n            const rowIdx = navSet === this.filterSet ? navSet[i] : navSet[i][0];\n            const row = rows[rowIdx];\n            if (fn(row)) {\n                newFilterSet.push(rowIdx);\n            }\n\n        }\n        this.filterSet = newFilterSet;\n        this.currentFilter = filter;\n        if (!extendsCurrentFilter && this.sortRequired) {\n            // TODO this might be very expensive for large dataset\n            // WHEN DO WE DO THIS - IS THIS CORRECT !!!!!\n            this.sort(this.sortCols);\n        }\n        return newFilterSet.length;\n\n    }\n\n    update(idx, updates) {\n        if (this.currentFilter === null && this.sortCols === null) {\n            if (idx >= this.range.lo && idx < this.range.hi) {\n                return [idx + this.offset, ...updates];\n            }\n        } else if (this.currentFilter === null) {\n            const { sortSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const [rowIdx] = sortSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        } else {\n            // sorted AND/OR filtered\n            const { filterSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const rowIdx = Array.isArray(filterSet[i]) ? filterSet[i][0] : filterSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        }\n    }\n\n    insert(idx, row) {\n        // TODO multi colun sort sort DSC \n        if (this.sortCols === null && this.currentFilter === null) {\n            // simplest scenario, row will be at end of sortset ...\n            this.sortSet.push([idx, null, null]);\n            if (idx >= this.range.hi) {\n                // ... row is beyond viewport\n                return {\n                    size: this.size\n                }\n            } else {\n                // ... row is within viewport\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            }\n        } else if (this.currentFilter === null) {\n            // sort only\n            const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n            const [[colIdx]] = sortCols;\n            const sortRow = [idx, row[colIdx]];\n            const sorter = sortBy([[1, 'asc']]);\n            const sortPos = sortPosition(this.sortSet, sorter, sortRow, 'last-available');\n            this.sortSet.splice(sortPos, 0, sortRow);\n\n            if (sortPos >= this.range.hi) {\n                return {\n                    size: this.size\n                }\n            } else if (sortPos >= this.range.lo) {\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            } else {\n                return {\n                    size: this.size,\n                    offset: this.offset - 1\n                }\n            }\n\n        } else if (this.sortCols === null) {\n            // filter only\n            const fn = functor(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                const navIdx = this.filterSet.length;\n                this.filterSet.push(idx);\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n        } else {\n            // sort AND filter\n            const fn = functor(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                // TODO what about totalCOunt\n\n                const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n                const [[colIdx]] = sortCols; // TODO multi-colun sort\n                const sortRow = [idx, row[colIdx]];\n                const sorter = sortBy([[1, 'asc']]); // TODO DSC\n                const navIdx = sortPosition(this.filterSet, sorter, sortRow, 'last-available');\n                this.filterSet.splice(navIdx, 0, sortRow);\n\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n\n        }\n    }\n}\n\n// TODO need to retain and return any searchText\nclass SetFilterRowSet extends RowSet {\n    constructor(table, columns, columnName, dataRowAllFilters, dataRowTotal) {\n        super(table, columns);        \n        this.columnName = columnName;\n        this._searchText = null;\n        this.dataRowFilter = null;\n        this.dataCounts = {\n            dataRowTotal,\n            dataRowAllFilters,\n            dataRowCurrentFilter : 0,\n            filterRowTotal : this.data.length,\n            filterRowSelected : this.data.length,\n            filterRowHidden : 0\n        };\n        this.setProjection();\n        this.sort([['name', 'asc']]);\n    }\n\n    get searchText() {\n        return this._searchText;\n    }\n\n    set searchText(text) {\n        // TODO\n        console.log(`FilterRowset set text = '${text}'`);\n        this.selectedCount = this.filter({ type: 'SW', colName: 'name', value: text });\n        const {filterSet, data: rows} = this;\n        // let totalCount = 0;\n        const colIdx = this.columnMap.totalCount;\n        for (let i=0;i<filterSet.length;i++){\n            const row = rows[filterSet[i]];\n            // totalCount += row[colIdx];\n        }\n        // this.totalCount = totalCount;\n        this._searchText = text;\n    }\n\n\n    currentRange(){\n        //TODO move these into a single struct\n\n            return {\n                ...super.currentRange(),\n                //TODO is this necessary, these won't change on a range request\n                dataCounts: this.dataCounts\n            }\n    \n    }\n    \n    setRange(range, useDelta){\n\n        return {\n            ...super.setRange(range, useDelta),\n            //TODO is this necessary, these won't change on a range request\n            dataCounts: this.dataCounts\n        }\n    }\n\n    filter(filter){\n        super.filter(filter);\n\n        const {dataCounts, filterSet, data: rows, dataRowFilter, table, columnName} = this;\n        let columnFilter;\n\n        if (dataRowFilter && (columnFilter = extractFilterForColumn(dataRowFilter, columnName))){\n            const columnMap = table.columnMap;\n            const fn = functor(columnMap, overrideColName(columnFilter, 'name'));\n            dataCounts.filterRowSelected = filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0); \n                \n        } else {\n            dataCounts.filterRowSelected = filterSet.length;\n        }\n\n        dataCounts.filterRowTotal = filterSet.length;\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        this._searchText = '';\n    }\n\n\n    get values() {\n        const key = this.columnMap['name'];\n        return this.filterSet.map(idx => this.data[idx][key])\n    }\n\n    setSelected(dataRowFilter, dataRowAllFilters) {\n\n        const columnFilter = extractFilterForColumn(dataRowFilter, this.columnName);\n        const columnMap = this.table.columnMap;\n        const {dataCounts, data: rows, filterSet} = this;\n\n        this.dataRowFilter = dataRowFilter;\n        \n        if (columnFilter){\n            const fn = functor(columnMap, overrideColName(columnFilter, 'name'));\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0) \n                : rows.reduce((count, row) => count + (fn(row) ? 1 : 0),0); \n        } else {\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.length\n                : rows.length;\n        }\n\n        dataCounts.dataRowAllFilters = dataRowAllFilters;\n\n        this.setProjection(columnFilter);\n\n        console.log(`SetFilterRowSet.setSelected selectedCount ${dataCounts.filterRowSelected} current range ${JSON.stringify(this.range)}`);\n        return this.currentRange();\n\n    }\n\n    setProjection(columnFilter = null){\n\n        const columnMap = this.table.columnMap;\n\n        this.project = projectColumnsFilter(\n            columnMap,\n            this.columns,\n            this.meta,\n            columnFilter\n        );\n\n    }\n\n}\n\nclass BinFilterRowSet extends RowSet {\n    constructor(table, columns, columnName) {\n        super(table, columns);\n        this.type = DataTypes.FILTER_BINS;\n        this.columnName = columnName;\n    }\n\n    setSelected(filter){\n        console.log(`need to apply filter to selected BinRowset`, filter);\n    }\n    // we don't currently have a concept of range here, but it will\n    // be used in the future\n    // Note: currently no projection here, we don't currently need metadata\n    setRange() {\n        console.log(`BinFilterRowset.setRange`);\n        return {\n            type: this.type,\n            rows: this.data,\n            range: null,\n            size: this.size,\n            offset: 0\n        };\n    }\n\n}\n\nconst RANGE_POS_TUPLE_SIZE = 4;\nconst NO_RESULT = [null,null,null];\n\nconst FORWARDS = 0;\nconst BACKWARDS = 1;\nfunction GroupIterator(groups, navSet, data, NAV_IDX, NAV_COUNT, meta) {\n    let _idx = 0;\n    let _grpIdx = null;\n    let _rowIdx = null;\n    let _direction = FORWARDS;\n    let _range = NULL_RANGE;\n    let _range_position_lo = [0, null, null];\n    let _range_positions = [];\n    let _range_position_hi = [null, null, null];\n\n    return {\n        get direction(){ return _direction },\n        get rangePositions(){ return _range_positions },\n        setRange,\n        currentRange,\n        getRangeIndexOfGroup,\n        getRangeIndexOfRow,\n        setNavSet,\n        refresh: currentRange,\n        clear\n    };\n\n\n    function getRangeIndexOfGroup(grpIdx){\n        const list = _range_positions;\n        for (let i=0; i< list.length; i += RANGE_POS_TUPLE_SIZE){\n            if (list[i+1] === grpIdx) {\n                if (list[i+2] === null){\n                    return i/RANGE_POS_TUPLE_SIZE;\n                } else {\n                    // first row encountere should be the group, if it\n                    // isn't it means it is crolled out of viewport\n                    return -1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function getRangeIndexOfRow(idx){\n        const list = _range_positions;\n        for (let i=0; i< list.length; i += RANGE_POS_TUPLE_SIZE){\n            if (list[i+3] === idx) {\n                return i/RANGE_POS_TUPLE_SIZE;\n            }\n        }\n        return -1\n    }\n\n    function clear(){\n        _idx = 0;\n        _grpIdx = null;\n        _rowIdx = null;\n        _direction = FORWARDS;\n        _range = NULL_RANGE;\n        _range_position_lo = [0, null, null];\n        _range_positions = [];\n        _range_position_hi = [null, null, null];\n    }\n\n    function setNavSet([newNavSet, navIdx, navCount]){\n        navSet = newNavSet;\n        NAV_IDX = navIdx;\n        NAV_COUNT = navCount;\n    }\n\n    function currentRange(){\n        const rows = [];\n        const {IDX} = meta;\n        ([_idx, _grpIdx, _rowIdx] = _range_position_lo);\n        if (_idx === 0 && _grpIdx === null && _rowIdx === null){\n            _idx = -1;\n        }\n        _range_positions.length = 0;\n\n        let startIdx = _idx;\n        let row;\n        let i = _range.lo;\n        do {\n            _direction = FORWARDS;\n            ([row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n            if (row){\n                rows.push(row);\n                _idx += 1;\n                const absRowIdx = _rowIdx === null ? null : row[IDX];\n                _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n                i += 1;\n            }\n        } while (row && i < _range.hi)\n        if (row){\n            _direction = FORWARDS;\n            const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n            [row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n            _idx += 1;\n            _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n            ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n        } else {\n            _range_position_hi = [null,null,null];\n        }\n\n        return [rows, startIdx+1];\n\n    }\n\n    function setRange(range, useDelta=true){\n        const rangeDiff = compareRanges(_range, range);\n        const { lo: resultLo, hi: resultHi } = useDelta ? getDeltaRange(_range, range) : getFullRange(range);\n        const {IDX} = meta;\n\n        if (rangeDiff === RangeFlags.NULL){\n            _range_position_lo = [0,null,null];\n            _range_position_hi = [null,null,null];\n            _range_positions.length = 0;\n            return [[],null];\n        } else if (range.lo === _range.lo && useDelta === false){\n            // when we're asked for the same range again, rebuild the range\n            ([_idx, _grpIdx, _rowIdx] = _range_position_lo);\n            _range_positions.length = 0;\n        } else {\n\n            if (_direction === FORWARDS && (rangeDiff & RangeFlags.BWD)){\n                ([_idx, _grpIdx, _rowIdx] = _range_positions);\n            } else if (_direction === BACKWARDS && (rangeDiff & RangeFlags.FWD)){\n                ([_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE));\n                _idx += 1;\n            }\n\n            if (rangeDiff === RangeFlags.FWD){\n                skip(range.lo - _range.hi, next);\n                _range_positions.length = 0;\n            } else if (rangeDiff === RangeFlags.BWD){\n                skip(_range.lo - range.hi, previous);\n                _range_positions.length = 0;\n            }\n\n            const loDiff = range.lo - _range.lo;\n            const hiDiff = _range.hi - range.hi;\n            // allow for a range that overshoots data\n            const missingQuota = (_range.hi - _range.lo) - _range_positions.length/RANGE_POS_TUPLE_SIZE;\n\n            if (loDiff > 0){\n                const removed = _range_positions.splice(0,loDiff*RANGE_POS_TUPLE_SIZE);\n                if (removed.length){\n                    _range_position_lo = removed.slice(-RANGE_POS_TUPLE_SIZE);\n\n                    // experiment - is this A) always correct B) enough\n                    if (useDelta === false){\n                        [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n                    }\n\n                }\n            }\n            if (hiDiff > 0){\n                //TODO allow for scenatio where both lo and HI have changed\n                if (hiDiff > missingQuota){\n                    const absDiff = hiDiff - missingQuota;\n                    const removed = _range_positions.splice(-absDiff*RANGE_POS_TUPLE_SIZE,absDiff*RANGE_POS_TUPLE_SIZE);\n                    if (removed.length){\n                        _range_position_hi = removed.slice(0,RANGE_POS_TUPLE_SIZE);\n                    }\n                }\n            }\n\n        }\n\n        const rows = [];\n        let row;\n        let startIdx = null;\n\n        if ((rangeDiff & RangeFlags.REDUCE) === 0){\n            if ((rangeDiff & RangeFlags.FWD) || (rangeDiff === RangeFlags.SAME)){\n                let i = resultLo;\n                startIdx = _idx;\n                do {\n                    _direction = FORWARDS;\n                    ([row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    if (row){\n                        rows.push(row);\n                        const absRowIdx = _rowIdx === null ? null : row[IDX];\n                        _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n                        i += 1;\n                        _idx += 1;\n                    }\n                } while (row && i < resultHi)\n                if (row){\n                    _direction = FORWARDS;\n                    const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n                    ([row, _grpIdx, _rowIdx] = next(groups, data ,_grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n                    ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n                } else {\n                    _range_position_hi = [null,null,null];\n                }\n\n            } else {\n                let i = resultHi - 1;\n                do {\n                    _direction = BACKWARDS;\n                    ([row, _grpIdx, _rowIdx] = previous(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    if (row){\n                        _idx -= 1;\n                        rows.unshift(row);\n                        const absRowIdx = _rowIdx === null ? null : row[IDX];\n                        _range_positions.unshift(_idx, _grpIdx, _rowIdx, absRowIdx);\n                        i -= 1;\n                    }\n                } while (row && i >= resultLo)\n                startIdx = _idx;\n                if (row){\n                    const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n                    _direction = BACKWARDS;\n                    [row, _grpIdx, _rowIdx] = previous(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n                    _range_position_lo = [row ? _idx-1 : 0, _grpIdx, _rowIdx];\n                    ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n                } else {\n                    _range_position_lo = [0,null,null];\n                }\n\n            }\n\n        } else {\n            // reduced range, adjust the current pos. DIrection can only be a guess, but if it's wrong\n            // the appropriate adjustment will be made nest time range is set\n            if (rangeDiff & RangeFlags.FWD){\n                console.log(`adjust thye idx`);\n                ([_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE));\n                _idx += 1;\n            } else {\n                ([_idx, _grpIdx, _rowIdx] = _range_positions);\n            }\n        }\n\n        _range = range;\n        return [rows, startIdx];\n    }\n\n    function skip(n, fn){\n\n        let i=0;\n        let row;\n\n        do {\n            [row, _grpIdx, _rowIdx] = fn(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n            if (fn === next){\n                _idx += 1;\n            } else {\n                _idx -= 1;\n            }\n            i += 1;\n\n        } while (row && i < n)\n        if (fn === next){\n            _range_position_lo = [_idx-1, _grpIdx, _rowIdx];\n        } else {\n            _range_position_hi = [_idx, _grpIdx, _rowIdx];\n        }\n    }\n\n}\n\nfunction getAbsRowIdx(group, relRowIdx, navSet, NAV_IDX){\n    return navSet[group[NAV_IDX] + relRowIdx];\n}\n\nfunction next(groups, rows, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta){\n    if (grpIdx === null){\n        grpIdx = -1;\n        do {\n            grpIdx += 1;\n        } while (grpIdx < groups.length && (\n            (getCount(groups[grpIdx],NAV_COUNT) === 0)\n        ));\n\n        if (grpIdx >= groups.length){\n            return NO_RESULT;\n        } else {\n            return [groups[grpIdx], grpIdx, null];\n        }\n    } else if (grpIdx >= groups.length){\n        return NO_RESULT;\n    } else {\n        let groupRow = groups[grpIdx];\n        const depth = groupRow[meta.DEPTH];\n        const count = getCount(groupRow,NAV_COUNT);\n        // Note: we're unlikely to be passed the row if row count is zero\n        if (depth === 1 && count !== 0 && (rowIdx === null || rowIdx < count - 1)){\n            rowIdx = rowIdx === null ? 0 : rowIdx + 1;\n            const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX);\n            // the equivalent of project row\n            const row = rows[absRowIdx].slice();\n            row[meta.IDX] = absRowIdx;\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n            return [row, grpIdx, rowIdx === null ? 0 : rowIdx];\n        } else if (depth > 0){\n\n            do {\n                grpIdx += 1;\n            } while (grpIdx < groups.length && (\n                (getCount(groups[grpIdx],NAV_COUNT) === 0)\n            ));\n            if (grpIdx >= groups.length){\n                return NO_RESULT;\n            } else {\n                return [groups[grpIdx], grpIdx, null];\n            }\n        } else {\n            const absDepth = Math.abs(depth);\n            do {\n                grpIdx += 1;\n            } while (grpIdx < groups.length && (\n                (Math.abs(groups[grpIdx][meta.DEPTH]) < absDepth) ||\n                (getCount(groups[grpIdx],NAV_COUNT) === 0)\n            ));\n            if (grpIdx >= groups.length){\n                return NO_RESULT;\n            } else {\n                return [groups[grpIdx], grpIdx, null];\n            }\n        }\n    }\n}\n\nfunction previous(groups, data, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta){\n    if (grpIdx !== null && groups[grpIdx][meta.DEPTH] === 1 && typeof rowIdx === 'number'){\n        let lastGroup = groups[grpIdx];\n        if (rowIdx === 0){\n            return [lastGroup, grpIdx, null];\n        } else {\n            rowIdx -= 1;\n            const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX);\n            const row = data[absRowIdx].slice();\n            // row[meta.IDX] = idx;\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n            return [row, grpIdx, rowIdx];\n        }\n    } else {\n        if (grpIdx === null){\n            grpIdx = groups.length-1;\n        } else if (grpIdx === 0) {\n            return NO_RESULT;\n        } else {\n            grpIdx -= 1;\n        }\n        let lastGroup = groups[grpIdx];\n        if (lastGroup[meta.DEPTH] === 1){\n            rowIdx = getCount(lastGroup, NAV_COUNT) - 1;\n            const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX);\n            const row = data[absRowIdx].slice();\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n            return [row, grpIdx, rowIdx];\n        }\n        while (lastGroup[meta.PARENT_IDX] !== null && groups[lastGroup[meta.PARENT_IDX]][meta.DEPTH] < 0){\n            grpIdx = lastGroup[meta.PARENT_IDX];\n            lastGroup = groups[grpIdx];\n        }\n        return [lastGroup, grpIdx, null];\n    }\n}\n\nconst EMPTY_ARRAY = [];\n\nclass GroupRowSet extends BaseRowSet {\n\n    constructor(rowSet, columns, groupby, groupState, sortCriteria = null, filter=rowSet.currentFilter) {\n        super(rowSet.table, columns, rowSet.baseOffset);\n        this.groupby = groupby;\n        this.groupState = groupState;\n        this.aggregations = [];\n        this.currentLength = 0; // TODO\n        this.groupRows = [];\n        this.aggregatedColumn = {};\n\n        this.collapseChildGroups = this.collapseChildGroups.bind(this);\n        this.countChildGroups = this.countChildGroups.bind(this);\n\n        columns.forEach(column => {\n            if (column.aggregate) {\n                const key = rowSet.columnMap[column.name];\n                this.aggregations.push([key, column.aggregate]); // why ?\n                this.aggregatedColumn[key] = column.aggregate;\n            }\n        });\n        this.expandedByDefault = false;\n        this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length\n            ? sortCriteria\n            : null;\n\n        // can we lazily build the sortSet as we fetch data for the first time ?\n        this.sortSet = rowSet.data.map((d,i) => i);\n        // we will store an array of pointers to parent Groups.mirroring sequence of leaf rows\n        this.rowParents = Array(rowSet.data.length);\n\n        this.applyGroupby(groupby);\n\n\n        const [navSet, IDX, COUNT] = this.selectNavigationSet(false);\n        // TODO roll the IDX and COUNT overrides into meta\n        this.iter = GroupIterator(this.groupRows, navSet, this.data, IDX, COUNT, this.meta);\n\n        if (filter){\n            this.filter(filter);\n        }\n\n    }\n\n    get length() {\n        return this.currentLength;\n    }\n    get first() {\n        return this.data[0];\n    }\n    get last(){\n        return this.data[this.data.length - 1];\n    }\n\n    currentRange(){\n        return this.setRange(this.range, false);\n    }\n\n    setRange(range, useDelta=true){\n        const [rowsInRange, idx] = !useDelta && range.lo === this.range.lo && range.hi === this.range.hi\n            ? this.iter.currentRange()\n            : this.iter.setRange(range, useDelta);\n\n        const filterCount = this.filterSet && this.meta.FILTER_COUNT;\n        const rows = rowsInRange.map((row,i) => this.cloneRow(row, idx+i, filterCount));\n        this.range = range;\n        return {\n            rows,\n            range,\n            size: this.length,\n            offset: this.offset,\n            selectedIndices: this.selectedIndices\n        };\n    }\n\n    cloneRow(row, idx, FILTER_COUNT){\n        const {IDX, DEPTH, COUNT} = this.meta;\n        const dolly = row.slice();\n        dolly[IDX] = idx + this.offset;\n\n        if (FILTER_COUNT && dolly[DEPTH] !== 0 && typeof dolly[FILTER_COUNT] === 'number'){\n            dolly[COUNT] = dolly[FILTER_COUNT];\n        }\n        return dolly;\n    }\n\n    applyGroupby(groupby, rows=this.data){\n        const { columns } = this;\n        this.groupRows.length = 0;\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        this.groupRows = groupRows(rows, this.sortSet, columns, this.columnMap, groupCols, {\n            groups: this.groupRows, rowParents: this.rowParents\n        });\n        this.currentLength = this.countVisibleRows(this.groupRows);\n    }\n\n    groupBy(groupby) {\n\n        if (groupbySortReversed(groupby, this.groupby)) {\n            this.sortGroupby(groupby);\n        } else if (groupbyExtendsExistingGroupby(groupby, this.groupby)) {\n            this.extendGroupby(groupby);\n            this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n        } else if (groupbyReducesExistingGroupby(groupby, this.groupby)) {\n            this.reduceGroupby(groupby);\n            this.range = NULL_RANGE;\n            this.iter.clear();\n            this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n        } else {\n            this.applyGroupby(groupby);\n        }\n        this.groupby = groupby;\n\n    }\n\n    // User interaction will never produce more than one change, but programatic change might !\n    //TODO if we have sortCriteria, apply to leaf rows as we expand\n    setGroupState(groupState) {\n        // onsole.log(`[groupRowSet.setGroupState] ${JSON.stringify(groupState,null,2)}`)\n        const changes = getGroupStateChanges(groupState, this.groupState);\n        changes.forEach(([key, ,isExpanded]) => {\n            const {groupRows} = this;\n            if (key === '*') {\n                this.toggleAll(isExpanded);\n                this.currentLength = this.countVisibleRows(groupRows, false);\n            } else {\n                const groupIdx= this.findGroupIdx(key);\n                if (groupIdx !== -1){\n                    if (isExpanded){\n                        this.currentLength += this.expandGroup(groupIdx, groupRows);\n                    } else {\n                        this.currentLength -= this.collapseGroup(groupIdx, groupRows);\n                    }\n                } else {\n                    console.warn(`setGroupState could not find row to toggle`);\n                }\n            }\n        });\n        this.groupState = groupState;\n    }\n\n    expandGroup(idx, groups){\n        return this.toggleGroup(idx, groups, this.countChildGroups);\n    }\n\n    collapseGroup(idx, groups){\n        return this.toggleGroup(idx, groups, this.collapseChildGroups);\n    }\n\n    toggleGroup(groupIdx, groupRows, processChildGroups){\n        const {DEPTH, COUNT, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        const groupRow = groupRows[groupIdx];\n        const depth = groupRow[DEPTH];\n        const useFilter = this.filterSet !== null;\n        groupRow[DEPTH] = -depth;\n        if (Math.abs(depth) === 1){\n            const COUNT_IDX = useFilter ? FILTER_COUNT : COUNT;\n            adjustment = groupRow[COUNT_IDX];\n        } else {\n            adjustment = processChildGroups(Math.abs(depth)-1, groupIdx+1, groupRows, useFilter);\n        }\n        return adjustment;\n    }\n\n    countChildGroups(childDepth, startIdx, groupRows, useFilter){\n        const {DEPTH, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        for (let i=startIdx; i<groupRows.length; i++){\n            const nextDepth = groupRows[i][DEPTH];\n            if (Math.abs(nextDepth) === childDepth){\n                if (!useFilter || groupRows[i][FILTER_COUNT] > 0){\n                    adjustment += 1;\n                }\n            } else if (Math.abs(nextDepth) > childDepth){\n                break;\n            }\n        }\n        return adjustment;\n    }\n\n    collapseChildGroups(childDepth, startIdx, groupRows, useFilter){\n        const {DEPTH, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        for (let i=startIdx; i<groupRows.length; i++){\n            const nextDepth = groupRows[i][DEPTH];\n            if (Math.abs(nextDepth) === childDepth){\n                if (!useFilter || groupRows[i][FILTER_COUNT] > 0){\n                    adjustment += 1;\n                    if (nextDepth > 0){\n                        adjustment += this.collapseGroup(i, groupRows);\n                    }\n                }\n            } else if (Math.abs(nextDepth) > childDepth){\n                break;\n            }\n        }\n        return adjustment;\n    }\n\n    sort(sortCriteria) {\n        const {groupRows: groups} = this;\n        const { IDX, DEPTH, COUNT, IDX_POINTER } = this.meta;\n        this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length\n            ? sortCriteria\n            : null;\n\n        const sortCols = mapSortCriteria(sortCriteria, this.columnMap);\n        //TODO only need to handle visible rows\n        for (let i=0;i<groups.length;i++){\n            const groupRow = groups[i];\n            const depth = groupRow[DEPTH];\n            const count = groupRow[COUNT];\n            const absDepth = Math.abs(depth);\n            const sortIdx = groupRow[IDX_POINTER];\n            if (absDepth === 1){\n                this.sortDataSubset(sortIdx, count, sortCols, IDX);\n\n            }\n        }\n    }\n\n    sortDataSubset(startIdx, length, sortCriteria, IDX){\n        const rows = [];\n        for (let i=startIdx;i<startIdx+length;i++){\n            const rowIdx = this.sortSet[i];\n            rows.push(this.data[rowIdx]);\n        }\n        rows.sort(sortBy(sortCriteria));\n        for (let i=0;i<rows.length;i++){\n            this.sortSet[i+startIdx] = rows[i][IDX];\n        }\n    }\n\n    clearFilter(/*cloneChanges*/) {\n        this.currentFilter = null;\n        this.filterSet = null;\n        // rebuild agregations for groups where filter count is less than count, remove filter count\n        const { data: rows, groupRows: groups, sortSet, columns } = this;\n        const { COUNT, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        const aggregations = findAggregatedColumns(columns, this.columnMap, this.groupby);\n\n        for (let i=0;i<groups.length; i++){\n            let groupRow = groups[i];\n            if (typeof groupRow[FILTER_COUNT] === 'number' && groupRow[COUNT] > groupRow[FILTER_COUNT]){\n                aggregateGroup(groups, i, sortSet, rows, columns, aggregations);\n                groupRow[FILTER_COUNT] = null;\n                groupRow[NEXT_FILTER_IDX] = null;\n            }\n        }\n\n        this.iter.setNavSet(this.selectNavigationSet(false));\n        this.currentLength = this.countVisibleRows(groups, false);\n    }\n\n    filter(filter){\n        const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n        const fn = filter && functor(this.columnMap, filter);\n        const { COUNT, DEPTH, PARENT_IDX, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        const { data: rows, groupRows: groups } = this;\n        let [navSet, NAV_IDX, NAV_COUNT] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet);\n        const newFilterSet= [];\n\n        for (let i=0;i<groups.length; i++){\n            let groupRow = groups[i];\n            const depth = groupRow[DEPTH];\n            const count = getCount(groupRow,NAV_COUNT, COUNT);\n            const absDepth = Math.abs(depth);\n\n            if (absDepth === 1){\n                const sortIdx = groupRow[NAV_IDX];\n                let rowCount = 0;\n\n                for (let ii=sortIdx; ii<sortIdx+count; ii++){\n                    const rowIdx = navSet[ii];\n                    const row = rows[rowIdx];\n                    const includerow = fn(row);\n                    if (includerow) {\n                        rowCount += 1;\n                        if (rowCount === 1){\n                            groupRow[NEXT_FILTER_IDX] = newFilterSet.length;\n                        }\n                        newFilterSet.push(rowIdx);\n                    }\n                }\n\n                groupRow[FILTER_COUNT] = rowCount;\n                let aggregations = EMPTY_ARRAY;\n                // we cannot be sure what filter changes have taken effect, so we must recalculate aggregations\n                if (this.aggregations.length){\n                    aggregations = this.aggregations.map(([i, a]) => [i,a,0]);\n                    const len = newFilterSet.length;\n                    for (let ii=len-rowCount;ii<len;ii++){\n                        const rowIdx = newFilterSet[ii];\n                        const row = rows[rowIdx];\n                        for (let j = 0; j < aggregations.length; j++) {\n                            let [colIdx] = aggregations[j];\n                            aggregations[j][2] += row[colIdx];\n                        }\n                    }\n                    \n                    // 2) store aggregates at lowest level of the group hierarchy\n                    aggregations.forEach(aggregation => {\n                        const [colIdx, type, sum] = aggregation;\n                        if (type === 'sum') {\n                            groupRow[colIdx] = sum;\n                        } else if (type === 'avg') {\n                            groupRow[colIdx] = sum / rowCount;\n                        }\n                    });\n                }\n\n                // update parent counts\n                if (rowCount > 0){\n                    while (groupRow[PARENT_IDX] !== null){\n                        groupRow = groups[groupRow[PARENT_IDX]];\n\n                        aggregations.forEach(aggregation => {\n                            const [colIdx, type, sum] = aggregation;\n                            if (type === 'sum') {\n                                groupRow[colIdx] += sum;\n                            } else if (type === 'avg') {\n                                const originalCount = groupRow[FILTER_COUNT];\n                                const originalSum = originalCount * groupRow[colIdx];\n                                groupRow[colIdx] = (originalSum + sum) / (originalCount + rowCount);\n                            }\n                        });\n                        groupRow[FILTER_COUNT] += rowCount;\n                    }\n                }\n\n            } else {\n                // Higher-level group aggregations are calculated from lower level groups\n                // initialize aggregated columns\n                groupRow[FILTER_COUNT] = 0;\n                this.aggregations.forEach(aggregation => {\n                    const [colIdx] = aggregation;\n                    groupRow[colIdx] = 0;\n                });\n            }\n        }\n        this.filterSet = newFilterSet;\n        this.currentFilter = filter;\n        this.currentLength = this.countVisibleRows(this.groupRows, true);\n\n        this.iter.setNavSet(this.selectNavigationSet(true));\n\n    }\n\n    update(rowIdx, updates){\n        const {groupRows: groups, offset, rowParents, range: {lo}} = this;\n        const { COUNT, FILTER_COUNT, PARENT_IDX } = this.meta;\n\n        let groupUpdates;\n        const rowUpdates = [];\n\n        for (let i = 0; i < updates.length; i += 3) {\n            // the col mappings in updates refer to base column definitions\n            const colIdx = updates[i];\n            const originalValue = updates[i + 1];\n            const value = updates[i + 2];\n            rowUpdates.push(colIdx,originalValue,value);\n\n            let grpIdx = rowParents[rowIdx];\n            // this seems to return 0 an awful lot\n            let ii = 0;\n            \n            // If this column is being aggregated\n            if (this.aggregatedColumn[colIdx]){\n\n                groupUpdates = groupUpdates || [];\n                // collect adjusted aggregations for each group level\n                do {\n                    let groupRow = groups[grpIdx];\n\n                    let originalGroupValue = groupRow[colIdx];\n                    const diff = value - originalValue;\n                    const type = this.aggregatedColumn[colIdx];\n                    if (type === 'sum'){\n                        // ... wnd in the groupRow we have a further offset of 2 ...\n                        groupRow[colIdx] += diff;// again with the +2\n                    } else if (type === 'avg'){\n                        const count = getCount(groupRow, FILTER_COUNT, COUNT);\n                        groupRow[colIdx] = ((groupRow[colIdx] * count) + diff) / count;\n                    }\n\n                    (groupUpdates[ii] || (groupUpdates[ii]=[grpIdx])).push(colIdx, originalGroupValue, groupRow[colIdx]);\n\n                    grpIdx = groupRow[PARENT_IDX];\n                    ii += 1;\n\n                } while (grpIdx !== null)\n\n            }\n        }\n\n        const outgoingUpdates = [];\n        // check rangeIdx for both row and group updates, if they are not in range, they have not been\n        // sent to client and do not need to be added to outgoing updates\n        if (groupUpdates){\n            // the groups are currently in reverse order, lets send them out outermost group first\n            for (let i=groupUpdates.length-1; i >=0; i--){\n                const [grpIdx, ...updates] = groupUpdates[i];\n                // won't work - need to chnage groupIterator\n                const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n                if (rangeIdx !== -1){\n                    outgoingUpdates.push([lo+rangeIdx+offset, ...updates]);\n                }\n            }\n        }\n        const rangeIdx = this.iter.getRangeIndexOfRow(rowIdx);\n        if (rangeIdx !== -1){\n            // onsole.log(`[GroupRowSet.update] updates for row idx ${idx} ${rangeIdx+offset} ${JSON.stringify(rowUpdates)}`)\n            outgoingUpdates.push([lo+rangeIdx+offset, ...rowUpdates]);\n        }\n        \n        return outgoingUpdates;\n    }\n\n    insert(newRowIdx, row){\n        // TODO look at append and idx manipulation for insertion at head. See insertDeprecated\n        const { groupRows: groups, groupby, data: rows, sortSet, columns, meta, iter: iterator } = this;\n        let groupCols = mapSortCriteria(groupby, this.columnMap);\n        const groupPositions = findGroupPositions(groups, groupCols, row);\n        const {IDX, COUNT, KEY, IDX_POINTER} = meta;\n        const GROUP_KEY_SORT = [[KEY, 'asc']];\n        const allGroupsExist = groupPositions.length === groupby.length;\n        const noGroupsExist = groupPositions.length === 0;\n        const someGroupsExist = !noGroupsExist && !allGroupsExist;\n        let result;\n        let newGroupIdx = null;\n\n        if (allGroupsExist){\n            // all necessary groups are already in place, we will just insert a row and update counts/aggregates\n            let grpIdx = groupPositions[groupPositions.length-1];\n            const groupRow = groups[grpIdx];\n            this.rowParents[newRowIdx] = grpIdx;\n            let count = groupRow[COUNT];\n\n            const insertionPoint = groupRow[IDX_POINTER] + count;\n            // all existing pointers from the insertionPoint forward are going to be displaced by +1\n            adjustLeafIdxPointers(groups, insertionPoint, meta);\n            sortSet.splice(insertionPoint,0,row[IDX]);\n            if (allGroupsExpanded(groups, groupRow, meta)){\n                this.currentLength += 1;\n            }\n            \n        } else {\n\n            newGroupIdx = sortPosition(groups, sortBy(GROUP_KEY_SORT), expandRow(groupCols, row, meta), 'last-available');\n            sortSet.push(newRowIdx);\n            let nestedGroups, baseGroupby, rootIdx;\n\n            if (someGroupsExist){\n                baseGroupby = groupCols.slice(0,groupPositions.length);\n                rootIdx = groups[groupPositions[groupPositions.length-1]][IDX];\n                groupCols = groupCols.slice(groupPositions.length);\n            }\n\n            nestedGroups = groupRows(rows, sortSet, columns, this.columnMap, groupCols, {\n                startIdx: sortSet.length - 1, length: 1, groupIdx: newGroupIdx-1,\n                baseGroupby, rootIdx\n            });\n\n            adjustGroupIndices(groups, newGroupIdx, meta, nestedGroups.length);\n            groups.splice.apply(groups,[newGroupIdx,0].concat(nestedGroups));\n        }\n\n        this.incrementGroupCounts(groupPositions);\n\n        iterator.refresh(); // force iterator to rebuild rangePositions\n        let rangeIdx = allGroupsExist\n            ? iterator.getRangeIndexOfRow(newRowIdx)\n            : iterator.getRangeIndexOfGroup(newGroupIdx);\n        if (rangeIdx !== -1){\n            result = {replace: true};\n            if (newGroupIdx !== null){\n                this.currentLength += 1;\n            }\n        } else if (noGroupsExist === false){\n            result = {updates: this.collectGroupCountUpdates(groupPositions)};\n        }\n\n        return result;\n    }\n\n    incrementGroupCounts(groupPositions){\n        const {groupRows: groups, meta:{COUNT}} = this;\n        groupPositions.forEach(grpIdx => {\n            const group = groups[grpIdx];\n            group[COUNT] += 1;\n        });\n    }\n\n    collectGroupCountUpdates(groupPositions){\n        const {groupRows: groups, meta:{COUNT}, offset} = this;\n        const updates = [];\n        for (let i=0;i<groupPositions.length;i++){\n            const grpIdx = groupPositions[i];\n            const count = groups[grpIdx][COUNT];\n            const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n            if (rangeIdx !== -1){\n                updates.push([rangeIdx+offset, COUNT, count]);\n            }\n        }\n        return updates;\n    }\n\n    // start with a simplesequential search\n    findGroupIdx(groupKey){\n        const {groupRows, meta} = this;\n        for (let i=0;i<groupRows.length;i++){\n            if (groupRows[i][meta.KEY] === groupKey){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //TODO simple implementation first\n    toggleAll(isExpanded) {\n        const sign = isExpanded ? 1 : -1;\n        // iterate groupedRows and make every group row depth positive,\n        // Then visible rows is not going to be different from grouped rows\n        const {DEPTH} = this.meta;\n        const { groupRows: groups } = this;\n        this.expandedByDefault = isExpanded;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            const depth = groups[i][DEPTH];\n            // if (depth !== 0) {\n            groups[i][DEPTH] = Math.abs(depth) * sign;\n            // }\n        }\n    }\n\n    sortGroupby(groupby){\n        const { IDX, KEY, DEPTH, IDX_POINTER, PARENT_IDX } = this.meta;\n        const {groupRows: groups} = this;\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        const [colIdx, depth] = findSortedCol(groupby, this.groupby);\n        let count = 0;\n        let i=0;\n        for (;i<groups.length;i++){\n            if (Math.abs(groups[i][DEPTH]) > depth){\n                if (count > 0){\n                    this.sortGroupRowsSubset(groupCols, colIdx, i-count, count);\n                    count = 0;\n                }\n            } else {\n                count += 1;\n            }\n        }\n\n        this.sortGroupRowsSubset(groupCols, colIdx, i-count, count);\n\n        const tracker = new SimpleTracker(groupby.length);\n        this.groupRows.forEach((groupRow,i) => {\n            const depth = groupRow[DEPTH];\n            const groupKey = groupRow[KEY];\n            const absDepth = Math.abs(depth);\n            tracker.set(absDepth, i, groupKey);\n            groupRow[IDX] = i;\n            if (absDepth > 1){\n                groupRow[IDX_POINTER] = i+1;\n            }\n            if (tracker.hasParentPos(absDepth)){\n                groupRow[PARENT_IDX] = tracker.parentPos(absDepth);\n            }\n        });\n    }\n\n    sortGroupRowsSubset(groupby, colIdx, startPos=0, length=this.groupRows.length){\n        const {groupRows: groups} = this;\n        let insertPos = startPos + length;\n        const [groupColIdx, direction] = groupby[colIdx];\n        const before = (k1, k2) => direction === ASC ? k2 > k1 : k1 > k2;\n        const after = (k1, k2) => direction === ASC ? k2 < k1 : k1 < k2;\n        let currentKey = null;\n        for (let i=startPos;i<startPos+length;i++){\n            const key = groups[i][groupColIdx];\n            if (currentKey === null){\n                currentKey = key;\n            } else if (before(key,currentKey)){\n                const splicedRows = groups.splice(startPos,i-startPos);\n                insertPos -= splicedRows.length;\n                groups.splice.apply(groups, [insertPos,0].concat(splicedRows));\n                currentKey = key;\n                i = startPos-1;\n            } else if (after(key,currentKey)){\n                break;\n            }\n        }\n    }\n\n    // there is a current assumption here that new col(s) are always added at the end of existing cols in the groupBy\n    // Need to think about a new col inserted at start or in between existing cols \n    //TODO we might want to do this on expanded nodes only and repat in a lazy fashion as more nodes are revealed\n    extendGroupby(groupby) {\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        const baseGroupCols = groupCols.slice(0, this.groupby.length);\n        const newGroupbyClause = groupCols.slice(this.groupby.length);\n        const {groupRows: groups, groupby: baseGroupby, data: rows, columns, sortSet, filterSet, meta} = this;\n        const { IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = meta;\n        const baseLevels = baseGroupby.length;\n        const tracker = new GroupIdxTracker(baseLevels-1);\n        const filterFn = this.currentFilter\n            ? functor(this.columnMap, this.currentFilter)\n            : null;\n\n        // we are going to insert new rows into groupRows and update the PARENT_IDX pointers in data rows\n        for (let i=0;i<groups.length;i++){\n            const groupRow = groups[i];\n            if (tracker.idxAdjustment){\n                groupRow[meta.IDX] += tracker.idxAdjustment;\n            }\n\n            const rootIdx = groupRow[meta.IDX];\n            const depth = groupRow[meta.DEPTH];\n            const length = groupRow[meta.COUNT];\n            const groupKey = groupRow[meta.KEY];\n\n            const absDepth = Math.abs(depth);\n            groupRow[meta.DEPTH] = incrementDepth(depth);\n            const filterLength = groupRow[meta.FILTER_COUNT];\n            const filterIdx = groupRow[NEXT_FILTER_IDX];\n            groupRow[meta.NEXT_FILTER_IDX] = undefined;\n\n            if (tracker.hasPrevious(absDepth+1)){\n                groupRow[PARENT_IDX] += tracker.previous(absDepth+1);\n            }\n\n            if (absDepth === 1){\n                const startIdx = groupRow[IDX_POINTER];\n                const nestedGroupRows = groupRows(rows, sortSet, columns, this.columnMap, newGroupbyClause, {\n                    startIdx,\n                    length,\n                    rootIdx,\n                    baseGroupby: baseGroupCols,\n                    groupIdx: rootIdx,\n                    filterIdx,\n                    filterLength,\n                    filterSet,\n                    filterFn,\n                    rowParents: this.rowParents\n                });\n                const nestedGroupCount = nestedGroupRows.length;\n                // this might be a performance problem for large arrays, might need to concat\n                groups.splice(i+1,0, ...nestedGroupRows);\n                i += nestedGroupCount;\n                tracker.increment(nestedGroupCount);\n            } else {\n                tracker.set(absDepth, groupKey);\n            }\n            // This has to be a pointer into sortSet NOT rows\n            groupRow[IDX_POINTER] = rootIdx+1;\n        }\n    }\n\n    reduceGroupby(groupby) {\n        const { groupRows: groups, filterSet } = this;\n        const [doomed] = findDoomedColumnDepths(groupby, this.groupby);\n        const groupCols = mapSortCriteria(this.groupby, this.columnMap);\n        const [lastGroupIsDoomed, baseGroupby, addGroupby] = splitGroupsAroundDoomedGroup(groupCols, doomed);\n        const { IDX, DEPTH, KEY, IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = this.meta;\n        const tracker = new GroupIdxTracker(groupby.length);\n        const useFilter = filterSet !== null;\n        let currentGroupIdx = null;\n        let i = 0;\n        for (let len=groups.length;i<len;i++){\n            const groupRow = groups[i];\n            const depth = groupRow[DEPTH];\n            const groupKey = groupRow[KEY];\n            const absDepth = Math.abs(depth);\n\n            if (absDepth === doomed){\n                this.reParentLeafRows(i, currentGroupIdx);\n                groups.splice(i,1);\n                i -= 1;\n                len -= 1;\n                tracker.increment(1);\n            } else {\n                if (absDepth > doomed){\n                    tracker.set(absDepth,groupKey);\n                    if (absDepth === doomed + 1){\n                        if (lastGroupIsDoomed){\n                            // our pointer will no longer be to a child group but (via the sortSet) to the data.\n                            // This can be taken from the first child group (which will be removed)\n                            groupRow[IDX_POINTER] = lowestIdxPointer(groups, IDX_POINTER, DEPTH, i+1, absDepth-1);\n                            groupRow[NEXT_FILTER_IDX] = useFilter ? lowestIdxPointer(groups, NEXT_FILTER_IDX, DEPTH, i+1, absDepth-1) : undefined;\n                        } else if (currentGroupIdx !== null){\n                            const diff = this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n                            i -= diff;\n                            len -= diff;\n                            tracker.increment(diff);\n                        }\n                    }\n                    currentGroupIdx = i;\n                    if (tracker.hasPrevious(absDepth+1)){\n                        groupRow[PARENT_IDX] -= tracker.previous(absDepth+1);\n                    }\n                    groupRow[DEPTH] = decrementDepth(depth);\n                }\n                if (tracker.idxAdjustment > 0){\n                    groupRow[IDX] -= tracker.idxAdjustment;\n                    if (Math.abs(groupRow[DEPTH]) > 1){\n                        groupRow[IDX_POINTER] -= tracker.idxAdjustment;\n                    }\n                }\n            }\n        }\n        if (!lastGroupIsDoomed){\n            // don't forget the final group ...\n            this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n        }\n    }\n\n    reParentLeafRows(groupIdx, newParentGroupIdx){\n        // TODO what about filterSet ?\n        const {groupRows: groups, rowParents, sortSet, meta: {IDX_POINTER, COUNT}} = this;\n        const group = groups[groupIdx];\n        const idx = group[IDX_POINTER];\n        const count = group[COUNT];\n\n        for (let i=idx; i< idx+count; i++){\n            const rowIdx = sortSet[i];\n            rowParents[rowIdx] = newParentGroupIdx; \n        }\n\n    }\n\n    regroupChildGroups(currentGroupIdx, nextGroupIdx, baseGroupby, addGroupby){\n        const { groupRows: groups, data: rows, columns, meta } = this;\n        const { COUNT, IDX_POINTER } = meta;\n        const group = groups[currentGroupIdx];\n        const length = group[COUNT];\n        const startIdx = groups[currentGroupIdx+1][IDX_POINTER];\n        // We don't really need to go back to rows to regroup, we have partially grouped data already\n        // we could perform the whole operation within groupRows\n        const nestedGroupRows = groupRows(rows, this.sortSet, columns, this.columnMap, addGroupby, {\n            startIdx,\n            length,\n            rootIdx: currentGroupIdx,\n            baseGroupby,\n            groupIdx: currentGroupIdx,\n            rowParents: this.rowParents\n        });\n        const existingChildNodeCount = nextGroupIdx - currentGroupIdx - 1;\n        groups.splice(currentGroupIdx+1,existingChildNodeCount,...nestedGroupRows);\n        group[IDX_POINTER] = currentGroupIdx+1;\n        return existingChildNodeCount - nestedGroupRows.length;\n\n    }\n\n    // Note: this assumes no leaf rows visible. Is that always valid ?\n    // NOt after removing a groupBy ! Not after a filter\n    countVisibleRows(groupRows, usingFilter=false){\n        const {DEPTH, COUNT, FILTER_COUNT} = this.meta;\n        let count = 0;\n        for (let i=0, len=groupRows.length;i<len;i++){\n            const zeroCount = usingFilter && groupRows[i][FILTER_COUNT] === 0;\n            if (!zeroCount){\n                count += 1;\n            }\n            const depth = groupRows[i][DEPTH];\n            if (depth < 0 || zeroCount){\n                while (i<len-1 && Math.abs(groupRows[i+1][DEPTH]) < -depth){\n                    i += 1;\n                }\n            } else if (depth === 1){\n                count += (usingFilter ? groupRows[i][FILTER_COUNT] : groupRows[i][COUNT]);\n            }\n        }\n        return count;\n    }\n\n}\n\n/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nclass UpdateQueue {\n\n    constructor(){\n        this._queue = [];\n    }\n\n      get length() { return this._queue.length; }\n\n      update(update) {\n          //TODO we could also coalesce updates into an insert or rowset, if present\n          const batch = this.getCurrentBatch('update');\n\n          const [rowIdx] = update;\n          const {updates} = batch;\n\n          for (let i = 0, len = updates.length; i < len; i++) {\n              if (updates[i][0] === rowIdx) {\n                  // we already have an update for this item, update the update...\n                  let d = updates[i];\n                  for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n                      const pos = d.indexOf(update[colIdx]);\n                      if (pos === -1) {// should check that it is really a colIdx,not a value\n                          d.push(update[colIdx], update[colIdx + 1]);\n                      } else {\n                          d[pos + 1] = update[colIdx + 1];\n                      }\n                  }\n\n                  return;\n              }\n          }\n          updates.push(update);\n      }\n\n      resize(size) {\n          const batch = this.getCurrentBatch('size');\n          batch.size = size;\n      }\n\n      append(row, offset) {\n          const batch = this.getCurrentBatch('insert');\n          //onsole.log(`UpdateQueue append ${row[0]}`);\n          batch.rows.push(row);\n          batch.offset = offset;\n      }\n\n      replace(rows, size, offset) {\n          const batch = this.getCurrentBatch('rowset');\n          batch.rows = rows;\n          batch.size = size;\n          batch.offset = offset;\n      }\n\n      popAll() {\n          const results = this._queue;\n          this._queue = [];\n          return results;\n      }\n\n      getCurrentBatch(type) {\n\n          const q = this._queue;\n          const len = q.length;\n\n          let batch = len === 0 || type === 'rowset'\n              ? (q[0] = createBatch(type))\n              : q[len - 1];\n\n          if (batch.type !== type) {\n              // roll size recored into subsequent insert \n              if (type === 'insert' && batch.type === 'size') {\n                  batch.type = 'insert';\n                  batch.rows = [];\n              } else if (type === 'size' && batch.type === 'insert') ; else {\n                  batch = (q[len] = createBatch(type));\n              }\n          }\n\n          return batch;\n\n      }\n  }\n\nfunction createBatch(type) {\n    switch (type) {\n    case 'rowset': return { type, rows: [] };\n    case 'update': return { type, updates: [] };\n    case 'insert': return { type, rows: [] };\n    case 'size': return { type };\n    default: throw Error('Unknown batch type');\n    }\n}\n\nconst DEFAULT_INDEX_OFFSET = 100;\n\nclass DataView {\n\n    constructor(table, { columns = [], sortCriteria = null, groupBy = null, filter = null }, updateQueue = new UpdateQueue()) {\n        this._table = table;\n        this._index_offset = DEFAULT_INDEX_OFFSET;\n        this._filter = filter;\n        this._groupState = null;\n        this._sortCriteria = sortCriteria;\n\n        this._columns = null;\n        this._columnMap = null;\n        // column defs come from client, this is where we assign column keys\n        this.columns = columns;\n\n        this._groupby = groupBy;\n        this._update_queue = updateQueue;\n        // TODO we should pass columns into the rowset as it will be needed for computed columns\n        this.rowSet = new RowSet(table, this._columns, this._index_offset);\n        this.filterRowSet = null;\n\n        // What if data is BOTH grouped and sorted ...\n        if (groupBy !== null) {\n            // more efficient to compute this directly from the table projection\n            this.rowSet = new GroupRowSet(this.rowSet, this._columns, this._groupby, this._groupState);\n        } else if (this._sortCriteria !== null) {\n            this.rowSet.sort(this._sortCriteria);\n        }\n\n        this.rowUpdated = this.rowUpdated.bind(this);\n        this.rowInserted = this.rowInserted.bind(this);\n\n        table.on('rowUpdated', this.rowUpdated);\n        table.on('rowInserted', this.rowInserted);\n\n    }\n\n    // Set the columns from client\n    set columns(columns) {\n        this._columns = columns.map(toColumn);\n        this._columnMap = buildColumnMap(this._columns);\n    }\n\n    destroy() {\n        this._table.removeListener('rowUpdated', this.rowUpdated);\n        this._table.removeListener('rowUpdated', this.rowInserted);\n        this._table = null;\n        this.rowSet = null;\n        this.filterRowSet = null;\n        this._update_queue = null;\n    }\n\n    get status() {\n        return this._table.status;\n    }\n\n    rowInserted(event, idx, row) {\n        const { _update_queue, rowSet } = this;\n        const { size = null, replace, updates } = rowSet.insert(idx, row);\n        if (size !== null) {\n            _update_queue.resize(size);\n        }\n        if (replace) {\n            const { rows, size, offset } = rowSet.currentRange();\n            _update_queue.replace(rows, size, offset);\n        } else if (updates) {\n            updates.forEach(update => {\n                _update_queue.update(update);\n            });\n\n        }\n        // what about offset change only ?\n    }\n\n    rowUpdated(event, idx, updates) {\n        const { rowSet, _update_queue } = this;\n        // const {range, rowSet} = _row_data;\n        const result = rowSet.update(idx, updates);\n        if (result) {\n            if (rowSet instanceof RowSet) {\n                // we wouldn't have got the update back if it wasn't in range\n                if (withinRange(rowSet.range, result[0], rowSet.offset)) {\n                    _update_queue.update(result);\n                }\n            } else {\n                result.forEach(rowUpdate => {\n                    //TODO pretty sure we've already checked the range within the rowset itself\n                    if (withinRange(rowSet.range, rowUpdate[0], rowSet.offset)) {\n                        _update_queue.update(rowUpdate);\n                    }\n                });\n            }\n        }\n    }\n\n    getData(dataType) {\n        return dataType === DataTypes.ROW_DATA\n            ? this.rowSet\n            : dataType === DataTypes.FILTER_DATA\n                ? this.filterRowSet\n                : null;\n    }\n\n    //TODO we seem to get a setRange when we reverse sort order, is that correct ?\n    setRange(range, useDelta = true, dataType = DataTypes.ROW_DATA) {\n        return this.getData(dataType).setRange(range, useDelta);\n    }\n\n    select(idx, rangeSelect, keepExistingSelection){\n        console.log(`InMemoryView.select ${idx} rangeSelect:${rangeSelect}, keepExistingSelection: ${keepExistingSelection}`);\n        return this.rowSet.select(idx, rangeSelect, keepExistingSelection);\n        //TODO eliminate rows not in range\n    \n    }\n\n    sort(sortCriteria) {\n        this._sortCriteria = sortCriteria;\n        this.rowSet.sort(sortCriteria);\n        // assuming the only time we would not useDelta is when we want to reset ?\n        return this.setRange(resetRange(this.rowSet.range), false);\n    }\n\n    filter(filter, dataType=DataTypes.ROW_DATA, incremental=false) {\n        if (dataType === DataTypes.FILTER_DATA){\n\n            return [undefined,this.filterFilterData(filter)];\n        \n        } else {\n            if (incremental){\n                filter = addFilter(this._filter, filter);\n            }\n            const { rowSet, _filter, filterRowSet } = this;\n            const { range } = rowSet;\n            this._filter = filter;\n            let filterResultset;\n            let filterCount = rowSet.totalCount;\n    \n            if (filter === null && _filter) {\n                rowSet.clearFilter();\n            } else if (filter){\n                filterCount = this.rowSet.filter(filter);\n            } else {\n                throw Error(`InMemoryView.filter setting null filter when we had no filter anyway`);\n            }\n    \n            if (filterRowSet) {\n                if (filter){\n                    filterResultset = filterRowSet.setSelected(filter, filterCount);\n                } else {\n                    // TODO examine this. Must be a more efficient way to reset counts in filterSet\n                    const {columnName, range} = filterRowSet;\n                    this.filterRowSet = rowSet.getDistinctValuesForColumn({name:columnName});\n                    filterResultset = this.filterRowSet.setRange(range, false);\n                }\n            }\n    \n            const resultSet = {\n                ...(this.rowSet.setRange(resetRange(range), false)),\n                filter\n            };\n    \n            return filterResultset\n                ? [resultSet, filterResultset]\n                : [resultSet];\n        }\n\n    }\n\n    groupBy(groupby) {\n        const { rowSet, _columns, _groupState, _sortCriteria, _groupby } = this;\n        const { range: _range } = rowSet;\n        this._groupby = groupby;\n\n        if (groupby === null) {\n            this.rowSet = RowSet.fromGroupRowSet(this.rowSet);\n        } else {\n            if (_groupby === null) {\n                this.rowSet = new GroupRowSet(rowSet, _columns, groupby, _groupState, _sortCriteria);\n            } else {\n                rowSet.groupBy(groupby);\n            }\n        }\n        return this.rowSet.setRange(_range, false);\n    }\n\n    setGroupState(groupState) {\n        this._groupState = groupState;\n        const { rowSet } = this;\n        rowSet.setGroupState(groupState);\n        // TODO should we have setRange return the following directly, so IMV doesn't have to decide how to call setRange ?\n        // should we reset the range ?\n        return rowSet.setRange(rowSet.range, false);\n    }\n\n    get updates() {\n        const { _update_queue, rowSet: { range } } = this;\n        let results = {\n            updates: _update_queue.popAll(),\n            range: {\n                lo: range.lo,\n                hi: range.hi\n            }\n        };\n        return results;\n    }\n\n    getFilterData(column, searchText = null, range) {\n        console.log(`getFilterData searchText='${searchText}'`);\n        const { rowSet, filterRowSet, _filter: filter, _columnMap } = this;\n        // If our own dataset has been filtered by the column we want values for, we cannot use it, we have\n        // to go back to the source, using a filter which excludes the one in place on the target column. \n        const columnName = column.name;\n        const colDef = this._columns.find(col => col.name === columnName);\n        // No this should be decided beforehand (on client) \n        const type = getFilterType(colDef);\n\n        if (type === 'number') {\n            // // we need a notification from server to tell us when this is closed.\n            // we should assign to filterRowset\n            this.filterRowSet = rowSet.getBinnedValuesForColumn(column);\n\n        } else if (!filterRowSet || filterRowSet.columnName !== column.name) {\n\n            this.filterRowSet = rowSet.getDistinctValuesForColumn(column);\n\n        } else if (searchText) {\n            filterRowSet.searchText = searchText;\n\n        } else if (filterRowSet && filterRowSet.searchText) {\n            // reset the filter\n            filterRowSet.clearFilter();\n\n        } else if (filter && filter.colName === column.name) {\n            // if we already have the data for this filter, nothing further to do except reset the filterdata range\n            // so next request will return full dataset.\n            filterRowSet.setRange({ lo: 0, hi: 0 });\n        }\n\n        if (filter) {\n            this.filterRowSet.setSelected(filter, this.rowSet.filterCount);\n        }\n\n        // do we need to returtn searchText ? If so, it should\n        // be returned by the rowSet\n        return this.filterRowSet.setRange(range, false);\n\n    }\n\n    filterFilterData(filter){\n        const {filterRowSet} = this;\n        if (filterRowSet){\n\n            if (filter === null) {\n                filterRowSet.clearFilter();\n            } else if (filter){\n                filterRowSet.filter(filter);\n            }\n            return filterRowSet.setRange(resetRange(filterRowSet.range), false);\n    \n        } else {\n            console.error(`[InMemoryView] filterfilterRowSet no filterRowSet`);\n        }\n\n    }\n\n}\n\n/*\n  See UpdateQueue\n*/\n\nclass UpdateQueue$1 extends EventEmitter {\n\n    update(update) {\n        this.emit('update', [update]);\n    }\n\n    resize(size) {\n        console.log(`localUpdateQueue resize ${JSON.stringify(size)}`);\n    }\n\n    append(row, offset) {\n        console.log(`localUpdateQueue append ${JSON.stringify(row)} offset ${offset}`);\n    }\n\n    replace({rows, size, offset}) {\n        console.log(`localUpdateQueue replace ${JSON.stringify(rows)} size ${size} offset ${offset}`);\n        this.emit(DataTypes.ROW_DATA, rows, size, offset);\n    }\n\n    popAll() {\n        console.log(`localUpdateQueue popAll`);\n    }\n}\n\nconst buildDataView = async url =>\n  import(/* webpackIgnore: true */ url)\n    .catch(err => console.log(`failed to load data at ${url} ${err}`));\n\nconst logger = createLogger('LocalDataView', logColor.blue);\n\nclass LocalDataView {\n  constructor({\n    url,\n    tableName\n  }) {\n    // note: don't wait\n    logger.log(`lets try and load ${url}`);\n    this.eventualView = buildDataView(url);\n    this.columns = null;\n    this.meta = null;\n\n    this.tableName = tableName;\n    this.subscription = null;\n    this.viewport = null;\n    this.filterDataCallback = null;\n    this.filterDataMessage = null;\n\n    this.updateQueue = new UpdateQueue$1();\n    this.dataView = null;\n    this.clientCallback = null;\n    this.range = null;\n  }\n\n  async subscribe({\n    tableName = this.tableName,\n    columns,\n    // range = defaultRange,\n    // ...options\n  }, callback) {\n\n    if (!columns) throw Error(\"LocalDataView subscribe called without columns\");\n    \n    // TODO options can include sort, groupBy etc\n    \n    this.tableName = tableName;\n    this.columns = columns;\n    this.meta = metaData(columns);\n\n    const { default: data } = await this.eventualView;\n    const table = new Table({ data, columns });\n    this.dataView = new DataView(table, {columns}, this.updateQueue);\n    this.clientCallback = callback;\n\n    if (this.range){\n      this.setRange(this.range.lo, this.range.hi);\n    }\n  }\n\n  unsubscribe() {\n\n  }\n\n  setRange(lo, hi) {\n    if (this.dataView === null){\n      this.range = {lo,hi};\n    } else {\n      this.clientCallback(this.dataView.setRange({lo, hi}, true, DataTypes.ROW_DATA));\n    }\n  }\n\n  select(idx, _row, rangeSelect, keepExistingSelection) {\n    this.clientCallback(this.dataView.select(idx, rangeSelect, keepExistingSelection));\n  }\n\n  group(columns) {\n    this.clientCallback(this.dataView.groupBy(columns));\n  }\n\n  setGroupState(groupState) {\n    this.clientCallback(this.dataView.setGroupState(groupState));\n  }\n\n  sort(columns) {\n    this.clientCallback(this.dataView.sort(columns));\n  }\n\n  filter(filter, dataType = DataTypes.ROW_DATA, incremental = false) {\n    // TODO filter call returns an array\n    const [rowData, filterData] = this.dataView.filter(filter, dataType, incremental);\n    this.clientCallback(rowData);\n    if (filterData){\n      if (this.clientFilterCallback){\n        this.clientFilterCallback({filterData});\n      } else {\n        this.filterDataMessage = filterData;\n      }\n      }\n  }\n\n  getFilterData(column, searchText) {\n      const filterData =  this.dataView.getFilterData(column, searchText);\n      if (this.clientFilterCallback){\n        this.clientFilterCallback({filterData});\n      } else {\n        this.filterDataMessage = {filterData};\n      }\n    }\n\n  subscribeToFilterData(column, range, callback) {\n    logger.log(`<subscribeToFilterData>`);\n    this.clientFilterCallback = callback;\n    this.setFilterRange(range.lo, range.hi);\n    if (this.filterDataMessage) {\n      callback(this.filterDataMessage);\n      // do we need to nullify now ?\n    }\n  }\n\n  unsubscribeFromFilterData() {\n    logger.log(`<unsubscribeFromFilterData>`);\n    this.clientFilterCallback = null;\n  }\n\n  // To support multiple open filters, we need a column here\n  setFilterRange(lo, hi) {\n    const message = {\n      filterData: this.dataView.setRange({lo, hi}, true, DataTypes.FILTER_DATA)\n    };\n\n    if (this.clientFilterCallback){\n      this.clientFilterCallback(message);\n    } else {\n      this.filterDataMessage = message;\n    }\n  }\n\n}\n\n//TODO neither this file nor filter-data-view belong here - thye are not specific to remote views\n\nconst logger$1 = createLogger('BinnedDataView', logColor.brown);\n\nclass BinnedDataView {\n\n  constructor(dataView, column) {\n    this.dataView = dataView;\n    this.column = column;\n    this.dataCountCallback = null;\n  }\n\n  subscribe({range}, callback) {\n    logger$1.log(`<subscribe>`);\n\n    this.dataView.subscribeToFilterData(this.column, range, message => {\n\n      logger$1.log(`callback ${JSON.stringify(message.null, 2)}`);\n      const {filterData} = message;\n      const {rows, size, range} = filterData;\n\n      logger$1.log(`receive rows ${rows.length} of ${size} range ${JSON.stringify(range)}`, message);\n\n      // const mergedRows = this.processData(rows, size, 0)\n\n      callback(rows);\n\n      // if (this.dataCountCallback){\n      //     this.dataCountCallback(dataCounts);\n      // }\n\n\n    });\n\n  }\n\n  destroy(){\n    logger$1.log(`<destroy>`);\n    this.dataView.unsubscribeFromFilterData(this.column);\n}\n\n}\n\nconst logger$2 = createLogger('FilterDataView', logColor.brown);\n\nclass FilterDataView {\n\n  constructor(dataView, column){\n        this.dataView = dataView;\n        this.column = column;\n        this.dataCountCallback = null;\n    }\n\n    subscribe({columns, range}, callback){\n\n        this.columns = columns;\n        this.meta = metaData(columns);\n        //TODO make range s setter\n        this.range = range;\n        this.keyCount = range.hi - range.lo;\n\n        this.dataView.subscribeToFilterData(this.column, this.range, message => {\n            const {filterData: {dataCounts, ...data}} = message;\n            callback(data);\n            if (this.dataCountCallback){\n                this.dataCountCallback(dataCounts);\n            }    \n        });\n    }\n\n    subscribeToDataCounts(callback){\n        this.dataCountCallback = callback;\n    }\n    unsubscribeFromDataCounts(){\n        this.dataCountCallback = null;\n    }\n\n    unsubscribe(){\n        this.dataView.unsubscribeFromFilterData();\n    }\n\n    destroy(){\n        logger$2.log(`<destroy>`);\n        this.dataView.unsubscribeFromFilterData(this.column);\n    }\n\n    // onFilterData = (_, rows, rowCount, totalCount, dataCounts) => {\n    //     this.emit(DataTypes.ROW_DATA, rows, rowCount, totalCount, dataCounts);\n    // }\n\n    select(idx, row){\n        const {KEY, SELECTED} = this.meta;\n        const key = row[KEY];\n    \n        const filter = {\n            type: row[SELECTED] === 1 ? NOT_IN : IN,\n            colName: this.column.name,\n            values: [key]\n        };\n        // This is enough to filter rows and populate filter display - but how can we add filter markers to UI ?\n        this.dataView.filter(filter, DataTypes.ROW_DATA, true);\n    \n    }\n\n    filter(filter, dataType = DataTypes.FILTER_DATA, incremental=false){\n        this.dataView.filter(filter, dataType, incremental);\n    }\n\n    getFilterData(column, searchText){\n        console.log(`FilterDataView.getFilterData ${JSON.stringify(column)} ${searchText}`);\n        this.dataView.getFilterData(column, searchText);\n    }\n\n    // TODO we need a filter method to filter results to omit zero value filterCount - call getFilterData on view, passing filter\n\n    setRange(lo, hi){\n      this.range = { lo, hi };\n      this.dataView.setFilterRange(lo,hi);\n    }\n\n    sort(){\n        \n    }\n  \n}\n\nconst groupHelpers = {\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby\n};\n\nconst sortUtils = {\n  sortByToMap\n};\n\nconst columnUtils = {\n  buildColumnMap,\n  getFilterType,\n  toColumn,\n  toKeyedColumn,\n  metaData,\n  setFilterColumnMeta\n};\n\nconst rowUtils = {\n  isEmptyRow, mergeAndPurge, purgeAndFill, update\n};\n\nconst filter = {\n  AND,\n  OR,\n  IN,\n  NOT_IN,\n  STARTS_WITH,\n  NOT_STARTS_WITH,\n  shouldShowFilter,\n  addFilter,\n  extractFilterForColumn,\n  removeFilterForColumn,\n  getFilterColumn,\n  includesColumn,\n  SET_FILTER_DATA_COLUMNS,\n  BIN_FILTER_DATA_COLUMNS\n};\n\nconst rangeUtils = {\n  getFullRange,\n  resetRange\n};\n\nconst arrayUtils = {\n  partition\n};\n\nconst DataTypes$1 = DataTypes;\n\nconst ASC$1 = ASC;\nconst DSC$1 = DSC;\nconst NULL_RANGE$1 = NULL_RANGE;\n\nexport { ASC$1 as ASC, BinnedDataView, DSC$1 as DSC, DataTypes$1 as DataTypes, DataView, FilterDataView, LocalDataView, NULL_RANGE$1 as NULL_RANGE, Table, arrayUtils, columnUtils, filter, groupHelpers, rangeUtils, rowUtils, sortUtils };\n//# sourceMappingURL=index.es.js.map\n","\nimport { rangeUtils, DataTypes } from '@heswell/data';\n\nconst EMPTY_ARRAY = [];\nconst ROWSET = 'rowset';\nconst UPDATE = 'update';\nconst FILTER_DATA = 'filterData';\n\nexport default class MessageQueue {\n\n    constructor() {\n        this._queue = [];\n    }\n\n    get length() { return this._queue.length; }\n    set length(val) { this._queue.length = val; }\n    get queue() {\n        const q = this._queue.slice();\n        this._queue.length = 0;\n        return q;\n    }\n\n    push(message, meta) {\n        const { type, data } = message;\n        if (type === UPDATE) {\n            mergeAndPurgeUpdates(this._queue, message);\n        } else if (type === ROWSET) {\n            if (message.data.rows.length === 0 && message.size > 0) {\n                return;\n            }\n            mergeAndPurgeRowset(this._queue, message, meta);\n\n        } else if (type === FILTER_DATA && data.type !== DataTypes.FILTER_BINS) {\n            mergeAndPurgeFilterData(this._queue, message, meta);\n        } else {\n            //onsole.log(`MessageQueue ${type} `);\n        }\n        if (message.type === 'rowset'){\n            console.log(`[${Date.now()}] message queue push message ${JSON.stringify(message.data.range)}`)\n        }\n        this._queue.push(message);\n\n    }\n\n    purgeViewport(viewport) {\n        this._queue = this._queue.filter(batch => batch.viewport !== viewport);\n    }\n\n    // currentRange(){\n    //     for (let i = 0; i<this._queue.length; i++){\n    //         const message = this._queue[i];\n    //         const {data} = message;\n    //         if (data){\n    //             console.log(`message-queue.currentRange ${message.type} ${JSON.stringify(data.range)}`)\n    //         }\n    //     }\n    // }\n\n    extract(test) {\n        if (this._queue.length === 0) {\n            return EMPTY_ARRAY;\n        } else {\n            return extractMessages(this._queue, test);\n        }\n    }\n}\n\n\n// This purges redundant messages from the queue and merges their data into the new message. \n// AN unintended consequence of this might be that data slips down the queue, as the new \n// message is added at the back of the queue - INVESTIGATE.\nfunction mergeAndPurgeFilterData(queue, message, meta) {\n    const {IDX} = meta;\n    const { viewport, data: filterData } = message;\n    const { range } = filterData;\n    const { lo, hi } = rangeUtils.getFullRange(range);\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        let { type, viewport: vp, data } = queue[i];\n\n        if (vp === viewport && type === FILTER_DATA) {\n\n            var { lo: lo1, hi: hi1 } = rangeUtils.getFullRange(queue[i].data.range);\n\n            /*if ((lo1 === 0 && hi1 === 0 && lo === 0) ||\n                (lo1 >= hi || hi1 < lo)) {\n                    // nothing to do\n                }\n            else {\n*/\n                var overlaps = data.rows.filter(\n                    row => row[IDX] >= lo && row[IDX] < hi);\n\n\n                if (lo < lo1) {\n                    message.data = {\n                        ...message.data,\n                        rows: filterData.rows.concat(overlaps)\n                    };\n                }\n                else {\n                    message.data = {\n                        ...message.data,\n                        rows: overlaps.concat(filterData.rows)\n                    };\n                }\n\n            // }\n            queue.splice(i, 1);\n        }\n    }\n}\n\n// we need to know the current range in order to be able to merge rowsets which are still valid\nfunction mergeAndPurgeRowset(queue, message, meta) {\n    const { viewport, data: { rows, size, range, offset=0 } } = message;\n    const { lo, hi } = rangeUtils.getFullRange(range);\n    const low = lo + offset;\n    const high = hi + offset;\n\n    if (rows.length === 0){\n        console.log(`MESSAGE PUSHED TO MESAGEQ WITH NO ROWS`);\n        return;\n    }\n\n    const {IDX} = meta;\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        let { type, viewport: vp, data } = queue[i];\n\n        if (vp === viewport) {\n\n            if (type === ROWSET) { // snapshot. filterData, searchData \n\n                var { range: { lo: lo1, hi: hi1 } } = queue[i].data;\n\n                if (lo1 >= hi || hi1 < lo) {\n                    // no overlap, purge the message\n                }\n                else {\n                    var overlaps = data.rows.filter(\n                        row => row[IDX] >= low && row[IDX] < high);\n\n                    if (lo < lo1) {\n                        message.data.rows = rows.concat(overlaps);\n                    }\n                    else {\n                        message.data.rows = overlaps.concat(rows);\n                    }\n                }\n                queue.splice(i, 1);\n            }\n            else if (type === UPDATE) {\n                // if we have updates for rows within the current rowset, discard them - the rowset\n                // represents latest data.\n                let validUpdates = queue[i].updates.filter(u => {\n                    let idx = u[IDX];\n\n                    if (typeof rows[IDX] === 'undefined') {\n                        console.warn(`MessageQueue:about to error, these are the rows that have been passed `);\n                        console.warn(`[${rows.map(r => r[IDX]).join(',')}]`);\n                    }\n\n\n                    let min = rows[0][IDX];\n                    let max = rows[rows.length - 1][IDX];\n\n                    return idx >= low && idx < high &&   \t// within range \n                        idx < size &&  \t\t\t\t// within dataset  \n                        (idx < min || idx >= max); \t\t// NOT within new rowset \n                });\n\n                if (validUpdates.length) {\n                    queue[i].updates = validUpdates;\n                }\n                else {\n                    //onsole.log(`MessageQueue:purging updates that are no longer applicable`);\n                    queue.splice(i, 1);\n                }\n            }\n\n\n        }\n    }\n}\n\n// we need to know the current range in order to be able to merge rowsets which are still valid\nfunction mergeAndPurgeUpdates(queue, message) {\n\n    //onsole.log(`mergeAndPurge: update message ${JSON.stringify(message)}` );\n\n    var { viewport, range: { lo, hi } } = message;\n\n    //onsole.log(`mergeAndPurge: update message ${lo} - ${hi}   ${JSON.stringify(queue)}` );\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n\n        if (queue[i].type === message.type && queue[i].viewport === viewport) {\n\n            //onsole.log(`we have a match for an update ${i} of ${queue.length}   ${JSON.stringify(queue[i].updates)}`)\n\n            var { lo: lo1, hi: hi1 } = queue[i].updates;\n\n            if (lo1 >= hi || hi1 < lo) {\n                // no overlap, purge the message\n            }\n            else {\n                // merge updates for same row(s)\n                //console.log(`mergeAndPurgeUpdates ${JSON.stringify(queue[i])} ${JSON.stringify(message.updates)}`)\n            }\n            console.log(`merging rowset current range [${lo},${hi}] [${queue[i].rows.lo},${queue[i].rows.hi}]`);\n            queue.splice(i, 1);\n        }\n    }\n}\n\nfunction extractMessages(queue, test) {\n    var extract = [];\n\n    for (var i = queue.length - 1; i >= 0; i--) {\n        if (test(queue[i])) {\n            extract.push(queue.splice(i, 1)[0]);\n        }\n    }\n\n    extract.reverse();\n    const now = new Date().getTime()\n    console.log(`[${now}] extracted messages ${extract.map(formatMessage)}\\n\\n`)\n    return extract;\n}\n\n\nconst formatMessage = msg => ` type: ${msg.type} \n    rows: [${msg.data && msg.data.rows && msg.data.rows.map(row => row[7])}]`;\n","export function updateLoop(name, connection, interval, fn){\n  \n      //console.log(`starting update loop ${name} @  ${interval}`);\n  \n      let _keepGoing = true;\n      let _timeoutHandle = null;\n  \n      function beat(){\n  \n          const message = fn();\n  \n          if (message !== null){\n              connection.send(message);\n          }\t\n          \n          if (_keepGoing){\n              _timeoutHandle = setTimeout(beat, interval);\n          }\n      }\n  \n      beat();\n  \n      function stopper(){\n          console.log(`stopping updateLoop ${name}`);\n          if (_timeoutHandle){\n              clearTimeout(_timeoutHandle);\n          }\n          _keepGoing = false;\n      }\n  \n      return stopper;\n  \n  \n  }\n  ","import MessageQueue from '../message-queue';\nimport { findHandler as handlerFor, killSubscriptions } from '../requestHandlers';\nimport { updateLoop } from '../updateLoop';\n\n// we can have a separate clientId for XHR requests\nlet _clientId = 0;\n\nexport const requestHandler = (options, logger) => (localWebsocketConnection) => {\n\n    const { HEARTBEAT_FREQUENCY, PRIORITY_UPDATE_FREQUENCY, CLIENT_UPDATE_FREQUENCY } = options;\n\n    let server_clientId = ++_clientId;\n\n    console.log(`Server.websocketRequestHandler: connection request from new client #${server_clientId}`);\n\n    localWebsocketConnection.send(JSON.stringify(\n        { type: 'Welcome', clientId: ++_clientId }\n    ));\n\n    const _update_queue = new MessageQueue();\n\n    // Note: these loops are all running per client, this will get expensive\n    const HEARTBEAT = JSON.stringify({ type: 'HB', vsHostName: 'localhost' });\n    const stopHeartBeats = updateLoop('HeartBeat', localWebsocketConnection, HEARTBEAT_FREQUENCY, () => HEARTBEAT);\n    const stopPriorityUpdates = updateLoop('Priority Updates', localWebsocketConnection, PRIORITY_UPDATE_FREQUENCY, priorityQueueReader);\n    const stopUpdates = updateLoop('Regular Updates', localWebsocketConnection, CLIENT_UPDATE_FREQUENCY, queueReader);\n\n    localWebsocketConnection.on('message', function (msg) {\n\n        const json = JSON.parse(msg);\n        const message = json.message;\n        const msgType = message.type;\n\n        // some handlers are stateful (eg tableHandler). They must be notified \n        // when connection closes (maybe with delay to allow for temp disconenction)\n        const handler = handlerFor(msgType);\n\n        if (handler) {\n            handler(server_clientId, message, _update_queue);\n        } else {\n            console.log('server: dont know how to handle ' + msg);\n        }\n\n    });\n\n    localWebsocketConnection.on('close', function (msg) {\n\n        console.log('>>> viewserver, local CONNECTION closed');\n\n        // how do we clear up the open subscription(s)\n        // keep  alist od all active handlers and notify them\n\n        stopHeartBeats();\n        stopPriorityUpdates();\n        stopUpdates();\n\n        killSubscriptions(server_clientId, _update_queue);\n        // kill the update queue\n\n    });\n\n    function PRIORITY1(msg) { return msg.priority === 1 }\n\n    function priorityQueueReader() {\n        const queue = _update_queue.extract(PRIORITY1);\n        if (queue.length > 0) {\n            queue.forEach(msg => {\n                if (msg.data && msg.data.range){\n                    console.log(`[${Date.now()}]<<<<<<<<< ${msg.type} ${JSON.stringify(msg.data.range)}`)\n                }\n            })\n            const msg = JSON.stringify(queue);\n            return msg;\n        } else {\n            return null;\n        }\n    }\n\n    function queueReader() {\n        if (_update_queue.length > 0) {\n            const msg = JSON.stringify(_update_queue.queue);\n            //onsole.log(`\\n[${new Date().toISOString().slice(11,23)}] <<<<<   ${msg}`);\n            return msg;\n        } else {\n            return null;\n        }\n    }\n\n};\n","/* global require:false __dirname:false process:false module:false */\nimport {configure as configureRequestHandlers} from './requestHandlers';\nimport {configure as configureXhr} from './xhrHandler';\nimport {requestHandler as viewserverRequestHandler} from './handlers/viewserverRequestHandler';\n\nimport http from 'http';\n\nconst WebSocket = require('ws')\n\nconst logger = console\n\nclass SubscriptionCounter {\n    constructor(){\n        this._count = 0;\n    }\n    next(){\n        this._count += 1;\n        return this._count;\n    }\n}\n\n//const mapArgs = (map, arg) => {let [n,v]=arg.split('=');map[n.toLowerCase()]=v;return map;};\n// const args = process.argv.slice(2).reduce(mapArgs,{});\nconst port = /* argv.port || */ 9090;\n\n//onsole.log(`args ${JSON.stringify(process.argv)}`);\n\n//const port = process.env.OPENSHIFT_NODEJS_PORT || argv.port || 9090;\nconst PRIORITY_UPDATE_FREQUENCY = 50;\nconst CLIENT_UPDATE_FREQUENCY = 250;\nconst HEARTBEAT_FREQUENCY = 5000;\n\nexport default function start(config){\n\n    configureRequestHandlers({\n        ...config,\n        subscriptionCounter: new SubscriptionCounter()\n    });\n\n    const msgConfig = {\n        CLIENT_UPDATE_FREQUENCY,\n        HEARTBEAT_FREQUENCY,\n        PRIORITY_UPDATE_FREQUENCY\n    };\n\n    configureXhr(msgConfig);\n\n    const httpServer = http.createServer(function(request, response) {\n        \n        if (request.url === '/xhr'){\n            handleXhrRequest(request, response);\n        } else if (request.url.match(/\\/ws\\/stomp\\/info/)) {\n            // doesn't belng here\n            const HTTP_HEADERS = {\n                'Access-Control-Allow-Credentials': true,\n                'Access-Control-Allow-Origin': request.headers['origin'],\n                'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',\n                // 'Content-Length':77,\n                'Content-type': 'application/json;charset=UTF-8'\n            };\n            response.writeHead(200, HTTP_HEADERS);\n            response.end(JSON.stringify({entropy: 9006110,origins: ['*:*'],'cookie_needed': true,websocket: true}));\n\n        } else {\n            console.log((new Date()) + ' received request for ' + request.url);\n            request.addListener('end', function () {\n                // do nothing\n            }).resume();\n        }\n    });\n\n    const wss = new WebSocket.Server({server: httpServer});\n\n    // const requestHandler = argv.stomp   \n    //     ? stompRequestHandler\n    //     : argv.sockjs\n    //         ? sockjsRequestHandler\n    //         : viewserverRequestHandler;\n    const requestHandler = viewserverRequestHandler;\n\n    wss.on('connection', requestHandler(msgConfig, logger));\n\n    // const ipaddress = '127.0.0.1';\n    httpServer.listen(port, function() {\n        console.log(`HTTP Server is listening on port ${port}`);\n    });\n};\n\nfunction handleXhrRequest(request, response){\n    let content = '';\n    request.on('data', data => content += data);\n    request.on('end', () => {\n        console.log(`got a client request ${content}`);\n        let {clientId,message} = JSON.parse(content);\n    });\n}"],"names":["DataTypes","handlerFor","configureRequestHandlers","requestHandler","viewserverRequestHandler"],"mappings":"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"}