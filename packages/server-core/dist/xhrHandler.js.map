{
  "version": 3,
  "sources": ["../src/xhrHandler.ts"],
  "sourcesContent": ["import { uuid } from './uuid.js';\n\nimport MessageQueue from './message-queue.js';\nimport { findHandler as handlerFor } from './requestHandlers.js';\n\nvar updateInterval = null;\n\nvar Frequency;\n\nconst CONTENT_TYPE_JSON = { 'Content-type': 'application/json' };\n\nconst _client_xhr_connections = {};\n\nfunction getClientConnection(clientId) {\n  var connection = _client_xhr_connections[clientId];\n  if (connection === undefined) {\n    connection = _client_xhr_connections[clientId] = {\n      queue: new MessageQueue()\n    };\n  }\n\n  return connection;\n}\n\nexport function configure({\n  PRIORITY_UPDATE_FREQUENCY: PRIORITY = 100,\n  CLIENT_UPDATE_FREQUENCY: UPDATE = 250,\n  HEARTBEAT_FREQUENCY: HEARTBEAT = 5000,\n  TIMEOUT_PERIOD: TIMEOUT = 10000\n}) {\n  Frequency = {\n    PRIORITY,\n    UPDATE,\n    HEARTBEAT,\n    TIMEOUT\n  };\n}\n\nexport function handleRequest(request, response) {\n  var content = '';\n  request.on('data', (data) => (content += data));\n  request.on('end', () => {\n    let { clientId, message } = JSON.parse(content);\n    //onsole.log(' 1) ' + JSON.stringify(message));\n    var handler;\n\n    if (message.type === 'connect') {\n      let clientId = uuid();\n      // save this, so we know whos's conencted\n      response.writeHead(200, CONTENT_TYPE_JSON);\n      response.end(JSON.stringify({ type: 'Welcome', clientId }));\n    } else if (message.type === 'HB') {\n      //onsole.log('>>> HeartBeat');\n      let connection = getClientConnection(clientId);\n      connection.response = response;\n      connection.timestamp = new Date().getTime();\n\n      if (updateInterval === null) {\n        updateInterval = setTimeout(processXhrUpdates, Frequency.UPDATE);\n      }\n    } else if ((handler = handlerFor(message))) {\n      let connection = getClientConnection(clientId);\n      handler(clientId, message, connection.queue);\n      console.log(\n        `after calling the handler, queue contains ${JSON.stringify(\n          connection.queue.length\n        )} records`\n      );\n\n      // we need to be sure this message is for the same request\n      if (connection.queue.length > 0) {\n        response.writeHead(200, CONTENT_TYPE_JSON);\n        var msg = JSON.stringify(connection.queue._queue);\n        connection.queue.length = 0;\n        response.end(msg);\n      } else {\n        // we need to distinguish from the HB response\n        connection.response = response;\n        // also set a timer to timeout the response ?\n      }\n    } else {\n      console.log('server: dont know how to handle ' + JSON.stringify(message));\n    }\n  });\n}\n\nfunction processXhrUpdates() {\n  const currentTime = new Date().getTime();\n  var clients = Object.keys(_client_xhr_connections);\n  var clientCount = clients.length;\n  var deadClient = false;\n\n  clients.forEach((clientId) => {\n    let { queue, timestamp, response } = _client_xhr_connections[clientId];\n    if (queue.length) {\n      if (response) {\n        //onsole.log(`processXhrHandler: client ${clientId} has ${queue.length} updates queued SEND UPDATES`);\n        response.writeHead(200, CONTENT_TYPE_JSON);\n        response.end(JSON.stringify(queue._queue));\n        queue.length = 0;\n        _client_xhr_connections[clientId].timestamp = currentTime;\n        _client_xhr_connections[clientId].response = null;\n      } else if (currentTime - timestamp > Frequency.TIMEOUT) {\n        console.log(\n          `We have updates and more than ${\n            Frequency.TIMEOUT / 1000\n          } seconds (TIMEOUT_PERIOD) since we communicated with this client`\n        );\n        deadClient = true;\n      } else {\n        console.log(\n          `processXhrHandler: client ${clientId} has ${queue.length} updates queued, nor response available, wait for next client HB `\n        );\n      }\n    } else if (currentTime - timestamp > Frequency.HEARTBEAT) {\n      console.log(\n        `more than ${\n          Frequency.HEARTBEAT / 1000\n        } seconds (HEARTBEAT_FREQUENCY) since we communicated with this client`\n      );\n      _client_xhr_connections[clientId].response = null;\n\n      if (response) {\n        response.writeHead(200, CONTENT_TYPE_JSON);\n        response.end(JSON.stringify({ type: 'HB', timestamp: currentTime }));\n        _client_xhr_connections[clientId].timestamp = currentTime;\n      } else if (currentTime - timestamp > Frequency.TIMEOUT) {\n        console.log(\n          `more than ${\n            Frequency.TIMEOUT / 1000\n          } seconds (TIMEOUT_PERIOD) since we communicated with this client`\n        );\n        // assume the client is dead\n        deadClient = true;\n      }\n    }\n\n    if (deadClient === true) {\n      requestHandlers.TerminateAllSubscriptionsForClient(clientId);\n      updateInterval = null;\n      delete _client_xhr_connections[clientId];\n      clientCount -= 1;\n    }\n  });\n\n  if (clientCount > 0) {\n    updateInterval = setTimeout(processXhrUpdates, Frequency.UPDATE);\n  }\n}\n"],
  "mappings": "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",
  "names": ["clientId"]
}
