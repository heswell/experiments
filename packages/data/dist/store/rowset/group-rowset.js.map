{
  "version": 3,
  "sources": ["../../../src/store/rowset/group-rowset.ts"],
  "sourcesContent": ["import { mapSortCriteria } from '../columnUtils.js';\nimport { extendsFilter, functor as filterPredicate } from '../filter.js';\nimport GroupIterator from '../groupIterator.js';\nimport {\n  adjustGroupIndices,\n  adjustLeafIdxPointers,\n  aggregateGroup,\n  allGroupsExpanded,\n  decrementDepth,\n  expandRow,\n  findAggregatedColumns,\n  findDoomedColumnDepths,\n  findGroupPositions,\n  findSortedCol,\n  getCount,\n  getGroupStateChanges,\n  groupbyExtendsExistingGroupby,\n  groupbyReducesExistingGroupby,\n  groupbySortReversed,\n  GroupIdxTracker,\n  groupRows,\n  incrementDepth,\n  lowestIdxPointer,\n  SimpleTracker,\n  splitGroupsAroundDoomedGroup\n} from '../groupUtils.js';\nimport { NULL_RANGE } from '../rangeUtils.js';\nimport { sortBy, sortPosition } from '../sort.js';\nimport { ASC } from '../types.js';\nimport BaseRowSet from './rowSet.js';\n\nconst EMPTY_ARRAY = [];\n\nexport class GroupRowSet extends BaseRowSet {\n  constructor(\n    rowSet,\n    columns,\n    groupby,\n    groupState,\n    sortCriteria = null,\n    filter = rowSet.currentFilter\n  ) {\n    super(rowSet.table, columns, rowSet.baseOffset);\n    this.groupby = groupby;\n    this.groupState = groupState;\n    this.aggregations = [];\n    this.currentLength = 0; // TODO\n    this.groupRows = [];\n    this.aggregatedColumn = {};\n\n    this.collapseChildGroups = this.collapseChildGroups.bind(this);\n    this.countChildGroups = this.countChildGroups.bind(this);\n\n    columns.forEach((column) => {\n      if (column.aggregate) {\n        const key = rowSet.columnMap[column.name];\n        this.aggregations.push([key, column.aggregate]); // why ?\n        this.aggregatedColumn[key] = column.aggregate;\n      }\n    });\n    this.expandedByDefault = false;\n    this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length ? sortCriteria : null;\n\n    // can we lazily build the sortSet as we fetch data for the first time ?\n    this.sortSet = rowSet.data.map((d, i) => i);\n    // we will store an array of pointers to parent Groups.mirroring sequence of leaf rows\n    this.rowParents = Array(rowSet.data.length);\n\n    this.applyGroupby(groupby);\n\n    const [navSet, IDX, COUNT] = this.selectNavigationSet(false);\n    // TODO roll the IDX and COUNT overrides into meta\n    this.iter = GroupIterator(this.groupRows, navSet, this.data, IDX, COUNT, this.meta);\n\n    if (filter) {\n      this.filter(filter);\n    }\n  }\n\n  get length() {\n    return this.currentLength;\n  }\n  get first() {\n    return this.data[0];\n  }\n  get last() {\n    return this.data[this.data.length - 1];\n  }\n\n  currentRange() {\n    return this.setRange(this.range, false);\n  }\n\n  setRange(range, useDelta = true) {\n    const [rowsInRange, idx] =\n      !useDelta && range.lo === this.range.lo && range.hi === this.range.hi\n        ? this.iter.currentRange()\n        : this.iter.setRange(range, useDelta);\n\n    const filterCount = this.filterSet && this.meta.FILTER_COUNT;\n    const rows = rowsInRange.map((row, i) => this.cloneRow(row, idx + i, filterCount));\n    this.range = range;\n    return {\n      rows,\n      range,\n      size: this.length,\n      offset: this.offset,\n      selectedIndices: this.selectedIndices\n    };\n  }\n\n  cloneRow(row, idx, FILTER_COUNT) {\n    const { IDX, DEPTH, COUNT } = this.meta;\n    const dolly = row.slice();\n    dolly[IDX] = idx + this.offset;\n\n    if (FILTER_COUNT && dolly[DEPTH] !== 0 && typeof dolly[FILTER_COUNT] === 'number') {\n      dolly[COUNT] = dolly[FILTER_COUNT];\n    }\n    return dolly;\n  }\n\n  applyGroupby(groupby, rows = this.data) {\n    const { columns } = this;\n    this.groupRows.length = 0;\n    const groupCols = mapSortCriteria(groupby, this.columnMap);\n    this.groupRows = groupRows(rows, this.sortSet, columns, this.columnMap, groupCols, {\n      groups: this.groupRows,\n      rowParents: this.rowParents\n    });\n    this.currentLength = this.countVisibleRows(this.groupRows);\n  }\n\n  groupBy(groupby) {\n    if (groupbySortReversed(groupby, this.groupby)) {\n      this.sortGroupby(groupby);\n    } else if (groupbyExtendsExistingGroupby(groupby, this.groupby)) {\n      this.extendGroupby(groupby);\n      this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n    } else if (groupbyReducesExistingGroupby(groupby, this.groupby)) {\n      this.reduceGroupby(groupby);\n      this.range = NULL_RANGE;\n      this.iter.clear();\n      this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n    } else {\n      this.applyGroupby(groupby);\n    }\n    this.groupby = groupby;\n  }\n\n  // User interaction will never produce more than one change, but programatic change might !\n  //TODO if we have sortCriteria, apply to leaf rows as we expand\n  setGroupState(groupState) {\n    // onsole.log(`[groupRowSet.setGroupState] ${JSON.stringify(groupState,null,2)}`)\n    const changes = getGroupStateChanges(groupState, this.groupState);\n    changes.forEach(([key, , isExpanded]) => {\n      const { groupRows } = this;\n      if (key === '*') {\n        this.toggleAll(isExpanded);\n        this.currentLength = this.countVisibleRows(groupRows, false);\n      } else {\n        const groupIdx = this.findGroupIdx(key);\n        if (groupIdx !== -1) {\n          if (isExpanded) {\n            this.currentLength += this.expandGroup(groupIdx, groupRows);\n          } else {\n            this.currentLength -= this.collapseGroup(groupIdx, groupRows);\n          }\n        } else {\n          console.warn(`setGroupState could not find row to toggle`);\n        }\n      }\n    });\n    this.groupState = groupState;\n  }\n\n  expandGroup(idx, groups) {\n    return this.toggleGroup(idx, groups, this.countChildGroups);\n  }\n\n  collapseGroup(idx, groups) {\n    return this.toggleGroup(idx, groups, this.collapseChildGroups);\n  }\n\n  toggleGroup(groupIdx, groupRows, processChildGroups) {\n    const { DEPTH, COUNT, FILTER_COUNT } = this.meta;\n    let adjustment = 0;\n    const groupRow = groupRows[groupIdx];\n    const depth = groupRow[DEPTH];\n    const useFilter = this.filterSet !== null;\n    groupRow[DEPTH] = -depth;\n    if (Math.abs(depth) === 1) {\n      const COUNT_IDX = useFilter ? FILTER_COUNT : COUNT;\n      adjustment = groupRow[COUNT_IDX];\n    } else {\n      adjustment = processChildGroups(Math.abs(depth) - 1, groupIdx + 1, groupRows, useFilter);\n    }\n    return adjustment;\n  }\n\n  countChildGroups(childDepth, startIdx, groupRows, useFilter) {\n    const { DEPTH, FILTER_COUNT } = this.meta;\n    let adjustment = 0;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const nextDepth = groupRows[i][DEPTH];\n      if (Math.abs(nextDepth) === childDepth) {\n        if (!useFilter || groupRows[i][FILTER_COUNT] > 0) {\n          adjustment += 1;\n        }\n      } else if (Math.abs(nextDepth) > childDepth) {\n        break;\n      }\n    }\n    return adjustment;\n  }\n\n  collapseChildGroups(childDepth, startIdx, groupRows, useFilter) {\n    const { DEPTH, FILTER_COUNT } = this.meta;\n    let adjustment = 0;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const nextDepth = groupRows[i][DEPTH];\n      if (Math.abs(nextDepth) === childDepth) {\n        if (!useFilter || groupRows[i][FILTER_COUNT] > 0) {\n          adjustment += 1;\n          if (nextDepth > 0) {\n            adjustment += this.collapseGroup(i, groupRows);\n          }\n        }\n      } else if (Math.abs(nextDepth) > childDepth) {\n        break;\n      }\n    }\n    return adjustment;\n  }\n\n  sort(sortCriteria) {\n    const { groupRows: groups } = this;\n    const { IDX, DEPTH, COUNT, IDX_POINTER } = this.meta;\n    this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length ? sortCriteria : null;\n\n    const sortCols = mapSortCriteria(sortCriteria, this.columnMap);\n    //TODO only need to handle visible rows\n    for (let i = 0; i < groups.length; i++) {\n      const groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const count = groupRow[COUNT];\n      const absDepth = Math.abs(depth);\n      const sortIdx = groupRow[IDX_POINTER];\n      if (absDepth === 1) {\n        this.sortDataSubset(sortIdx, count, sortCols, IDX);\n      }\n    }\n  }\n\n  sortDataSubset(startIdx, length, sortCriteria, IDX) {\n    const rows = [];\n    for (let i = startIdx; i < startIdx + length; i++) {\n      const rowIdx = this.sortSet[i];\n      rows.push(this.data[rowIdx]);\n    }\n    rows.sort(sortBy(sortCriteria));\n    for (let i = 0; i < rows.length; i++) {\n      this.sortSet[i + startIdx] = rows[i][IDX];\n    }\n  }\n\n  clearFilter(/*cloneChanges*/) {\n    this.currentFilter = null;\n    this.filterSet = null;\n    // rebuild agregations for groups where filter count is less than count, remove filter count\n    const { data: rows, groupRows: groups, sortSet, columns } = this;\n    const { COUNT, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n    const aggregations = findAggregatedColumns(columns, this.columnMap, this.groupby);\n\n    for (let i = 0; i < groups.length; i++) {\n      let groupRow = groups[i];\n      if (typeof groupRow[FILTER_COUNT] === 'number' && groupRow[COUNT] > groupRow[FILTER_COUNT]) {\n        aggregateGroup(groups, i, sortSet, rows, columns, aggregations);\n        groupRow[FILTER_COUNT] = null;\n        groupRow[NEXT_FILTER_IDX] = null;\n      }\n    }\n\n    this.iter.setNavSet(this.selectNavigationSet(false));\n    this.currentLength = this.countVisibleRows(groups, false);\n  }\n\n  filter(filter) {\n    const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n    const fn = filter && filterPredicate(this.columnMap, filter);\n    const { COUNT, DEPTH, PARENT_IDX, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n    const { data: rows, groupRows: groups } = this;\n    let [navSet, NAV_IDX, NAV_COUNT] = this.selectNavigationSet(\n      extendsCurrentFilter && this.filterSet\n    );\n    const newFilterSet = [];\n\n    for (let i = 0; i < groups.length; i++) {\n      let groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const count = getCount(groupRow, NAV_COUNT, COUNT);\n      const absDepth = Math.abs(depth);\n\n      if (absDepth === 1) {\n        const sortIdx = groupRow[NAV_IDX];\n        let rowCount = 0;\n\n        for (let ii = sortIdx; ii < sortIdx + count; ii++) {\n          const rowIdx = navSet[ii];\n          const row = rows[rowIdx];\n          const includerow = fn(row);\n          if (includerow) {\n            rowCount += 1;\n            if (rowCount === 1) {\n              groupRow[NEXT_FILTER_IDX] = newFilterSet.length;\n            }\n            newFilterSet.push(rowIdx);\n          }\n        }\n\n        groupRow[FILTER_COUNT] = rowCount;\n        let aggregations = EMPTY_ARRAY;\n        // we cannot be sure what filter changes have taken effect, so we must recalculate aggregations\n        if (this.aggregations.length) {\n          aggregations = this.aggregations.map(([i, a]) => [i, a, 0]);\n          const len = newFilterSet.length;\n          for (let ii = len - rowCount; ii < len; ii++) {\n            const rowIdx = newFilterSet[ii];\n            const row = rows[rowIdx];\n            for (let j = 0; j < aggregations.length; j++) {\n              let [colIdx] = aggregations[j];\n              aggregations[j][2] += row[colIdx];\n            }\n          }\n\n          // 2) store aggregates at lowest level of the group hierarchy\n          aggregations.forEach((aggregation) => {\n            const [colIdx, type, sum] = aggregation;\n            if (type === 'sum') {\n              groupRow[colIdx] = sum;\n            } else if (type === 'avg') {\n              groupRow[colIdx] = sum / rowCount;\n            }\n          });\n        }\n\n        // update parent counts\n        if (rowCount > 0) {\n          while (groupRow[PARENT_IDX] !== null) {\n            groupRow = groups[groupRow[PARENT_IDX]];\n\n            aggregations.forEach((aggregation) => {\n              const [colIdx, type, sum] = aggregation;\n              if (type === 'sum') {\n                groupRow[colIdx] += sum;\n              } else if (type === 'avg') {\n                const originalCount = groupRow[FILTER_COUNT];\n                const originalSum = originalCount * groupRow[colIdx];\n                groupRow[colIdx] = (originalSum + sum) / (originalCount + rowCount);\n              }\n            });\n            groupRow[FILTER_COUNT] += rowCount;\n          }\n        }\n      } else {\n        // Higher-level group aggregations are calculated from lower level groups\n        // initialize aggregated columns\n        groupRow[FILTER_COUNT] = 0;\n        this.aggregations.forEach((aggregation) => {\n          const [colIdx] = aggregation;\n          groupRow[colIdx] = 0;\n        });\n      }\n    }\n    this.filterSet = newFilterSet;\n    this.currentFilter = filter;\n    this.currentLength = this.countVisibleRows(this.groupRows, true);\n\n    this.iter.setNavSet(this.selectNavigationSet(true));\n  }\n\n  update(rowIdx, updates) {\n    const {\n      groupRows: groups,\n      offset,\n      rowParents,\n      range: { lo }\n    } = this;\n    const { COUNT, FILTER_COUNT, PARENT_IDX } = this.meta;\n\n    let groupUpdates;\n    const rowUpdates = [];\n\n    for (let i = 0; i < updates.length; i += 3) {\n      // the col mappings in updates refer to base column definitions\n      const colIdx = updates[i];\n      const originalValue = updates[i + 1];\n      const value = updates[i + 2];\n      rowUpdates.push(colIdx, originalValue, value);\n\n      let grpIdx = rowParents[rowIdx];\n      // this seems to return 0 an awful lot\n      let ii = 0;\n\n      // If this column is being aggregated\n      if (this.aggregatedColumn[colIdx]) {\n        groupUpdates = groupUpdates || [];\n        // collect adjusted aggregations for each group level\n        do {\n          let groupRow = groups[grpIdx];\n\n          let originalGroupValue = groupRow[colIdx];\n          const diff = value - originalValue;\n          const type = this.aggregatedColumn[colIdx];\n          if (type === 'sum') {\n            // ... wnd in the groupRow we have a further offset of 2 ...\n            groupRow[colIdx] += diff; // again with the +2\n          } else if (type === 'avg') {\n            const count = getCount(groupRow, FILTER_COUNT, COUNT);\n            groupRow[colIdx] = (groupRow[colIdx] * count + diff) / count;\n          }\n\n          (groupUpdates[ii] || (groupUpdates[ii] = [grpIdx])).push(\n            colIdx,\n            originalGroupValue,\n            groupRow[colIdx]\n          );\n\n          grpIdx = groupRow[PARENT_IDX];\n          ii += 1;\n        } while (grpIdx !== null);\n      }\n    }\n\n    const outgoingUpdates = [];\n    // check rangeIdx for both row and group updates, if they are not in range, they have not been\n    // sent to client and do not need to be added to outgoing updates\n    if (groupUpdates) {\n      // the groups are currently in reverse order, lets send them out outermost group first\n      for (let i = groupUpdates.length - 1; i >= 0; i--) {\n        const [grpIdx, ...updates] = groupUpdates[i];\n        // won't work - need to chnage groupIterator\n        const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n        if (rangeIdx !== -1) {\n          outgoingUpdates.push([lo + rangeIdx + offset, ...updates]);\n        }\n      }\n    }\n    const rangeIdx = this.iter.getRangeIndexOfRow(rowIdx);\n    if (rangeIdx !== -1) {\n      // onsole.log(`[GroupRowSet.update] updates for row idx ${idx} ${rangeIdx+offset} ${JSON.stringify(rowUpdates)}`)\n      outgoingUpdates.push([lo + rangeIdx + offset, ...rowUpdates]);\n    }\n\n    return outgoingUpdates;\n  }\n\n  insert(newRowIdx, row) {\n    // TODO look at append and idx manipulation for insertion at head.\n    const { groupRows: groups, groupby, data: rows, sortSet, columns, meta, iter: iterator } = this;\n    let groupCols = mapSortCriteria(groupby, this.columnMap);\n    const groupPositions = findGroupPositions(groups, groupCols, row);\n    const { IDX, COUNT, KEY, IDX_POINTER } = meta;\n    const GROUP_KEY_SORT = [[KEY, 'asc']];\n    const allGroupsExist = groupPositions.length === groupby.length;\n    const noGroupsExist = groupPositions.length === 0;\n    const someGroupsExist = !noGroupsExist && !allGroupsExist;\n    let result;\n    let newGroupIdx = null;\n\n    if (allGroupsExist) {\n      // all necessary groups are already in place, we will just insert a row and update counts/aggregates\n      let grpIdx = groupPositions[groupPositions.length - 1];\n      const groupRow = groups[grpIdx];\n      this.rowParents[newRowIdx] = grpIdx;\n      let count = groupRow[COUNT];\n\n      const insertionPoint = groupRow[IDX_POINTER] + count;\n      // all existing pointers from the insertionPoint forward are going to be displaced by +1\n      adjustLeafIdxPointers(groups, insertionPoint, meta);\n      sortSet.splice(insertionPoint, 0, row[IDX]);\n      if (allGroupsExpanded(groups, groupRow, meta)) {\n        this.currentLength += 1;\n      }\n    } else {\n      newGroupIdx = sortPosition(\n        groups,\n        sortBy(GROUP_KEY_SORT),\n        expandRow(groupCols, row, meta),\n        'last-available'\n      );\n      sortSet.push(newRowIdx);\n      let nestedGroups, baseGroupby, rootIdx;\n\n      if (someGroupsExist) {\n        baseGroupby = groupCols.slice(0, groupPositions.length);\n        rootIdx = groups[groupPositions[groupPositions.length - 1]][IDX];\n        groupCols = groupCols.slice(groupPositions.length);\n      }\n\n      nestedGroups = groupRows(rows, sortSet, columns, this.columnMap, groupCols, {\n        startIdx: sortSet.length - 1,\n        length: 1,\n        groupIdx: newGroupIdx - 1,\n        baseGroupby,\n        rootIdx\n      });\n\n      adjustGroupIndices(groups, newGroupIdx, meta, nestedGroups.length);\n      groups.splice.apply(groups, [newGroupIdx, 0].concat(nestedGroups));\n    }\n\n    this.incrementGroupCounts(groupPositions);\n    this.updateAggregatedValues(groupPositions, row);\n\n    iterator.refresh(); // force iterator to rebuild rangePositions\n    let rangeIdx = allGroupsExist\n      ? iterator.getRangeIndexOfRow(newRowIdx)\n      : iterator.getRangeIndexOfGroup(newGroupIdx);\n\n    if (rangeIdx !== -1) {\n      // New row is visible within viewport so we will force render all rows\n      result = { replace: true };\n      if (newGroupIdx !== null) {\n        this.currentLength += 1;\n      }\n    } else if (noGroupsExist === false) {\n      // new row is not visible as group is collapsed, but we need to update groiup row(s)\n      result = { updates: this.collectGroupUpdates(groupPositions) };\n    }\n\n    return result;\n  }\n\n  incrementGroupCounts(groupPositions) {\n    const {\n      groupRows: groups,\n      meta: { COUNT }\n    } = this;\n    groupPositions.forEach((grpIdx) => {\n      const group = groups[grpIdx];\n      group[COUNT] += 1;\n    });\n  }\n\n  updateAggregatedValues(groupPositions, row) {\n    const { groupRows: groups } = this;\n\n    groupPositions.forEach((grpIdx) => {\n      const group = groups[grpIdx];\n      for (let [key, type] of this.aggregations) {\n        const value = row[key];\n        const groupValue = group[key];\n        if (type === 'sum') {\n          group[key] = groupValue + value;\n        }\n      }\n    });\n  }\n\n  collectGroupUpdates(groupPositions) {\n    const {\n      aggregations,\n      groupRows: groups,\n      meta: { COUNT },\n      offset\n    } = this;\n    const updates = [];\n    for (let grpIdx of groupPositions) {\n      const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n      if (rangeIdx !== -1) {\n        const group = groups[grpIdx];\n        const update = [rangeIdx + offset, COUNT, group[COUNT]];\n        for (let [key] of aggregations) {\n          update.push(key, group[key]);\n        }\n        updates.push(update);\n      }\n    }\n    return updates;\n  }\n\n  // start with a simplesequential search\n  findGroupIdx(groupKey) {\n    const { groupRows, meta } = this;\n    for (let i = 0; i < groupRows.length; i++) {\n      if (groupRows[i][meta.KEY] === groupKey) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  //TODO simple implementation first\n  toggleAll(isExpanded) {\n    const sign = isExpanded ? 1 : -1;\n    // iterate groupedRows and make every group row depth positive,\n    // Then visible rows is not going to be different from grouped rows\n    const { DEPTH } = this.meta;\n    const { groupRows: groups } = this;\n    this.expandedByDefault = isExpanded;\n    for (let i = 0, len = groups.length; i < len; i++) {\n      const depth = groups[i][DEPTH];\n      // if (depth !== 0) {\n      groups[i][DEPTH] = Math.abs(depth) * sign;\n      // }\n    }\n  }\n\n  sortGroupby(groupby) {\n    const { IDX, KEY, DEPTH, IDX_POINTER, PARENT_IDX } = this.meta;\n    const { groupRows: groups } = this;\n    const groupCols = mapSortCriteria(groupby, this.columnMap);\n    const [colIdx, depth] = findSortedCol(groupby, this.groupby);\n    let count = 0;\n    let i = 0;\n    for (; i < groups.length; i++) {\n      if (Math.abs(groups[i][DEPTH]) > depth) {\n        if (count > 0) {\n          this.sortGroupRowsSubset(groupCols, colIdx, i - count, count);\n          count = 0;\n        }\n      } else {\n        count += 1;\n      }\n    }\n\n    this.sortGroupRowsSubset(groupCols, colIdx, i - count, count);\n\n    const tracker = new SimpleTracker(groupby.length);\n    this.groupRows.forEach((groupRow, i) => {\n      const depth = groupRow[DEPTH];\n      const groupKey = groupRow[KEY];\n      const absDepth = Math.abs(depth);\n      tracker.set(absDepth, i, groupKey);\n      groupRow[IDX] = i;\n      if (absDepth > 1) {\n        groupRow[IDX_POINTER] = i + 1;\n      }\n      if (tracker.hasParentPos(absDepth)) {\n        groupRow[PARENT_IDX] = tracker.parentPos(absDepth);\n      }\n    });\n  }\n\n  sortGroupRowsSubset(groupby, colIdx, startPos = 0, length = this.groupRows.length) {\n    const { groupRows: groups } = this;\n    let insertPos = startPos + length;\n    const [groupColIdx, direction] = groupby[colIdx];\n    const before = (k1, k2) => (direction === ASC ? k2 > k1 : k1 > k2);\n    const after = (k1, k2) => (direction === ASC ? k2 < k1 : k1 < k2);\n    let currentKey = null;\n    for (let i = startPos; i < startPos + length; i++) {\n      const key = groups[i][groupColIdx];\n      if (currentKey === null) {\n        currentKey = key;\n      } else if (before(key, currentKey)) {\n        const splicedRows = groups.splice(startPos, i - startPos);\n        insertPos -= splicedRows.length;\n        groups.splice.apply(groups, [insertPos, 0].concat(splicedRows));\n        currentKey = key;\n        i = startPos - 1;\n      } else if (after(key, currentKey)) {\n        break;\n      }\n    }\n  }\n\n  // there is a current assumption here that new col(s) are always added at the end of existing cols in the groupBy\n  // Need to think about a new col inserted at start or in between existing cols\n  //TODO we might want to do this on expanded nodes only and repat in a lazy fashion as more nodes are revealed\n  extendGroupby(groupby) {\n    const groupCols = mapSortCriteria(groupby, this.columnMap);\n    const baseGroupCols = groupCols.slice(0, this.groupby.length);\n    const newGroupbyClause = groupCols.slice(this.groupby.length);\n    const {\n      groupRows: groups,\n      groupby: baseGroupby,\n      data: rows,\n      columns,\n      sortSet,\n      filterSet,\n      meta\n    } = this;\n    const { IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = meta;\n    const baseLevels = baseGroupby.length;\n    const tracker = new GroupIdxTracker(baseLevels - 1);\n    const filterFn = this.currentFilter\n      ? filterPredicate(this.columnMap, this.currentFilter)\n      : null;\n\n    // we are going to insert new rows into groupRows and update the PARENT_IDX pointers in data rows\n    for (let i = 0; i < groups.length; i++) {\n      const groupRow = groups[i];\n      if (tracker.idxAdjustment) {\n        groupRow[meta.IDX] += tracker.idxAdjustment;\n      }\n\n      const rootIdx = groupRow[meta.IDX];\n      const depth = groupRow[meta.DEPTH];\n      const length = groupRow[meta.COUNT];\n      const groupKey = groupRow[meta.KEY];\n\n      const absDepth = Math.abs(depth);\n      groupRow[meta.DEPTH] = incrementDepth(depth);\n      const filterLength = groupRow[meta.FILTER_COUNT];\n      const filterIdx = groupRow[NEXT_FILTER_IDX];\n      groupRow[meta.NEXT_FILTER_IDX] = undefined;\n\n      if (tracker.hasPrevious(absDepth + 1)) {\n        groupRow[PARENT_IDX] += tracker.previous(absDepth + 1);\n      }\n\n      if (absDepth === 1) {\n        const startIdx = groupRow[IDX_POINTER];\n        const nestedGroupRows = groupRows(\n          rows,\n          sortSet,\n          columns,\n          this.columnMap,\n          newGroupbyClause,\n          {\n            startIdx,\n            length,\n            rootIdx,\n            baseGroupby: baseGroupCols,\n            groupIdx: rootIdx,\n            filterIdx,\n            filterLength,\n            filterSet,\n            filterFn,\n            rowParents: this.rowParents\n          }\n        );\n        const nestedGroupCount = nestedGroupRows.length;\n        // this might be a performance problem for large arrays, might need to concat\n        groups.splice(i + 1, 0, ...nestedGroupRows);\n        i += nestedGroupCount;\n        tracker.increment(nestedGroupCount);\n      } else {\n        tracker.set(absDepth, groupKey);\n      }\n      // This has to be a pointer into sortSet NOT rows\n      groupRow[IDX_POINTER] = rootIdx + 1;\n    }\n  }\n\n  reduceGroupby(groupby) {\n    const { groupRows: groups, filterSet } = this;\n    const [doomed] = findDoomedColumnDepths(groupby, this.groupby);\n    const groupCols = mapSortCriteria(this.groupby, this.columnMap);\n    const [lastGroupIsDoomed, baseGroupby, addGroupby] = splitGroupsAroundDoomedGroup(\n      groupCols,\n      doomed\n    );\n    const { IDX, DEPTH, KEY, IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = this.meta;\n    const tracker = new GroupIdxTracker(groupby.length);\n    const useFilter = filterSet !== null;\n    let currentGroupIdx = null;\n    let i = 0;\n    for (let len = groups.length; i < len; i++) {\n      const groupRow = groups[i];\n      const depth = groupRow[DEPTH];\n      const groupKey = groupRow[KEY];\n      const absDepth = Math.abs(depth);\n\n      if (absDepth === doomed) {\n        this.reParentLeafRows(i, currentGroupIdx);\n        groups.splice(i, 1);\n        i -= 1;\n        len -= 1;\n        tracker.increment(1);\n      } else {\n        if (absDepth > doomed) {\n          tracker.set(absDepth, groupKey);\n          if (absDepth === doomed + 1) {\n            if (lastGroupIsDoomed) {\n              // our pointer will no longer be to a child group but (via the sortSet) to the data.\n              // This can be taken from the first child group (which will be removed)\n              groupRow[IDX_POINTER] = lowestIdxPointer(\n                groups,\n                IDX_POINTER,\n                DEPTH,\n                i + 1,\n                absDepth - 1\n              );\n              groupRow[NEXT_FILTER_IDX] = useFilter\n                ? lowestIdxPointer(groups, NEXT_FILTER_IDX, DEPTH, i + 1, absDepth - 1)\n                : undefined;\n            } else if (currentGroupIdx !== null) {\n              const diff = this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n              i -= diff;\n              len -= diff;\n              tracker.increment(diff);\n            }\n          }\n          currentGroupIdx = i;\n          if (tracker.hasPrevious(absDepth + 1)) {\n            groupRow[PARENT_IDX] -= tracker.previous(absDepth + 1);\n          }\n          groupRow[DEPTH] = decrementDepth(depth);\n        }\n        if (tracker.idxAdjustment > 0) {\n          groupRow[IDX] -= tracker.idxAdjustment;\n          if (Math.abs(groupRow[DEPTH]) > 1) {\n            groupRow[IDX_POINTER] -= tracker.idxAdjustment;\n          }\n        }\n      }\n    }\n    if (!lastGroupIsDoomed) {\n      // don't forget the final group ...\n      this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n    }\n  }\n\n  reParentLeafRows(groupIdx, newParentGroupIdx) {\n    // TODO what about filterSet ?\n    const {\n      groupRows: groups,\n      rowParents,\n      sortSet,\n      meta: { IDX_POINTER, COUNT }\n    } = this;\n    const group = groups[groupIdx];\n    const idx = group[IDX_POINTER];\n    const count = group[COUNT];\n\n    for (let i = idx; i < idx + count; i++) {\n      const rowIdx = sortSet[i];\n      rowParents[rowIdx] = newParentGroupIdx;\n    }\n  }\n\n  regroupChildGroups(currentGroupIdx, nextGroupIdx, baseGroupby, addGroupby) {\n    const { groupRows: groups, data: rows, columns, meta } = this;\n    const { COUNT, IDX_POINTER } = meta;\n    const group = groups[currentGroupIdx];\n    const length = group[COUNT];\n    const startIdx = groups[currentGroupIdx + 1][IDX_POINTER];\n    // We don't really need to go back to rows to regroup, we have partially grouped data already\n    // we could perform the whole operation within groupRows\n    const nestedGroupRows = groupRows(rows, this.sortSet, columns, this.columnMap, addGroupby, {\n      startIdx,\n      length,\n      rootIdx: currentGroupIdx,\n      baseGroupby,\n      groupIdx: currentGroupIdx,\n      rowParents: this.rowParents\n    });\n    const existingChildNodeCount = nextGroupIdx - currentGroupIdx - 1;\n    groups.splice(currentGroupIdx + 1, existingChildNodeCount, ...nestedGroupRows);\n    group[IDX_POINTER] = currentGroupIdx + 1;\n    return existingChildNodeCount - nestedGroupRows.length;\n  }\n\n  // Note: this assumes no leaf rows visible. Is that always valid ?\n  // NOt after removing a groupBy ! Not after a filter\n  countVisibleRows(groupRows, usingFilter = false) {\n    const { DEPTH, COUNT, FILTER_COUNT } = this.meta;\n    let count = 0;\n    for (let i = 0, len = groupRows.length; i < len; i++) {\n      const zeroCount = usingFilter && groupRows[i][FILTER_COUNT] === 0;\n      if (!zeroCount) {\n        count += 1;\n      }\n      const depth = groupRows[i][DEPTH];\n      if (depth < 0 || zeroCount) {\n        while (i < len - 1 && Math.abs(groupRows[i + 1][DEPTH]) < -depth) {\n          i += 1;\n        }\n      } else if (depth === 1) {\n        count += usingFilter ? groupRows[i][FILTER_COUNT] : groupRows[i][COUNT];\n      }\n    }\n    return count;\n  }\n}\n"],
  "mappings": "AAAA,SAAS,uBAAuB;AAChC,SAAS,eAAe,WAAW,uBAAuB;AAC1D,OAAO,mBAAmB;AAC1B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,kBAAkB;AAC3B,SAAS,QAAQ,oBAAoB;AACrC,SAAS,WAAW;AACpB,OAAO,gBAAgB;AAEvB,MAAM,cAAc,CAAC;AAEd,MAAM,oBAAoB,WAAW;AAAA,EAC1C,YACE,QACA,SACA,SACA,YACA,eAAe,MACf,SAAS,OAAO,eAChB;AACA,UAAM,OAAO,OAAO,SAAS,OAAO,UAAU;AAC9C,SAAK,UAAU;AACf,SAAK,aAAa;AAClB,SAAK,eAAe,CAAC;AACrB,SAAK,gBAAgB;AACrB,SAAK,YAAY,CAAC;AAClB,SAAK,mBAAmB,CAAC;AAEzB,SAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI;AAC7D,SAAK,mBAAmB,KAAK,iBAAiB,KAAK,IAAI;AAEvD,YAAQ,QAAQ,CAAC,WAAW;AAC1B,UAAI,OAAO,WAAW;AACpB,cAAM,MAAM,OAAO,UAAU,OAAO;AACpC,aAAK,aAAa,KAAK,CAAC,KAAK,OAAO,SAAS,CAAC;AAC9C,aAAK,iBAAiB,OAAO,OAAO;AAAA,MACtC;AAAA,IACF,CAAC;AACD,SAAK,oBAAoB;AACzB,SAAK,eAAe,MAAM,QAAQ,YAAY,KAAK,aAAa,SAAS,eAAe;AAGxF,SAAK,UAAU,OAAO,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC;AAE1C,SAAK,aAAa,MAAM,OAAO,KAAK,MAAM;AAE1C,SAAK,aAAa,OAAO;AAEzB,UAAM,CAAC,QAAQ,KAAK,KAAK,IAAI,KAAK,oBAAoB,KAAK;AAE3D,SAAK,OAAO,cAAc,KAAK,WAAW,QAAQ,KAAK,MAAM,KAAK,OAAO,KAAK,IAAI;AAElF,QAAI,QAAQ;AACV,WAAK,OAAO,MAAM;AAAA,IACpB;AAAA,EACF;AAAA,EAEA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,QAAQ;AACV,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EACA,IAAI,OAAO;AACT,WAAO,KAAK,KAAK,KAAK,KAAK,SAAS;AAAA,EACtC;AAAA,EAEA,eAAe;AACb,WAAO,KAAK,SAAS,KAAK,OAAO,KAAK;AAAA,EACxC;AAAA,EAEA,SAAS,OAAO,WAAW,MAAM;AAC/B,UAAM,CAAC,aAAa,GAAG,IACrB,CAAC,YAAY,MAAM,OAAO,KAAK,MAAM,MAAM,MAAM,OAAO,KAAK,MAAM,KAC/D,KAAK,KAAK,aAAa,IACvB,KAAK,KAAK,SAAS,OAAO,QAAQ;AAExC,UAAM,cAAc,KAAK,aAAa,KAAK,KAAK;AAChD,UAAM,OAAO,YAAY,IAAI,CAAC,KAAK,MAAM,KAAK,SAAS,KAAK,MAAM,GAAG,WAAW,CAAC;AACjF,SAAK,QAAQ;AACb,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,MACb,iBAAiB,KAAK;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,SAAS,KAAK,KAAK,cAAc;AAC/B,UAAM,EAAE,KAAK,OAAO,MAAM,IAAI,KAAK;AACnC,UAAM,QAAQ,IAAI,MAAM;AACxB,UAAM,OAAO,MAAM,KAAK;AAExB,QAAI,gBAAgB,MAAM,WAAW,KAAK,OAAO,MAAM,kBAAkB,UAAU;AACjF,YAAM,SAAS,MAAM;AAAA,IACvB;AACA,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,SAAS,OAAO,KAAK,MAAM;AACtC,UAAM,EAAE,QAAQ,IAAI;AACpB,SAAK,UAAU,SAAS;AACxB,UAAM,YAAY,gBAAgB,SAAS,KAAK,SAAS;AACzD,SAAK,YAAY,UAAU,MAAM,KAAK,SAAS,SAAS,KAAK,WAAW,WAAW;AAAA,MACjF,QAAQ,KAAK;AAAA,MACb,YAAY,KAAK;AAAA,IACnB,CAAC;AACD,SAAK,gBAAgB,KAAK,iBAAiB,KAAK,SAAS;AAAA,EAC3D;AAAA,EAEA,QAAQ,SAAS;AACf,QAAI,oBAAoB,SAAS,KAAK,OAAO,GAAG;AAC9C,WAAK,YAAY,OAAO;AAAA,IAC1B,WAAW,8BAA8B,SAAS,KAAK,OAAO,GAAG;AAC/D,WAAK,cAAc,OAAO;AAC1B,WAAK,gBAAgB,KAAK,iBAAiB,KAAK,WAAW,KAAK,cAAc,IAAI;AAAA,IACpF,WAAW,8BAA8B,SAAS,KAAK,OAAO,GAAG;AAC/D,WAAK,cAAc,OAAO;AAC1B,WAAK,QAAQ;AACb,WAAK,KAAK,MAAM;AAChB,WAAK,gBAAgB,KAAK,iBAAiB,KAAK,WAAW,KAAK,cAAc,IAAI;AAAA,IACpF,OAAO;AACL,WAAK,aAAa,OAAO;AAAA,IAC3B;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EAIA,cAAc,YAAY;AAExB,UAAM,UAAU,qBAAqB,YAAY,KAAK,UAAU;AAChE,YAAQ,QAAQ,CAAC,CAAC,KAAK,EAAE,UAAU,MAAM;AACvC,YAAM,EAAE,WAAAA,WAAU,IAAI;AACtB,UAAI,QAAQ,KAAK;AACf,aAAK,UAAU,UAAU;AACzB,aAAK,gBAAgB,KAAK,iBAAiBA,YAAW,KAAK;AAAA,MAC7D,OAAO;AACL,cAAM,WAAW,KAAK,aAAa,GAAG;AACtC,YAAI,aAAa,IAAI;AACnB,cAAI,YAAY;AACd,iBAAK,iBAAiB,KAAK,YAAY,UAAUA,UAAS;AAAA,UAC5D,OAAO;AACL,iBAAK,iBAAiB,KAAK,cAAc,UAAUA,UAAS;AAAA,UAC9D;AAAA,QACF,OAAO;AACL,kBAAQ,KAAK,4CAA4C;AAAA,QAC3D;AAAA,MACF;AAAA,IACF,CAAC;AACD,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,YAAY,KAAK,QAAQ;AACvB,WAAO,KAAK,YAAY,KAAK,QAAQ,KAAK,gBAAgB;AAAA,EAC5D;AAAA,EAEA,cAAc,KAAK,QAAQ;AACzB,WAAO,KAAK,YAAY,KAAK,QAAQ,KAAK,mBAAmB;AAAA,EAC/D;AAAA,EAEA,YAAY,UAAUA,YAAW,oBAAoB;AACnD,UAAM,EAAE,OAAO,OAAO,aAAa,IAAI,KAAK;AAC5C,QAAI,aAAa;AACjB,UAAM,WAAWA,WAAU;AAC3B,UAAM,QAAQ,SAAS;AACvB,UAAM,YAAY,KAAK,cAAc;AACrC,aAAS,SAAS,CAAC;AACnB,QAAI,KAAK,IAAI,KAAK,MAAM,GAAG;AACzB,YAAM,YAAY,YAAY,eAAe;AAC7C,mBAAa,SAAS;AAAA,IACxB,OAAO;AACL,mBAAa,mBAAmB,KAAK,IAAI,KAAK,IAAI,GAAG,WAAW,GAAGA,YAAW,SAAS;AAAA,IACzF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,YAAY,UAAUA,YAAW,WAAW;AAC3D,UAAM,EAAE,OAAO,aAAa,IAAI,KAAK;AACrC,QAAI,aAAa;AACjB,aAAS,IAAI,UAAU,IAAIA,WAAU,QAAQ,KAAK;AAChD,YAAM,YAAYA,WAAU,GAAG;AAC/B,UAAI,KAAK,IAAI,SAAS,MAAM,YAAY;AACtC,YAAI,CAAC,aAAaA,WAAU,GAAG,gBAAgB,GAAG;AAChD,wBAAc;AAAA,QAChB;AAAA,MACF,WAAW,KAAK,IAAI,SAAS,IAAI,YAAY;AAC3C;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB,YAAY,UAAUA,YAAW,WAAW;AAC9D,UAAM,EAAE,OAAO,aAAa,IAAI,KAAK;AACrC,QAAI,aAAa;AACjB,aAAS,IAAI,UAAU,IAAIA,WAAU,QAAQ,KAAK;AAChD,YAAM,YAAYA,WAAU,GAAG;AAC/B,UAAI,KAAK,IAAI,SAAS,MAAM,YAAY;AACtC,YAAI,CAAC,aAAaA,WAAU,GAAG,gBAAgB,GAAG;AAChD,wBAAc;AACd,cAAI,YAAY,GAAG;AACjB,0BAAc,KAAK,cAAc,GAAGA,UAAS;AAAA,UAC/C;AAAA,QACF;AAAA,MACF,WAAW,KAAK,IAAI,SAAS,IAAI,YAAY;AAC3C;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,KAAK,cAAc;AACjB,UAAM,EAAE,WAAW,OAAO,IAAI;AAC9B,UAAM,EAAE,KAAK,OAAO,OAAO,YAAY,IAAI,KAAK;AAChD,SAAK,eAAe,MAAM,QAAQ,YAAY,KAAK,aAAa,SAAS,eAAe;AAExF,UAAM,WAAW,gBAAgB,cAAc,KAAK,SAAS;AAE7D,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,WAAW,OAAO;AACxB,YAAM,QAAQ,SAAS;AACvB,YAAM,QAAQ,SAAS;AACvB,YAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,YAAM,UAAU,SAAS;AACzB,UAAI,aAAa,GAAG;AAClB,aAAK,eAAe,SAAS,OAAO,UAAU,GAAG;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AAAA,EAEA,eAAe,UAAU,QAAQ,cAAc,KAAK;AAClD,UAAM,OAAO,CAAC;AACd,aAAS,IAAI,UAAU,IAAI,WAAW,QAAQ,KAAK;AACjD,YAAM,SAAS,KAAK,QAAQ;AAC5B,WAAK,KAAK,KAAK,KAAK,OAAO;AAAA,IAC7B;AACA,SAAK,KAAK,OAAO,YAAY,CAAC;AAC9B,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,WAAK,QAAQ,IAAI,YAAY,KAAK,GAAG;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,cAA8B;AAC5B,SAAK,gBAAgB;AACrB,SAAK,YAAY;AAEjB,UAAM,EAAE,MAAM,MAAM,WAAW,QAAQ,SAAS,QAAQ,IAAI;AAC5D,UAAM,EAAE,OAAO,cAAc,gBAAgB,IAAI,KAAK;AACtD,UAAM,eAAe,sBAAsB,SAAS,KAAK,WAAW,KAAK,OAAO;AAEhF,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,WAAW,OAAO;AACtB,UAAI,OAAO,SAAS,kBAAkB,YAAY,SAAS,SAAS,SAAS,eAAe;AAC1F,uBAAe,QAAQ,GAAG,SAAS,MAAM,SAAS,YAAY;AAC9D,iBAAS,gBAAgB;AACzB,iBAAS,mBAAmB;AAAA,MAC9B;AAAA,IACF;AAEA,SAAK,KAAK,UAAU,KAAK,oBAAoB,KAAK,CAAC;AACnD,SAAK,gBAAgB,KAAK,iBAAiB,QAAQ,KAAK;AAAA,EAC1D;AAAA,EAEA,OAAO,QAAQ;AACb,UAAM,uBAAuB,cAAc,KAAK,eAAe,MAAM;AACrE,UAAM,KAAK,UAAU,gBAAgB,KAAK,WAAW,MAAM;AAC3D,UAAM,EAAE,OAAO,OAAO,YAAY,cAAc,gBAAgB,IAAI,KAAK;AACzE,UAAM,EAAE,MAAM,MAAM,WAAW,OAAO,IAAI;AAC1C,QAAI,CAAC,QAAQ,SAAS,SAAS,IAAI,KAAK;AAAA,MACtC,wBAAwB,KAAK;AAAA,IAC/B;AACA,UAAM,eAAe,CAAC;AAEtB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,WAAW,OAAO;AACtB,YAAM,QAAQ,SAAS;AACvB,YAAM,QAAQ,SAAS,UAAU,WAAW,KAAK;AACjD,YAAM,WAAW,KAAK,IAAI,KAAK;AAE/B,UAAI,aAAa,GAAG;AAClB,cAAM,UAAU,SAAS;AACzB,YAAI,WAAW;AAEf,iBAAS,KAAK,SAAS,KAAK,UAAU,OAAO,MAAM;AACjD,gBAAM,SAAS,OAAO;AACtB,gBAAM,MAAM,KAAK;AACjB,gBAAM,aAAa,GAAG,GAAG;AACzB,cAAI,YAAY;AACd,wBAAY;AACZ,gBAAI,aAAa,GAAG;AAClB,uBAAS,mBAAmB,aAAa;AAAA,YAC3C;AACA,yBAAa,KAAK,MAAM;AAAA,UAC1B;AAAA,QACF;AAEA,iBAAS,gBAAgB;AACzB,YAAI,eAAe;AAEnB,YAAI,KAAK,aAAa,QAAQ;AAC5B,yBAAe,KAAK,aAAa,IAAI,CAAC,CAACC,IAAG,CAAC,MAAM,CAACA,IAAG,GAAG,CAAC,CAAC;AAC1D,gBAAM,MAAM,aAAa;AACzB,mBAAS,KAAK,MAAM,UAAU,KAAK,KAAK,MAAM;AAC5C,kBAAM,SAAS,aAAa;AAC5B,kBAAM,MAAM,KAAK;AACjB,qBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,kBAAI,CAAC,MAAM,IAAI,aAAa;AAC5B,2BAAa,GAAG,MAAM,IAAI;AAAA,YAC5B;AAAA,UACF;AAGA,uBAAa,QAAQ,CAAC,gBAAgB;AACpC,kBAAM,CAAC,QAAQ,MAAM,GAAG,IAAI;AAC5B,gBAAI,SAAS,OAAO;AAClB,uBAAS,UAAU;AAAA,YACrB,WAAW,SAAS,OAAO;AACzB,uBAAS,UAAU,MAAM;AAAA,YAC3B;AAAA,UACF,CAAC;AAAA,QACH;AAGA,YAAI,WAAW,GAAG;AAChB,iBAAO,SAAS,gBAAgB,MAAM;AACpC,uBAAW,OAAO,SAAS;AAE3B,yBAAa,QAAQ,CAAC,gBAAgB;AACpC,oBAAM,CAAC,QAAQ,MAAM,GAAG,IAAI;AAC5B,kBAAI,SAAS,OAAO;AAClB,yBAAS,WAAW;AAAA,cACtB,WAAW,SAAS,OAAO;AACzB,sBAAM,gBAAgB,SAAS;AAC/B,sBAAM,cAAc,gBAAgB,SAAS;AAC7C,yBAAS,WAAW,cAAc,QAAQ,gBAAgB;AAAA,cAC5D;AAAA,YACF,CAAC;AACD,qBAAS,iBAAiB;AAAA,UAC5B;AAAA,QACF;AAAA,MACF,OAAO;AAGL,iBAAS,gBAAgB;AACzB,aAAK,aAAa,QAAQ,CAAC,gBAAgB;AACzC,gBAAM,CAAC,MAAM,IAAI;AACjB,mBAAS,UAAU;AAAA,QACrB,CAAC;AAAA,MACH;AAAA,IACF;AACA,SAAK,YAAY;AACjB,SAAK,gBAAgB;AACrB,SAAK,gBAAgB,KAAK,iBAAiB,KAAK,WAAW,IAAI;AAE/D,SAAK,KAAK,UAAU,KAAK,oBAAoB,IAAI,CAAC;AAAA,EACpD;AAAA,EAEA,OAAO,QAAQ,SAAS;AACtB,UAAM;AAAA,MACJ,WAAW;AAAA,MACX;AAAA,MACA;AAAA,MACA,OAAO,EAAE,GAAG;AAAA,IACd,IAAI;AACJ,UAAM,EAAE,OAAO,cAAc,WAAW,IAAI,KAAK;AAEjD,QAAI;AACJ,UAAM,aAAa,CAAC;AAEpB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,GAAG;AAE1C,YAAM,SAAS,QAAQ;AACvB,YAAM,gBAAgB,QAAQ,IAAI;AAClC,YAAM,QAAQ,QAAQ,IAAI;AAC1B,iBAAW,KAAK,QAAQ,eAAe,KAAK;AAE5C,UAAI,SAAS,WAAW;AAExB,UAAI,KAAK;AAGT,UAAI,KAAK,iBAAiB,SAAS;AACjC,uBAAe,gBAAgB,CAAC;AAEhC,WAAG;AACD,cAAI,WAAW,OAAO;AAEtB,cAAI,qBAAqB,SAAS;AAClC,gBAAM,OAAO,QAAQ;AACrB,gBAAM,OAAO,KAAK,iBAAiB;AACnC,cAAI,SAAS,OAAO;AAElB,qBAAS,WAAW;AAAA,UACtB,WAAW,SAAS,OAAO;AACzB,kBAAM,QAAQ,SAAS,UAAU,cAAc,KAAK;AACpD,qBAAS,WAAW,SAAS,UAAU,QAAQ,QAAQ;AAAA,UACzD;AAEA,WAAC,aAAa,QAAQ,aAAa,MAAM,CAAC,MAAM,IAAI;AAAA,YAClD;AAAA,YACA;AAAA,YACA,SAAS;AAAA,UACX;AAEA,mBAAS,SAAS;AAClB,gBAAM;AAAA,QACR,SAAS,WAAW;AAAA,MACtB;AAAA,IACF;AAEA,UAAM,kBAAkB,CAAC;AAGzB,QAAI,cAAc;AAEhB,eAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,cAAM,CAAC,WAAWC,QAAO,IAAI,aAAa;AAE1C,cAAMC,YAAW,KAAK,KAAK,qBAAqB,MAAM;AACtD,YAAIA,cAAa,IAAI;AACnB,0BAAgB,KAAK,CAAC,KAAKA,YAAW,QAAQ,GAAGD,QAAO,CAAC;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AACA,UAAM,WAAW,KAAK,KAAK,mBAAmB,MAAM;AACpD,QAAI,aAAa,IAAI;AAEnB,sBAAgB,KAAK,CAAC,KAAK,WAAW,QAAQ,GAAG,UAAU,CAAC;AAAA,IAC9D;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,WAAW,KAAK;AAErB,UAAM,EAAE,WAAW,QAAQ,SAAS,MAAM,MAAM,SAAS,SAAS,MAAM,MAAM,SAAS,IAAI;AAC3F,QAAI,YAAY,gBAAgB,SAAS,KAAK,SAAS;AACvD,UAAM,iBAAiB,mBAAmB,QAAQ,WAAW,GAAG;AAChE,UAAM,EAAE,KAAK,OAAO,KAAK,YAAY,IAAI;AACzC,UAAM,iBAAiB,CAAC,CAAC,KAAK,KAAK,CAAC;AACpC,UAAM,iBAAiB,eAAe,WAAW,QAAQ;AACzD,UAAM,gBAAgB,eAAe,WAAW;AAChD,UAAM,kBAAkB,CAAC,iBAAiB,CAAC;AAC3C,QAAI;AACJ,QAAI,cAAc;AAElB,QAAI,gBAAgB;AAElB,UAAI,SAAS,eAAe,eAAe,SAAS;AACpD,YAAM,WAAW,OAAO;AACxB,WAAK,WAAW,aAAa;AAC7B,UAAI,QAAQ,SAAS;AAErB,YAAM,iBAAiB,SAAS,eAAe;AAE/C,4BAAsB,QAAQ,gBAAgB,IAAI;AAClD,cAAQ,OAAO,gBAAgB,GAAG,IAAI,IAAI;AAC1C,UAAI,kBAAkB,QAAQ,UAAU,IAAI,GAAG;AAC7C,aAAK,iBAAiB;AAAA,MACxB;AAAA,IACF,OAAO;AACL,oBAAc;AAAA,QACZ;AAAA,QACA,OAAO,cAAc;AAAA,QACrB,UAAU,WAAW,KAAK,IAAI;AAAA,QAC9B;AAAA,MACF;AACA,cAAQ,KAAK,SAAS;AACtB,UAAI,cAAc,aAAa;AAE/B,UAAI,iBAAiB;AACnB,sBAAc,UAAU,MAAM,GAAG,eAAe,MAAM;AACtD,kBAAU,OAAO,eAAe,eAAe,SAAS,IAAI;AAC5D,oBAAY,UAAU,MAAM,eAAe,MAAM;AAAA,MACnD;AAEA,qBAAe,UAAU,MAAM,SAAS,SAAS,KAAK,WAAW,WAAW;AAAA,QAC1E,UAAU,QAAQ,SAAS;AAAA,QAC3B,QAAQ;AAAA,QACR,UAAU,cAAc;AAAA,QACxB;AAAA,QACA;AAAA,MACF,CAAC;AAED,yBAAmB,QAAQ,aAAa,MAAM,aAAa,MAAM;AACjE,aAAO,OAAO,MAAM,QAAQ,CAAC,aAAa,CAAC,EAAE,OAAO,YAAY,CAAC;AAAA,IACnE;AAEA,SAAK,qBAAqB,cAAc;AACxC,SAAK,uBAAuB,gBAAgB,GAAG;AAE/C,aAAS,QAAQ;AACjB,QAAI,WAAW,iBACX,SAAS,mBAAmB,SAAS,IACrC,SAAS,qBAAqB,WAAW;AAE7C,QAAI,aAAa,IAAI;AAEnB,eAAS,EAAE,SAAS,KAAK;AACzB,UAAI,gBAAgB,MAAM;AACxB,aAAK,iBAAiB;AAAA,MACxB;AAAA,IACF,WAAW,kBAAkB,OAAO;AAElC,eAAS,EAAE,SAAS,KAAK,oBAAoB,cAAc,EAAE;AAAA,IAC/D;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,qBAAqB,gBAAgB;AACnC,UAAM;AAAA,MACJ,WAAW;AAAA,MACX,MAAM,EAAE,MAAM;AAAA,IAChB,IAAI;AACJ,mBAAe,QAAQ,CAAC,WAAW;AACjC,YAAM,QAAQ,OAAO;AACrB,YAAM,UAAU;AAAA,IAClB,CAAC;AAAA,EACH;AAAA,EAEA,uBAAuB,gBAAgB,KAAK;AAC1C,UAAM,EAAE,WAAW,OAAO,IAAI;AAE9B,mBAAe,QAAQ,CAAC,WAAW;AACjC,YAAM,QAAQ,OAAO;AACrB,eAAS,CAAC,KAAK,IAAI,KAAK,KAAK,cAAc;AACzC,cAAM,QAAQ,IAAI;AAClB,cAAM,aAAa,MAAM;AACzB,YAAI,SAAS,OAAO;AAClB,gBAAM,OAAO,aAAa;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,oBAAoB,gBAAgB;AAClC,UAAM;AAAA,MACJ;AAAA,MACA,WAAW;AAAA,MACX,MAAM,EAAE,MAAM;AAAA,MACd;AAAA,IACF,IAAI;AACJ,UAAM,UAAU,CAAC;AACjB,aAAS,UAAU,gBAAgB;AACjC,YAAM,WAAW,KAAK,KAAK,qBAAqB,MAAM;AACtD,UAAI,aAAa,IAAI;AACnB,cAAM,QAAQ,OAAO;AACrB,cAAM,SAAS,CAAC,WAAW,QAAQ,OAAO,MAAM,MAAM;AACtD,iBAAS,CAAC,GAAG,KAAK,cAAc;AAC9B,iBAAO,KAAK,KAAK,MAAM,IAAI;AAAA,QAC7B;AACA,gBAAQ,KAAK,MAAM;AAAA,MACrB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAGA,aAAa,UAAU;AACrB,UAAM,EAAE,WAAAF,YAAW,KAAK,IAAI;AAC5B,aAAS,IAAI,GAAG,IAAIA,WAAU,QAAQ,KAAK;AACzC,UAAIA,WAAU,GAAG,KAAK,SAAS,UAAU;AACvC,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAGA,UAAU,YAAY;AACpB,UAAM,OAAO,aAAa,IAAI;AAG9B,UAAM,EAAE,MAAM,IAAI,KAAK;AACvB,UAAM,EAAE,WAAW,OAAO,IAAI;AAC9B,SAAK,oBAAoB;AACzB,aAAS,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,KAAK;AACjD,YAAM,QAAQ,OAAO,GAAG;AAExB,aAAO,GAAG,SAAS,KAAK,IAAI,KAAK,IAAI;AAAA,IAEvC;AAAA,EACF;AAAA,EAEA,YAAY,SAAS;AACnB,UAAM,EAAE,KAAK,KAAK,OAAO,aAAa,WAAW,IAAI,KAAK;AAC1D,UAAM,EAAE,WAAW,OAAO,IAAI;AAC9B,UAAM,YAAY,gBAAgB,SAAS,KAAK,SAAS;AACzD,UAAM,CAAC,QAAQ,KAAK,IAAI,cAAc,SAAS,KAAK,OAAO;AAC3D,QAAI,QAAQ;AACZ,QAAI,IAAI;AACR,WAAO,IAAI,OAAO,QAAQ,KAAK;AAC7B,UAAI,KAAK,IAAI,OAAO,GAAG,MAAM,IAAI,OAAO;AACtC,YAAI,QAAQ,GAAG;AACb,eAAK,oBAAoB,WAAW,QAAQ,IAAI,OAAO,KAAK;AAC5D,kBAAQ;AAAA,QACV;AAAA,MACF,OAAO;AACL,iBAAS;AAAA,MACX;AAAA,IACF;AAEA,SAAK,oBAAoB,WAAW,QAAQ,IAAI,OAAO,KAAK;AAE5D,UAAM,UAAU,IAAI,cAAc,QAAQ,MAAM;AAChD,SAAK,UAAU,QAAQ,CAAC,UAAUC,OAAM;AACtC,YAAMG,SAAQ,SAAS;AACvB,YAAM,WAAW,SAAS;AAC1B,YAAM,WAAW,KAAK,IAAIA,MAAK;AAC/B,cAAQ,IAAI,UAAUH,IAAG,QAAQ;AACjC,eAAS,OAAOA;AAChB,UAAI,WAAW,GAAG;AAChB,iBAAS,eAAeA,KAAI;AAAA,MAC9B;AACA,UAAI,QAAQ,aAAa,QAAQ,GAAG;AAClC,iBAAS,cAAc,QAAQ,UAAU,QAAQ;AAAA,MACnD;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,oBAAoB,SAAS,QAAQ,WAAW,GAAG,SAAS,KAAK,UAAU,QAAQ;AACjF,UAAM,EAAE,WAAW,OAAO,IAAI;AAC9B,QAAI,YAAY,WAAW;AAC3B,UAAM,CAAC,aAAa,SAAS,IAAI,QAAQ;AACzC,UAAM,SAAS,CAAC,IAAI,OAAQ,cAAc,MAAM,KAAK,KAAK,KAAK;AAC/D,UAAM,QAAQ,CAAC,IAAI,OAAQ,cAAc,MAAM,KAAK,KAAK,KAAK;AAC9D,QAAI,aAAa;AACjB,aAAS,IAAI,UAAU,IAAI,WAAW,QAAQ,KAAK;AACjD,YAAM,MAAM,OAAO,GAAG;AACtB,UAAI,eAAe,MAAM;AACvB,qBAAa;AAAA,MACf,WAAW,OAAO,KAAK,UAAU,GAAG;AAClC,cAAM,cAAc,OAAO,OAAO,UAAU,IAAI,QAAQ;AACxD,qBAAa,YAAY;AACzB,eAAO,OAAO,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,OAAO,WAAW,CAAC;AAC9D,qBAAa;AACb,YAAI,WAAW;AAAA,MACjB,WAAW,MAAM,KAAK,UAAU,GAAG;AACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAKA,cAAc,SAAS;AACrB,UAAM,YAAY,gBAAgB,SAAS,KAAK,SAAS;AACzD,UAAM,gBAAgB,UAAU,MAAM,GAAG,KAAK,QAAQ,MAAM;AAC5D,UAAM,mBAAmB,UAAU,MAAM,KAAK,QAAQ,MAAM;AAC5D,UAAM;AAAA,MACJ,WAAW;AAAA,MACX,SAAS;AAAA,MACT,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,EAAE,aAAa,YAAY,gBAAgB,IAAI;AACrD,UAAM,aAAa,YAAY;AAC/B,UAAM,UAAU,IAAI,gBAAgB,aAAa,CAAC;AAClD,UAAM,WAAW,KAAK,gBAClB,gBAAgB,KAAK,WAAW,KAAK,aAAa,IAClD;AAGJ,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,WAAW,OAAO;AACxB,UAAI,QAAQ,eAAe;AACzB,iBAAS,KAAK,QAAQ,QAAQ;AAAA,MAChC;AAEA,YAAM,UAAU,SAAS,KAAK;AAC9B,YAAM,QAAQ,SAAS,KAAK;AAC5B,YAAM,SAAS,SAAS,KAAK;AAC7B,YAAM,WAAW,SAAS,KAAK;AAE/B,YAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,eAAS,KAAK,SAAS,eAAe,KAAK;AAC3C,YAAM,eAAe,SAAS,KAAK;AACnC,YAAM,YAAY,SAAS;AAC3B,eAAS,KAAK,mBAAmB;AAEjC,UAAI,QAAQ,YAAY,WAAW,CAAC,GAAG;AACrC,iBAAS,eAAe,QAAQ,SAAS,WAAW,CAAC;AAAA,MACvD;AAEA,UAAI,aAAa,GAAG;AAClB,cAAM,WAAW,SAAS;AAC1B,cAAM,kBAAkB;AAAA,UACtB;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL;AAAA,UACA;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA,aAAa;AAAA,YACb,UAAU;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,YAAY,KAAK;AAAA,UACnB;AAAA,QACF;AACA,cAAM,mBAAmB,gBAAgB;AAEzC,eAAO,OAAO,IAAI,GAAG,GAAG,GAAG,eAAe;AAC1C,aAAK;AACL,gBAAQ,UAAU,gBAAgB;AAAA,MACpC,OAAO;AACL,gBAAQ,IAAI,UAAU,QAAQ;AAAA,MAChC;AAEA,eAAS,eAAe,UAAU;AAAA,IACpC;AAAA,EACF;AAAA,EAEA,cAAc,SAAS;AACrB,UAAM,EAAE,WAAW,QAAQ,UAAU,IAAI;AACzC,UAAM,CAAC,MAAM,IAAI,uBAAuB,SAAS,KAAK,OAAO;AAC7D,UAAM,YAAY,gBAAgB,KAAK,SAAS,KAAK,SAAS;AAC9D,UAAM,CAAC,mBAAmB,aAAa,UAAU,IAAI;AAAA,MACnD;AAAA,MACA;AAAA,IACF;AACA,UAAM,EAAE,KAAK,OAAO,KAAK,aAAa,YAAY,gBAAgB,IAAI,KAAK;AAC3E,UAAM,UAAU,IAAI,gBAAgB,QAAQ,MAAM;AAClD,UAAM,YAAY,cAAc;AAChC,QAAI,kBAAkB;AACtB,QAAI,IAAI;AACR,aAAS,MAAM,OAAO,QAAQ,IAAI,KAAK,KAAK;AAC1C,YAAM,WAAW,OAAO;AACxB,YAAM,QAAQ,SAAS;AACvB,YAAM,WAAW,SAAS;AAC1B,YAAM,WAAW,KAAK,IAAI,KAAK;AAE/B,UAAI,aAAa,QAAQ;AACvB,aAAK,iBAAiB,GAAG,eAAe;AACxC,eAAO,OAAO,GAAG,CAAC;AAClB,aAAK;AACL,eAAO;AACP,gBAAQ,UAAU,CAAC;AAAA,MACrB,OAAO;AACL,YAAI,WAAW,QAAQ;AACrB,kBAAQ,IAAI,UAAU,QAAQ;AAC9B,cAAI,aAAa,SAAS,GAAG;AAC3B,gBAAI,mBAAmB;AAGrB,uBAAS,eAAe;AAAA,gBACtB;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,IAAI;AAAA,gBACJ,WAAW;AAAA,cACb;AACA,uBAAS,mBAAmB,YACxB,iBAAiB,QAAQ,iBAAiB,OAAO,IAAI,GAAG,WAAW,CAAC,IACpE;AAAA,YACN,WAAW,oBAAoB,MAAM;AACnC,oBAAM,OAAO,KAAK,mBAAmB,iBAAiB,GAAG,aAAa,UAAU;AAChF,mBAAK;AACL,qBAAO;AACP,sBAAQ,UAAU,IAAI;AAAA,YACxB;AAAA,UACF;AACA,4BAAkB;AAClB,cAAI,QAAQ,YAAY,WAAW,CAAC,GAAG;AACrC,qBAAS,eAAe,QAAQ,SAAS,WAAW,CAAC;AAAA,UACvD;AACA,mBAAS,SAAS,eAAe,KAAK;AAAA,QACxC;AACA,YAAI,QAAQ,gBAAgB,GAAG;AAC7B,mBAAS,QAAQ,QAAQ;AACzB,cAAI,KAAK,IAAI,SAAS,MAAM,IAAI,GAAG;AACjC,qBAAS,gBAAgB,QAAQ;AAAA,UACnC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,mBAAmB;AAEtB,WAAK,mBAAmB,iBAAiB,GAAG,aAAa,UAAU;AAAA,IACrE;AAAA,EACF;AAAA,EAEA,iBAAiB,UAAU,mBAAmB;AAE5C,UAAM;AAAA,MACJ,WAAW;AAAA,MACX;AAAA,MACA;AAAA,MACA,MAAM,EAAE,aAAa,MAAM;AAAA,IAC7B,IAAI;AACJ,UAAM,QAAQ,OAAO;AACrB,UAAM,MAAM,MAAM;AAClB,UAAM,QAAQ,MAAM;AAEpB,aAAS,IAAI,KAAK,IAAI,MAAM,OAAO,KAAK;AACtC,YAAM,SAAS,QAAQ;AACvB,iBAAW,UAAU;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,mBAAmB,iBAAiB,cAAc,aAAa,YAAY;AACzE,UAAM,EAAE,WAAW,QAAQ,MAAM,MAAM,SAAS,KAAK,IAAI;AACzD,UAAM,EAAE,OAAO,YAAY,IAAI;AAC/B,UAAM,QAAQ,OAAO;AACrB,UAAM,SAAS,MAAM;AACrB,UAAM,WAAW,OAAO,kBAAkB,GAAG;AAG7C,UAAM,kBAAkB,UAAU,MAAM,KAAK,SAAS,SAAS,KAAK,WAAW,YAAY;AAAA,MACzF;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT;AAAA,MACA,UAAU;AAAA,MACV,YAAY,KAAK;AAAA,IACnB,CAAC;AACD,UAAM,yBAAyB,eAAe,kBAAkB;AAChE,WAAO,OAAO,kBAAkB,GAAG,wBAAwB,GAAG,eAAe;AAC7E,UAAM,eAAe,kBAAkB;AACvC,WAAO,yBAAyB,gBAAgB;AAAA,EAClD;AAAA,EAIA,iBAAiBD,YAAW,cAAc,OAAO;AAC/C,UAAM,EAAE,OAAO,OAAO,aAAa,IAAI,KAAK;AAC5C,QAAI,QAAQ;AACZ,aAAS,IAAI,GAAG,MAAMA,WAAU,QAAQ,IAAI,KAAK,KAAK;AACpD,YAAM,YAAY,eAAeA,WAAU,GAAG,kBAAkB;AAChE,UAAI,CAAC,WAAW;AACd,iBAAS;AAAA,MACX;AACA,YAAM,QAAQA,WAAU,GAAG;AAC3B,UAAI,QAAQ,KAAK,WAAW;AAC1B,eAAO,IAAI,MAAM,KAAK,KAAK,IAAIA,WAAU,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO;AAChE,eAAK;AAAA,QACP;AAAA,MACF,WAAW,UAAU,GAAG;AACtB,iBAAS,cAAcA,WAAU,GAAG,gBAAgBA,WAAU,GAAG;AAAA,MACnE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;",
  "names": ["groupRows", "i", "updates", "rangeIdx", "depth"]
}
