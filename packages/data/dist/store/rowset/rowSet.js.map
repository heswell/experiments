{
  "version": 3,
  "sources": ["../../../src/store/rowset/rowSet.ts"],
  "sourcesContent": ["/**\n * Keep all except for groupRowset in this file to avoid circular reference warnings\n */\nimport * as d3 from 'd3-array';\nimport { mapSortCriteria, metaData, projectColumns } from '../columnUtils.js';\nimport {\n  BIN_FILTER_DATA_COLUMNS,\n  extendsFilter,\n  extractFilterForColumn,\n  functor as filterPredicate,\n  overrideColName,\n  SET_FILTER_DATA_COLUMNS,\n  splitFilterOnColumn\n} from '../filter.js';\nimport { groupbyExtendsExistingGroupby } from '../groupUtils.js';\nimport { getDeltaRange, getFullRange, NULL_RANGE } from '../rangeUtils.js';\nimport { addRowsToIndex, arrayOfIndices } from '../rowUtils.js';\nimport SelectionModel, { SelectionModelType } from '../selection-model.js';\nimport {\n  sort,\n  sortableFilterSet,\n  sortBy,\n  sortExtend,\n  sortPosition,\n  sortReversed\n} from '../sort.js';\nimport Table from '../table.js';\nimport { DataTypes } from '../types.js';\n\nconst SINGLE_COLUMN = 1;\n\nconst NO_OPTIONS = {\n  filter: null\n};\n\nexport default class BaseRowSet {\n  constructor(table, columns, offset = 0) {\n    this.table = table;\n    this.offset = offset;\n    this.baseOffset = offset;\n    this.range = NULL_RANGE;\n    this.columns = columns;\n    this.currentFilter = null;\n    this.filterSet = null;\n    this.columnMap = table.columnMap;\n    this.meta = metaData(columns);\n    this.data = table.rows;\n    this.selected = { rows: [], focusedIdx: -1, lastTouchIdx: -1 };\n    /**\n     * data IDX of selected rows\n     */\n    this.selectedRowsIDX = [];\n    this.selectionModel = this.createSelectionModel();\n  }\n\n  createSelectionModel() {\n    return new SelectionModel();\n  }\n\n  // used by binned rowset\n  get filteredData() {\n    if (this.filterSet) {\n      return this.filterSet;\n    } else {\n      const { IDX } = this.meta;\n      return this.data.map((row) => row[IDX]);\n    }\n  }\n\n  get stats() {\n    // TODO cache the stats and invalidate them in the event of any op that might change them\n    const { totalRowCount, filteredRowCount, selected, selectedRowsIDX } = this;\n    const totalSelected = selectedRowsIDX.length;\n    const filteredSelected = selected.rows.length;\n\n    return {\n      totalRowCount,\n      totalSelected,\n      filteredRowCount,\n      filteredSelected\n    };\n  }\n\n  get totalRowCount() {\n    return this.data.length;\n  }\n\n  get filteredRowCount() {\n    return this.filterSet === null ? this.data.length : this.filterSet.length;\n  }\n\n  get selectedRowCount() {\n    return this.selected.rows.length;\n  }\n\n  setRange(range = this.range, useDelta = true, includeStats = false) {\n    const { lo, hi } = useDelta ? getDeltaRange(this.range, range) : getFullRange(range);\n    const resultset = this.slice(lo, hi);\n    this.range = range;\n    return {\n      dataType: this.type,\n      rows: resultset,\n      range,\n      size: this.size,\n      offset: this.offset,\n      stats: includeStats ? this.stats : undefined\n    };\n  }\n\n  currentRange() {\n    const { lo, hi } = this.range;\n    const resultset = this.slice(lo, hi);\n    return {\n      dataType: this.type,\n      rows: resultset,\n      range: this.range,\n      size: this.size,\n      offset: this.offset\n    };\n  }\n\n  select(idx, rangeSelect, keepExistingSelection) {\n    const {\n      meta: { SELECTED },\n      selectionModel,\n      range: { lo, hi },\n      filterSet,\n      sortSet,\n      offset\n    } = this;\n\n    const { selected, deselected, ...selectionState } = selectionModel.select(\n      this.selected,\n      idx,\n      rangeSelect,\n      keepExistingSelection\n    );\n\n    this.selected = selectionState;\n\n    if (filterSet) {\n      if (selected.length) {\n        this.selectedRowsIDX.push(...selected.map((i) => filterSet[i]));\n      }\n      if (deselected.length) {\n        const deselectedRowIDX = deselected.map((i) => filterSet[i]);\n        this.selectedRowsIDX = this.selectedRowsIDX.filter(\n          (rowIdx) => !deselectedRowIDX.includes(rowIdx)\n        );\n      }\n    } else {\n      const idxToIDX = (idx) => sortSet[idx][0];\n      this.selectedRowsIDX = this.selected.rows.map(idxToIDX);\n    }\n\n    const updates = [];\n    for (let i = 0; i < selected.length; i++) {\n      const idx = selected[i];\n      if (idx >= lo && idx < hi) {\n        updates.push([idx + offset, SELECTED, 1]);\n      }\n    }\n    for (let i = 0; i < deselected.length; i++) {\n      const idx = deselected[i];\n      if (idx >= lo && idx < hi) {\n        updates.push([idx + offset, SELECTED, 0]);\n      }\n    }\n\n    return updates;\n  }\n\n  selectAll() {\n    const {\n      data,\n      selected,\n      selectedRowsIDX,\n      meta: { SELECTED },\n      range: { lo, hi },\n      filterSet,\n      offset\n    } = this;\n    const previouslySelectedRows = [...this.selected.rows];\n    if (filterSet) {\n      // selection of a filtered subset is added to existing selection\n      for (let i = 0; i < filterSet.length; i++) {\n        const rowIDX = filterSet[i];\n        if (!selectedRowsIDX.includes(rowIDX)) {\n          selected.rows.push(i); // does it matter if thes eend up out of sequence ?\n          selectedRowsIDX.push(rowIDX);\n        }\n      }\n    } else {\n      // Step 1: brute force approach, actually create list of selected indices\n      // need to replace this with a structure that tracks ranges\n      this.selected = { rows: arrayOfIndices(data.length), focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = [...this.selected.rows];\n    }\n\n    const updates = [];\n    const max = Math.min(hi, (filterSet || data).length);\n    for (let i = lo; i < max; i++) {\n      if (this.selected.rows.includes(i) && !previouslySelectedRows.includes(i)) {\n        updates.push([i + offset, SELECTED, 1]);\n      }\n    }\n\n    return updates;\n  }\n\n  selectNone() {\n    const {\n      meta: { SELECTED },\n      range: { lo, hi },\n      filterSet,\n      offset\n    } = this;\n    const previouslySelectedRows = this.selectedRowsIDX;\n    if (filterSet) {\n      this.selected = { rows: [], focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = this.selectedRowsIDX.filter((idx) => !filterSet.includes(idx));\n    } else {\n      this.selected = { rows: [], focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = [];\n    }\n    const updates = [];\n    for (let i = lo; i < hi; i++) {\n      const idx = filterSet ? filterSet[i] : i;\n      if (previouslySelectedRows.includes(idx)) {\n        updates.push([i + offset, SELECTED, 0]);\n      }\n    }\n    return updates;\n  }\n\n  selectNavigationSet(useFilter) {\n    const { COUNT, IDX_POINTER, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n    return useFilter\n      ? [this.filterSet, NEXT_FILTER_IDX, FILTER_COUNT]\n      : [this.sortSet, IDX_POINTER, COUNT];\n  }\n\n  //TODO cnahge to return a rowSet, same as getDistinctValuesForColumn\n  getBinnedValuesForColumn(column) {\n    const key = this.columnMap[column.name];\n    const { data: rows, filteredData } = this;\n    const numbers = filteredData.map((rowIdx) => rows[rowIdx][key]);\n    const data = d3\n      .histogram()\n      .thresholds(20)(numbers)\n      .map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n\n    const table = new Table({ data, primaryKey: 'bin', columns: BIN_FILTER_DATA_COLUMNS });\n    const filterRowset = new BinFilterRowSet(table, BIN_FILTER_DATA_COLUMNS, column.name);\n    return filterRowset;\n  }\n\n  getDistinctValuesForColumn(column) {\n    const { data: rows, columnMap, currentFilter } = this;\n    const colIdx = columnMap[column.name];\n    const resultMap = {};\n    const data = [];\n    const dataRowCount = rows.length;\n    const [, /*columnFilter*/ otherFilters] = splitFilterOnColumn(currentFilter, column);\n    // this filter for column that we remove will provide our selected values\n    let dataRowAllFilters = 0;\n\n    if (otherFilters === null) {\n      let result;\n      for (let i = 0; i < dataRowCount; i++) {\n        const val = rows[i][colIdx];\n        if ((result = resultMap[val])) {\n          result[2] = ++result[1];\n        } else {\n          result = [val, 1, 1];\n          resultMap[val] = result;\n          data.push(result);\n        }\n      }\n      dataRowAllFilters = dataRowCount;\n    } else {\n      const fn = filterPredicate(columnMap, otherFilters);\n      let result;\n\n      for (let i = 0; i < dataRowCount; i++) {\n        const row = rows[i];\n        const val = row[colIdx];\n        const isIncluded = fn(row) ? 1 : 0;\n        if ((result = resultMap[val])) {\n          result[1] += isIncluded;\n          result[2]++;\n        } else {\n          result = [val, isIncluded, 1];\n          resultMap[val] = result;\n          data.push(result);\n        }\n        dataRowAllFilters += isIncluded;\n      }\n    }\n\n    //TODO primary key should be indicated in columns\n    const table = new Table({ data, primaryKey: 'name', columns: SET_FILTER_DATA_COLUMNS });\n    return new SetFilterRowSet(\n      table,\n      SET_FILTER_DATA_COLUMNS,\n      column.name,\n      dataRowAllFilters,\n      dataRowCount\n    );\n  }\n}\n\n//TODO should range be baked into the concept of RowSet ?\nexport class RowSet extends BaseRowSet {\n  // TODO stream as above\n  static fromGroupRowSet({ table, columns, offset, currentFilter: filter }) {\n    return new RowSet(table, columns, offset, {\n      filter\n    });\n  }\n  //TODO consolidate API of rowSet, groupRowset\n  constructor(table, columns, offset = 0, { filter = null } = NO_OPTIONS) {\n    super(table, columns, offset);\n    this.type = DataTypes.ROW_DATA;\n    this.project = projectColumns(table.columnMap, columns, this.meta);\n    this.sortCols = null;\n    this.sortReverse = false;\n    this.sortSet = this.buildSortSet();\n    this.filterSet = null;\n    this.sortRequired = false;\n    if (filter) {\n      this.currentFilter = filter;\n      this.filter(filter);\n    }\n  }\n\n  buildSortSet() {\n    const len = this.data.length;\n    const arr = Array(len);\n    for (let i = 0; i < len; i++) {\n      arr[i] = [i, null, null];\n    }\n    return arr;\n  }\n\n  slice(lo, hi) {\n    const { data, selectedRowsIDX, filterSet, offset, sortCols, sortSet, sortReverse } = this;\n    if (filterSet) {\n      const filterMapper =\n        typeof filterSet[0] === 'number' ? (idx) => data[idx] : ([idx]) => data[idx];\n\n      const results = [];\n      for (let i = lo, len = filterSet.length; i < len && i < hi; i++) {\n        const row = sortReverse ? filterMapper(filterSet[len - i - 1]) : filterMapper(filterSet[i]);\n        results.push(row);\n      }\n      return results.map(this.project(lo, offset, selectedRowsIDX));\n    } else if (sortCols) {\n      const results = [];\n      for (let i = lo, len = data.length; i < len && i < hi; i++) {\n        const idx = sortReverse ? sortSet[len - i - 1][0] : sortSet[i][0];\n        const row = data[idx];\n        results.push(row);\n      }\n      return results.map(this.project(lo, offset, selectedRowsIDX));\n    } else {\n      return this.data.slice(lo, hi).map(this.project(lo, offset, selectedRowsIDX));\n    }\n  }\n\n  // deprecated ?\n  get size() {\n    return this.filterSet === null ? this.data.length : this.filterSet.length;\n  }\n\n  get first() {\n    return this.data[0];\n  }\n  get last() {\n    return this.data[this.data.length - 1];\n  }\n  get rawData() {\n    return this.data;\n  }\n\n  setStatus(status) {\n    this.status = status;\n  }\n\n  addRows(rows) {\n    addRowsToIndex(rows, this.index, this.meta.IDX);\n    this.data = this.data.concat(rows);\n  }\n\n  sort(sortCols) {\n    const sortSet =\n      this.currentFilter === null\n        ? this.sortSet\n        : (this.filterSet = sortableFilterSet(this.filterSet));\n\n    this.sortRequired = this.currentFilter !== null;\n\n    if (sortReversed(this.sortCols, sortCols, SINGLE_COLUMN)) {\n      this.sortReverse = !this.sortReverse;\n    } else if (this.sortCols !== null && groupbyExtendsExistingGroupby(sortCols, this.sortCols)) {\n      this.sortReverse = false;\n      sortExtend(sortSet, this.data, this.sortCols, sortCols, this.columnMap);\n    } else {\n      this.sortReverse = false;\n      sort(sortSet, this.data, sortCols, this.columnMap);\n    }\n\n    this.sortCols = sortCols;\n  }\n\n  clearFilter() {\n    this.currentFilter = null;\n    this.filterSet = null;\n    if (this.sortRequired) {\n      this.sort(this.sortCols);\n    }\n  }\n\n  filter(filter) {\n    const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n    const fn = filter && filterPredicate(this.columnMap, filter);\n    const { data: rows } = this;\n    let [navSet] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet);\n    const newFilterSet = [];\n\n    for (let i = 0; i < navSet.length; i++) {\n      const rowIdx = navSet === this.filterSet ? navSet[i] : navSet[i][0];\n      const row = rows[rowIdx];\n      if (fn(row)) {\n        newFilterSet.push(rowIdx);\n      }\n    }\n\n    // recompute selected.rows from selectedRowIDX\n    if (this.selectedRowsIDX.length) {\n      const { selectedRowsIDX, selected } = this;\n      selected.rows.length = 0;\n      for (let i = 0; i < newFilterSet.length; i++) {\n        const rowIDX = newFilterSet[i];\n        if (selectedRowsIDX.includes(rowIDX)) {\n          selected.rows.push(i);\n        }\n      }\n    }\n\n    this.filterSet = newFilterSet;\n    this.currentFilter = filter;\n    if (!extendsCurrentFilter && this.sortRequired) {\n      // TODO this might be very expensive for large dataset\n      // WHEN DO WE DO THIS - IS THIS CORRECT !!!!!\n      this.sort(this.sortCols);\n    }\n    return newFilterSet.length;\n  }\n\n  update(idx, updates) {\n    if (this.currentFilter === null && this.sortCols === null) {\n      if (idx >= this.range.lo && idx < this.range.hi) {\n        return [idx + this.offset, ...updates];\n      }\n    } else if (this.currentFilter === null) {\n      const { sortSet } = this;\n      for (let i = this.range.lo; i < this.range.hi; i++) {\n        const [rowIdx] = sortSet[i];\n        if (rowIdx === idx) {\n          return [i + this.offset, ...updates];\n        }\n      }\n    } else {\n      // sorted AND/OR filtered\n      const { filterSet } = this;\n      for (let i = this.range.lo; i < this.range.hi; i++) {\n        const rowIdx = Array.isArray(filterSet[i]) ? filterSet[i][0] : filterSet[i];\n        if (rowIdx === idx) {\n          return [i + this.offset, ...updates];\n        }\n      }\n    }\n  }\n\n  insert(idx, row) {\n    // TODO multi colun sort sort DSC\n    if (this.sortCols === null && this.currentFilter === null) {\n      // simplest scenario, row will be at end of sortset ...\n      this.sortSet.push([idx, null, null]);\n      if (idx >= this.range.hi) {\n        // ... row is beyond viewport\n        return {\n          size: this.size\n        };\n      } else {\n        // ... row is within viewport\n        return {\n          size: this.size,\n          replace: true\n        };\n      }\n    } else if (this.currentFilter === null) {\n      // sort only - currently only support single column sorting\n      const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n      const [[colIdx]] = sortCols;\n      const sortRow = [idx, row[colIdx]];\n      const sorter = sortBy([[1, 'asc']]); // the sortSet is always ascending\n      const sortPos = sortPosition(this.sortSet, sorter, sortRow, 'last-available');\n      this.sortSet.splice(sortPos, 0, sortRow);\n\n      // we need to know whether it is an ASC or DSC sort to determine whether row is in viewport\n      const viewportPos = this.sortReverse ? this.size - sortPos : sortPos;\n\n      if (viewportPos >= this.range.hi) {\n        return {\n          size: this.size\n        };\n      } else if (viewportPos >= this.range.lo) {\n        return {\n          size: this.size,\n          replace: true\n        };\n      } else {\n        return {\n          size: this.size,\n          offset: this.offset - 1\n        };\n      }\n    } else if (this.sortCols === null) {\n      // filter only\n      const fn = filterPredicate(this.columnMap, this.currentFilter);\n      if (fn(row)) {\n        const navIdx = this.filterSet.length;\n        this.filterSet.push(idx);\n        if (navIdx >= this.range.hi) {\n          // ... row is beyond viewport\n          return {\n            size: this.size\n          };\n        } else if (navIdx >= this.range.lo) {\n          // ... row is within viewport\n          return {\n            size: this.size,\n            replace: true\n          };\n        } else {\n          return {\n            size: this.size,\n            offset: this.offset - 1\n          };\n        }\n      } else {\n        return {};\n      }\n    } else {\n      // sort AND filter\n      const fn = filterPredicate(this.columnMap, this.currentFilter);\n      if (fn(row)) {\n        // TODO what about totalCOunt\n\n        const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n        const [[colIdx, direction]] = sortCols; // TODO multi-colun sort\n        const sortRow = [idx, row[colIdx]];\n        const sorter = sortBy([[1, direction]]); // TODO DSC\n        const navIdx = sortPosition(this.filterSet, sorter, sortRow, 'last-available');\n        this.filterSet.splice(navIdx, 0, sortRow);\n\n        if (navIdx >= this.range.hi) {\n          // ... row is beyond viewport\n          return {\n            size: this.size\n          };\n        } else if (navIdx >= this.range.lo) {\n          // ... row is within viewport\n          return {\n            size: this.size,\n            replace: true\n          };\n        } else {\n          return {\n            size: this.size,\n            offset: this.offset - 1\n          };\n        }\n      } else {\n        return {};\n      }\n    }\n  }\n}\n\n// TODO need to retain and return any searchText\nexport class SetFilterRowSet extends RowSet {\n  constructor(table, columns, columnName, dataRowAllFilters, dataRowTotal) {\n    super(table, columns);\n    this.type = DataTypes.FILTER_DATA;\n    this.columnName = columnName;\n    this._searchText = null;\n    this.dataRowFilter = null;\n    this.dataCounts = {\n      dataRowTotal,\n      dataRowAllFilters,\n      dataRowCurrentFilter: 0,\n      filterRowTotal: this.data.length,\n      filterRowSelected: this.data.length,\n      filterRowHidden: 0\n    };\n    this.sort([['name', 'asc']]);\n  }\n\n  createSelectionModel() {\n    return new SelectionModel(SelectionModelType.Checkbox);\n  }\n\n  clearRange() {\n    this.range = { lo: 0, hi: 0 };\n  }\n\n  get values() {\n    const key = this.columnMap['name'];\n    return this.filterSet.map((idx) => this.data[idx][key]);\n  }\n\n  // will we ever need this on base rowset ?\n  getSelectedValue(idx) {\n    const { data, sortSet, filterSet } = this;\n    if (filterSet) {\n      const filterEntry = filterSet[idx];\n      const rowIDX = typeof filterEntry === 'number' ? filterEntry : filterEntry[0];\n      return data[rowIDX][0];\n    } else {\n      return sortSet[idx][1];\n    }\n  }\n\n  setSelectedFromFilter(dataRowFilter) {\n    const columnFilter = extractFilterForColumn(dataRowFilter, this.columnName);\n    const columnMap = this.table.columnMap;\n    const { data, filterSet, sortSet } = this;\n\n    this.dataRowFilter = dataRowFilter;\n\n    if (columnFilter) {\n      const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'name'), true);\n      const selectedRows = [];\n      const selectedRowsIDX = [];\n\n      if (filterSet) {\n        for (let i = 0; i < filterSet.length; i++) {\n          const rowIDX = filterSet[i];\n          if (fn(data[rowIDX])) {\n            selectedRows.push(i);\n            selectedRowsIDX.push(rowIDX);\n          }\n        }\n      } else {\n        for (let i = 0; i < data.length; i++) {\n          const rowIDX = sortSet[i][0];\n          if (fn(data[rowIDX])) {\n            selectedRows.push(i);\n            selectedRowsIDX.push(rowIDX);\n          }\n        }\n      }\n\n      this.selected = { rows: selectedRows, focusedIdx: -1, lastTouchIdx: -1 };\n      this.selectedRowsIDX = selectedRowsIDX;\n    } else {\n      this.selectAll();\n    }\n\n    return this.currentRange();\n  }\n}\n\nexport class BinFilterRowSet extends RowSet {\n  constructor(table, columns, columnName) {\n    super(table, columns);\n    this.type = DataTypes.FILTER_BINS;\n    this.columnName = columnName;\n  }\n\n  setSelectedFromFilter(filter) {\n    console.log(`need to apply filter to selected BinRowset`, filter);\n  }\n  // we don't currently have a concept of range here, but it will\n  // be used in the future\n  // Note: currently no projection here, we don't currently need metadata\n  setRange() {\n    return {\n      type: this.type,\n      rows: this.data,\n      range: null,\n      size: this.size,\n      offset: 0\n    };\n  }\n}\n"],
  "mappings": "AAGA,YAAY,QAAQ;AACpB,SAAS,iBAAiB,UAAU,sBAAsB;AAC1D;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,qCAAqC;AAC9C,SAAS,eAAe,cAAc,kBAAkB;AACxD,SAAS,gBAAgB,sBAAsB;AAC/C,OAAO,kBAAkB,0BAA0B;AACnD;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,OAAO,WAAW;AAClB,SAAS,iBAAiB;AAE1B,MAAM,gBAAgB;AAEtB,MAAM,aAAa;AAAA,EACjB,QAAQ;AACV;AAEA,MAAO,WAAyB;AAAA,EAC9B,YAAY,OAAO,SAAS,SAAS,GAAG;AACtC,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,gBAAgB;AACrB,SAAK,YAAY;AACjB,SAAK,YAAY,MAAM;AACvB,SAAK,OAAO,SAAS,OAAO;AAC5B,SAAK,OAAO,MAAM;AAClB,SAAK,WAAW,EAAE,MAAM,CAAC,GAAG,YAAY,IAAI,cAAc,GAAG;AAI7D,SAAK,kBAAkB,CAAC;AACxB,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,uBAAuB;AACrB,WAAO,IAAI,eAAe;AAAA,EAC5B;AAAA,EAGA,IAAI,eAAe;AACjB,QAAI,KAAK,WAAW;AAClB,aAAO,KAAK;AAAA,IACd,OAAO;AACL,YAAM,EAAE,IAAI,IAAI,KAAK;AACrB,aAAO,KAAK,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI;AAAA,IACxC;AAAA,EACF;AAAA,EAEA,IAAI,QAAQ;AAEV,UAAM,EAAE,eAAe,kBAAkB,UAAU,gBAAgB,IAAI;AACvE,UAAM,gBAAgB,gBAAgB;AACtC,UAAM,mBAAmB,SAAS,KAAK;AAEvC,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,gBAAgB;AAClB,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EAEA,IAAI,mBAAmB;AACrB,WAAO,KAAK,cAAc,OAAO,KAAK,KAAK,SAAS,KAAK,UAAU;AAAA,EACrE;AAAA,EAEA,IAAI,mBAAmB;AACrB,WAAO,KAAK,SAAS,KAAK;AAAA,EAC5B;AAAA,EAEA,SAAS,QAAQ,KAAK,OAAO,WAAW,MAAM,eAAe,OAAO;AAClE,UAAM,EAAE,IAAI,GAAG,IAAI,WAAW,cAAc,KAAK,OAAO,KAAK,IAAI,aAAa,KAAK;AACnF,UAAM,YAAY,KAAK,MAAM,IAAI,EAAE;AACnC,SAAK,QAAQ;AACb,WAAO;AAAA,MACL,UAAU,KAAK;AAAA,MACf,MAAM;AAAA,MACN;AAAA,MACA,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,MACb,OAAO,eAAe,KAAK,QAAQ;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,eAAe;AACb,UAAM,EAAE,IAAI,GAAG,IAAI,KAAK;AACxB,UAAM,YAAY,KAAK,MAAM,IAAI,EAAE;AACnC,WAAO;AAAA,MACL,UAAU,KAAK;AAAA,MACf,MAAM;AAAA,MACN,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,IACf;AAAA,EACF;AAAA,EAEA,OAAO,KAAK,aAAa,uBAAuB;AAC9C,UAAM;AAAA,MACJ,MAAM,EAAE,SAAS;AAAA,MACjB;AAAA,MACA,OAAO,EAAE,IAAI,GAAG;AAAA,MAChB;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,UAAM,EAAE,UAAU,eAAe,eAAe,IAAI,eAAe;AAAA,MACjE,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,SAAK,WAAW;AAEhB,QAAI,WAAW;AACb,UAAI,SAAS,QAAQ;AACnB,aAAK,gBAAgB,KAAK,GAAG,SAAS,IAAI,CAAC,MAAM,UAAU,EAAE,CAAC;AAAA,MAChE;AACA,UAAI,WAAW,QAAQ;AACrB,cAAM,mBAAmB,WAAW,IAAI,CAAC,MAAM,UAAU,EAAE;AAC3D,aAAK,kBAAkB,KAAK,gBAAgB;AAAA,UAC1C,CAAC,WAAW,CAAC,iBAAiB,SAAS,MAAM;AAAA,QAC/C;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,WAAW,CAACA,SAAQ,QAAQA,MAAK;AACvC,WAAK,kBAAkB,KAAK,SAAS,KAAK,IAAI,QAAQ;AAAA,IACxD;AAEA,UAAM,UAAU,CAAC;AACjB,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAMA,OAAM,SAAS;AACrB,UAAIA,QAAO,MAAMA,OAAM,IAAI;AACzB,gBAAQ,KAAK,CAACA,OAAM,QAAQ,UAAU,CAAC,CAAC;AAAA,MAC1C;AAAA,IACF;AACA,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAMA,OAAM,WAAW;AACvB,UAAIA,QAAO,MAAMA,OAAM,IAAI;AACzB,gBAAQ,KAAK,CAACA,OAAM,QAAQ,UAAU,CAAC,CAAC;AAAA,MAC1C;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,YAAY;AACV,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,EAAE,SAAS;AAAA,MACjB,OAAO,EAAE,IAAI,GAAG;AAAA,MAChB;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,yBAAyB,CAAC,GAAG,KAAK,SAAS,IAAI;AACrD,QAAI,WAAW;AAEb,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,cAAM,SAAS,UAAU;AACzB,YAAI,CAAC,gBAAgB,SAAS,MAAM,GAAG;AACrC,mBAAS,KAAK,KAAK,CAAC;AACpB,0BAAgB,KAAK,MAAM;AAAA,QAC7B;AAAA,MACF;AAAA,IACF,OAAO;AAGL,WAAK,WAAW,EAAE,MAAM,eAAe,KAAK,MAAM,GAAG,YAAY,IAAI,cAAc,GAAG;AACtF,WAAK,kBAAkB,CAAC,GAAG,KAAK,SAAS,IAAI;AAAA,IAC/C;AAEA,UAAM,UAAU,CAAC;AACjB,UAAM,MAAM,KAAK,IAAI,KAAK,aAAa,MAAM,MAAM;AACnD,aAAS,IAAI,IAAI,IAAI,KAAK,KAAK;AAC7B,UAAI,KAAK,SAAS,KAAK,SAAS,CAAC,KAAK,CAAC,uBAAuB,SAAS,CAAC,GAAG;AACzE,gBAAQ,KAAK,CAAC,IAAI,QAAQ,UAAU,CAAC,CAAC;AAAA,MACxC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAa;AACX,UAAM;AAAA,MACJ,MAAM,EAAE,SAAS;AAAA,MACjB,OAAO,EAAE,IAAI,GAAG;AAAA,MAChB;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,yBAAyB,KAAK;AACpC,QAAI,WAAW;AACb,WAAK,WAAW,EAAE,MAAM,CAAC,GAAG,YAAY,IAAI,cAAc,GAAG;AAC7D,WAAK,kBAAkB,KAAK,gBAAgB,OAAO,CAAC,QAAQ,CAAC,UAAU,SAAS,GAAG,CAAC;AAAA,IACtF,OAAO;AACL,WAAK,WAAW,EAAE,MAAM,CAAC,GAAG,YAAY,IAAI,cAAc,GAAG;AAC7D,WAAK,kBAAkB,CAAC;AAAA,IAC1B;AACA,UAAM,UAAU,CAAC;AACjB,aAAS,IAAI,IAAI,IAAI,IAAI,KAAK;AAC5B,YAAM,MAAM,YAAY,UAAU,KAAK;AACvC,UAAI,uBAAuB,SAAS,GAAG,GAAG;AACxC,gBAAQ,KAAK,CAAC,IAAI,QAAQ,UAAU,CAAC,CAAC;AAAA,MACxC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB,WAAW;AAC7B,UAAM,EAAE,OAAO,aAAa,cAAc,gBAAgB,IAAI,KAAK;AACnE,WAAO,YACH,CAAC,KAAK,WAAW,iBAAiB,YAAY,IAC9C,CAAC,KAAK,SAAS,aAAa,KAAK;AAAA,EACvC;AAAA,EAGA,yBAAyB,QAAQ;AAC/B,UAAM,MAAM,KAAK,UAAU,OAAO;AAClC,UAAM,EAAE,MAAM,MAAM,aAAa,IAAI;AACrC,UAAM,UAAU,aAAa,IAAI,CAAC,WAAW,KAAK,QAAQ,IAAI;AAC9D,UAAM,OAAO,GACV,UAAU,EACV,WAAW,EAAE,EAAE,OAAO,EACtB,IAAI,CAAC,KAAK,MAAM,CAAC,IAAI,GAAG,IAAI,QAAQ,IAAI,IAAI,IAAI,EAAE,CAAC;AAEtD,UAAM,QAAQ,IAAI,MAAM,EAAE,MAAM,YAAY,OAAO,SAAS,wBAAwB,CAAC;AACrF,UAAM,eAAe,IAAI,gBAAgB,OAAO,yBAAyB,OAAO,IAAI;AACpF,WAAO;AAAA,EACT;AAAA,EAEA,2BAA2B,QAAQ;AACjC,UAAM,EAAE,MAAM,MAAM,WAAW,cAAc,IAAI;AACjD,UAAM,SAAS,UAAU,OAAO;AAChC,UAAM,YAAY,CAAC;AACnB,UAAM,OAAO,CAAC;AACd,UAAM,eAAe,KAAK;AAC1B,UAAM,CAAC,EAAmB,YAAY,IAAI,oBAAoB,eAAe,MAAM;AAEnF,QAAI,oBAAoB;AAExB,QAAI,iBAAiB,MAAM;AACzB,UAAI;AACJ,eAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,cAAM,MAAM,KAAK,GAAG;AACpB,YAAK,SAAS,UAAU,MAAO;AAC7B,iBAAO,KAAK,EAAE,OAAO;AAAA,QACvB,OAAO;AACL,mBAAS,CAAC,KAAK,GAAG,CAAC;AACnB,oBAAU,OAAO;AACjB,eAAK,KAAK,MAAM;AAAA,QAClB;AAAA,MACF;AACA,0BAAoB;AAAA,IACtB,OAAO;AACL,YAAM,KAAK,gBAAgB,WAAW,YAAY;AAClD,UAAI;AAEJ,eAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,cAAM,MAAM,KAAK;AACjB,cAAM,MAAM,IAAI;AAChB,cAAM,aAAa,GAAG,GAAG,IAAI,IAAI;AACjC,YAAK,SAAS,UAAU,MAAO;AAC7B,iBAAO,MAAM;AACb,iBAAO;AAAA,QACT,OAAO;AACL,mBAAS,CAAC,KAAK,YAAY,CAAC;AAC5B,oBAAU,OAAO;AACjB,eAAK,KAAK,MAAM;AAAA,QAClB;AACA,6BAAqB;AAAA,MACvB;AAAA,IACF;AAGA,UAAM,QAAQ,IAAI,MAAM,EAAE,MAAM,YAAY,QAAQ,SAAS,wBAAwB,CAAC;AACtF,WAAO,IAAI;AAAA,MACT;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAGO,MAAM,eAAe,WAAW;AAAA,EAErC,OAAO,gBAAgB,EAAE,OAAO,SAAS,QAAQ,eAAe,OAAO,GAAG;AACxE,WAAO,IAAI,OAAO,OAAO,SAAS,QAAQ;AAAA,MACxC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,YAAY,OAAO,SAAS,SAAS,GAAG,EAAE,SAAS,KAAK,IAAI,YAAY;AACtE,UAAM,OAAO,SAAS,MAAM;AAC5B,SAAK,OAAO,UAAU;AACtB,SAAK,UAAU,eAAe,MAAM,WAAW,SAAS,KAAK,IAAI;AACjE,SAAK,WAAW;AAChB,SAAK,cAAc;AACnB,SAAK,UAAU,KAAK,aAAa;AACjC,SAAK,YAAY;AACjB,SAAK,eAAe;AACpB,QAAI,QAAQ;AACV,WAAK,gBAAgB;AACrB,WAAK,OAAO,MAAM;AAAA,IACpB;AAAA,EACF;AAAA,EAEA,eAAe;AACb,UAAM,MAAM,KAAK,KAAK;AACtB,UAAM,MAAM,MAAM,GAAG;AACrB,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,UAAI,KAAK,CAAC,GAAG,MAAM,IAAI;AAAA,IACzB;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,IAAI,IAAI;AACZ,UAAM,EAAE,MAAM,iBAAiB,WAAW,QAAQ,UAAU,SAAS,YAAY,IAAI;AACrF,QAAI,WAAW;AACb,YAAM,eACJ,OAAO,UAAU,OAAO,WAAW,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC,GAAG,MAAM,KAAK;AAE1E,YAAM,UAAU,CAAC;AACjB,eAAS,IAAI,IAAI,MAAM,UAAU,QAAQ,IAAI,OAAO,IAAI,IAAI,KAAK;AAC/D,cAAM,MAAM,cAAc,aAAa,UAAU,MAAM,IAAI,EAAE,IAAI,aAAa,UAAU,EAAE;AAC1F,gBAAQ,KAAK,GAAG;AAAA,MAClB;AACA,aAAO,QAAQ,IAAI,KAAK,QAAQ,IAAI,QAAQ,eAAe,CAAC;AAAA,IAC9D,WAAW,UAAU;AACnB,YAAM,UAAU,CAAC;AACjB,eAAS,IAAI,IAAI,MAAM,KAAK,QAAQ,IAAI,OAAO,IAAI,IAAI,KAAK;AAC1D,cAAM,MAAM,cAAc,QAAQ,MAAM,IAAI,GAAG,KAAK,QAAQ,GAAG;AAC/D,cAAM,MAAM,KAAK;AACjB,gBAAQ,KAAK,GAAG;AAAA,MAClB;AACA,aAAO,QAAQ,IAAI,KAAK,QAAQ,IAAI,QAAQ,eAAe,CAAC;AAAA,IAC9D,OAAO;AACL,aAAO,KAAK,KAAK,MAAM,IAAI,EAAE,EAAE,IAAI,KAAK,QAAQ,IAAI,QAAQ,eAAe,CAAC;AAAA,IAC9E;AAAA,EACF;AAAA,EAGA,IAAI,OAAO;AACT,WAAO,KAAK,cAAc,OAAO,KAAK,KAAK,SAAS,KAAK,UAAU;AAAA,EACrE;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EACA,IAAI,OAAO;AACT,WAAO,KAAK,KAAK,KAAK,KAAK,SAAS;AAAA,EACtC;AAAA,EACA,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,UAAU,QAAQ;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,QAAQ,MAAM;AACZ,mBAAe,MAAM,KAAK,OAAO,KAAK,KAAK,GAAG;AAC9C,SAAK,OAAO,KAAK,KAAK,OAAO,IAAI;AAAA,EACnC;AAAA,EAEA,KAAK,UAAU;AACb,UAAM,UACJ,KAAK,kBAAkB,OACnB,KAAK,UACJ,KAAK,YAAY,kBAAkB,KAAK,SAAS;AAExD,SAAK,eAAe,KAAK,kBAAkB;AAE3C,QAAI,aAAa,KAAK,UAAU,UAAU,aAAa,GAAG;AACxD,WAAK,cAAc,CAAC,KAAK;AAAA,IAC3B,WAAW,KAAK,aAAa,QAAQ,8BAA8B,UAAU,KAAK,QAAQ,GAAG;AAC3F,WAAK,cAAc;AACnB,iBAAW,SAAS,KAAK,MAAM,KAAK,UAAU,UAAU,KAAK,SAAS;AAAA,IACxE,OAAO;AACL,WAAK,cAAc;AACnB,WAAK,SAAS,KAAK,MAAM,UAAU,KAAK,SAAS;AAAA,IACnD;AAEA,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,cAAc;AACZ,SAAK,gBAAgB;AACrB,SAAK,YAAY;AACjB,QAAI,KAAK,cAAc;AACrB,WAAK,KAAK,KAAK,QAAQ;AAAA,IACzB;AAAA,EACF;AAAA,EAEA,OAAO,QAAQ;AACb,UAAM,uBAAuB,cAAc,KAAK,eAAe,MAAM;AACrE,UAAM,KAAK,UAAU,gBAAgB,KAAK,WAAW,MAAM;AAC3D,UAAM,EAAE,MAAM,KAAK,IAAI;AACvB,QAAI,CAAC,MAAM,IAAI,KAAK,oBAAoB,wBAAwB,KAAK,SAAS;AAC9E,UAAM,eAAe,CAAC;AAEtB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,SAAS,WAAW,KAAK,YAAY,OAAO,KAAK,OAAO,GAAG;AACjE,YAAM,MAAM,KAAK;AACjB,UAAI,GAAG,GAAG,GAAG;AACX,qBAAa,KAAK,MAAM;AAAA,MAC1B;AAAA,IACF;AAGA,QAAI,KAAK,gBAAgB,QAAQ;AAC/B,YAAM,EAAE,iBAAiB,SAAS,IAAI;AACtC,eAAS,KAAK,SAAS;AACvB,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAM,SAAS,aAAa;AAC5B,YAAI,gBAAgB,SAAS,MAAM,GAAG;AACpC,mBAAS,KAAK,KAAK,CAAC;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAEA,SAAK,YAAY;AACjB,SAAK,gBAAgB;AACrB,QAAI,CAAC,wBAAwB,KAAK,cAAc;AAG9C,WAAK,KAAK,KAAK,QAAQ;AAAA,IACzB;AACA,WAAO,aAAa;AAAA,EACtB;AAAA,EAEA,OAAO,KAAK,SAAS;AACnB,QAAI,KAAK,kBAAkB,QAAQ,KAAK,aAAa,MAAM;AACzD,UAAI,OAAO,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,IAAI;AAC/C,eAAO,CAAC,MAAM,KAAK,QAAQ,GAAG,OAAO;AAAA,MACvC;AAAA,IACF,WAAW,KAAK,kBAAkB,MAAM;AACtC,YAAM,EAAE,QAAQ,IAAI;AACpB,eAAS,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,KAAK;AAClD,cAAM,CAAC,MAAM,IAAI,QAAQ;AACzB,YAAI,WAAW,KAAK;AAClB,iBAAO,CAAC,IAAI,KAAK,QAAQ,GAAG,OAAO;AAAA,QACrC;AAAA,MACF;AAAA,IACF,OAAO;AAEL,YAAM,EAAE,UAAU,IAAI;AACtB,eAAS,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,KAAK;AAClD,cAAM,SAAS,MAAM,QAAQ,UAAU,EAAE,IAAI,UAAU,GAAG,KAAK,UAAU;AACzE,YAAI,WAAW,KAAK;AAClB,iBAAO,CAAC,IAAI,KAAK,QAAQ,GAAG,OAAO;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,KAAK,KAAK;AAEf,QAAI,KAAK,aAAa,QAAQ,KAAK,kBAAkB,MAAM;AAEzD,WAAK,QAAQ,KAAK,CAAC,KAAK,MAAM,IAAI,CAAC;AACnC,UAAI,OAAO,KAAK,MAAM,IAAI;AAExB,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,QACb;AAAA,MACF,OAAO;AAEL,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF,WAAW,KAAK,kBAAkB,MAAM;AAEtC,YAAM,WAAW,gBAAgB,KAAK,UAAU,KAAK,SAAS;AAC9D,YAAM,CAAC,CAAC,MAAM,CAAC,IAAI;AACnB,YAAM,UAAU,CAAC,KAAK,IAAI,OAAO;AACjC,YAAM,SAAS,OAAO,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;AAClC,YAAM,UAAU,aAAa,KAAK,SAAS,QAAQ,SAAS,gBAAgB;AAC5E,WAAK,QAAQ,OAAO,SAAS,GAAG,OAAO;AAGvC,YAAM,cAAc,KAAK,cAAc,KAAK,OAAO,UAAU;AAE7D,UAAI,eAAe,KAAK,MAAM,IAAI;AAChC,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,QACb;AAAA,MACF,WAAW,eAAe,KAAK,MAAM,IAAI;AACvC,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,QACX;AAAA,MACF,OAAO;AACL,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,UACX,QAAQ,KAAK,SAAS;AAAA,QACxB;AAAA,MACF;AAAA,IACF,WAAW,KAAK,aAAa,MAAM;AAEjC,YAAM,KAAK,gBAAgB,KAAK,WAAW,KAAK,aAAa;AAC7D,UAAI,GAAG,GAAG,GAAG;AACX,cAAM,SAAS,KAAK,UAAU;AAC9B,aAAK,UAAU,KAAK,GAAG;AACvB,YAAI,UAAU,KAAK,MAAM,IAAI;AAE3B,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,UACb;AAAA,QACF,WAAW,UAAU,KAAK,MAAM,IAAI;AAElC,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,YACX,SAAS;AAAA,UACX;AAAA,QACF,OAAO;AACL,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,YACX,QAAQ,KAAK,SAAS;AAAA,UACxB;AAAA,QACF;AAAA,MACF,OAAO;AACL,eAAO,CAAC;AAAA,MACV;AAAA,IACF,OAAO;AAEL,YAAM,KAAK,gBAAgB,KAAK,WAAW,KAAK,aAAa;AAC7D,UAAI,GAAG,GAAG,GAAG;AAGX,cAAM,WAAW,gBAAgB,KAAK,UAAU,KAAK,SAAS;AAC9D,cAAM,CAAC,CAAC,QAAQ,SAAS,CAAC,IAAI;AAC9B,cAAM,UAAU,CAAC,KAAK,IAAI,OAAO;AACjC,cAAM,SAAS,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC;AACtC,cAAM,SAAS,aAAa,KAAK,WAAW,QAAQ,SAAS,gBAAgB;AAC7E,aAAK,UAAU,OAAO,QAAQ,GAAG,OAAO;AAExC,YAAI,UAAU,KAAK,MAAM,IAAI;AAE3B,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,UACb;AAAA,QACF,WAAW,UAAU,KAAK,MAAM,IAAI;AAElC,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,YACX,SAAS;AAAA,UACX;AAAA,QACF,OAAO;AACL,iBAAO;AAAA,YACL,MAAM,KAAK;AAAA,YACX,QAAQ,KAAK,SAAS;AAAA,UACxB;AAAA,QACF;AAAA,MACF,OAAO;AACL,eAAO,CAAC;AAAA,MACV;AAAA,IACF;AAAA,EACF;AACF;AAGO,MAAM,wBAAwB,OAAO;AAAA,EAC1C,YAAY,OAAO,SAAS,YAAY,mBAAmB,cAAc;AACvE,UAAM,OAAO,OAAO;AACpB,SAAK,OAAO,UAAU;AACtB,SAAK,aAAa;AAClB,SAAK,cAAc;AACnB,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAAA,MAChB;AAAA,MACA;AAAA,MACA,sBAAsB;AAAA,MACtB,gBAAgB,KAAK,KAAK;AAAA,MAC1B,mBAAmB,KAAK,KAAK;AAAA,MAC7B,iBAAiB;AAAA,IACnB;AACA,SAAK,KAAK,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC;AAAA,EAC7B;AAAA,EAEA,uBAAuB;AACrB,WAAO,IAAI,eAAe,mBAAmB,QAAQ;AAAA,EACvD;AAAA,EAEA,aAAa;AACX,SAAK,QAAQ,EAAE,IAAI,GAAG,IAAI,EAAE;AAAA,EAC9B;AAAA,EAEA,IAAI,SAAS;AACX,UAAM,MAAM,KAAK,UAAU;AAC3B,WAAO,KAAK,UAAU,IAAI,CAAC,QAAQ,KAAK,KAAK,KAAK,IAAI;AAAA,EACxD;AAAA,EAGA,iBAAiB,KAAK;AACpB,UAAM,EAAE,MAAM,SAAS,UAAU,IAAI;AACrC,QAAI,WAAW;AACb,YAAM,cAAc,UAAU;AAC9B,YAAM,SAAS,OAAO,gBAAgB,WAAW,cAAc,YAAY;AAC3E,aAAO,KAAK,QAAQ;AAAA,IACtB,OAAO;AACL,aAAO,QAAQ,KAAK;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,sBAAsB,eAAe;AACnC,UAAM,eAAe,uBAAuB,eAAe,KAAK,UAAU;AAC1E,UAAM,YAAY,KAAK,MAAM;AAC7B,UAAM,EAAE,MAAM,WAAW,QAAQ,IAAI;AAErC,SAAK,gBAAgB;AAErB,QAAI,cAAc;AAChB,YAAM,KAAK,gBAAgB,WAAW,gBAAgB,cAAc,MAAM,GAAG,IAAI;AACjF,YAAM,eAAe,CAAC;AACtB,YAAM,kBAAkB,CAAC;AAEzB,UAAI,WAAW;AACb,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,gBAAM,SAAS,UAAU;AACzB,cAAI,GAAG,KAAK,OAAO,GAAG;AACpB,yBAAa,KAAK,CAAC;AACnB,4BAAgB,KAAK,MAAM;AAAA,UAC7B;AAAA,QACF;AAAA,MACF,OAAO;AACL,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,gBAAM,SAAS,QAAQ,GAAG;AAC1B,cAAI,GAAG,KAAK,OAAO,GAAG;AACpB,yBAAa,KAAK,CAAC;AACnB,4BAAgB,KAAK,MAAM;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAEA,WAAK,WAAW,EAAE,MAAM,cAAc,YAAY,IAAI,cAAc,GAAG;AACvE,WAAK,kBAAkB;AAAA,IACzB,OAAO;AACL,WAAK,UAAU;AAAA,IACjB;AAEA,WAAO,KAAK,aAAa;AAAA,EAC3B;AACF;AAEO,MAAM,wBAAwB,OAAO;AAAA,EAC1C,YAAY,OAAO,SAAS,YAAY;AACtC,UAAM,OAAO,OAAO;AACpB,SAAK,OAAO,UAAU;AACtB,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,sBAAsB,QAAQ;AAC5B,YAAQ,IAAI,8CAA8C,MAAM;AAAA,EAClE;AAAA,EAIA,WAAW;AACT,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,OAAO;AAAA,MACP,MAAM,KAAK;AAAA,MACX,QAAQ;AAAA,IACV;AAAA,EACF;AACF;",
  "names": ["idx"]
}
