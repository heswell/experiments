{
  "version": 3,
  "sources": ["../../src/store/filter.ts"],
  "sourcesContent": ["import * as d3 from 'd3-array';\n\nexport const EQUALS = 'EQ';\nexport const GREATER_THAN = 'GT';\nexport const GREATER_EQ = 'GE';\nexport const LESS_THAN = 'LT';\nexport const LESS_EQ = 'LE';\nexport const AND = 'AND';\nexport const OR = 'OR';\nexport const STARTS_WITH = 'SW';\nexport const NOT_STARTS_WITH = 'NOT_SW';\nexport const IN = 'IN';\nexport const NOT_IN = 'NOT_IN';\n\nexport const SET_FILTER_DATA_COLUMNS = [\n    {name: 'name', key:0}, \n    {name: 'count', key:1, width: 40, type: 'number'}, \n    {name: 'totalCount', key:2, width: 40, type: 'number'}\n];\n\nexport const BIN_FILTER_DATA_COLUMNS = [\n    {name: 'bin'}, \n    {name: 'count'}, \n    {name: 'bin-lo'},\n    {name: 'bin-hi'}\n];\nexport default function filterRows(rows, columnMap, filter) {\n    return applyFilter(rows, functor(columnMap, filter));\n}\n\n\nexport function getFilterColumn(column) {\n    return column.isGroup ? column.columns[0] : column;\n}\nexport function functor(columnMap, filter) {\n    //TODO convert filter to include colIdx ratherthan colName, so we don't have to pass cols\n    switch (filter.type) {\n    case IN: return testInclude(columnMap, filter);\n    case NOT_IN: return testExclude(columnMap, filter);\n    case EQUALS: return testEQ(columnMap, filter);\n    case GREATER_THAN: return testGT(columnMap, filter);\n    case GREATER_EQ: return testGE(columnMap, filter);\n    case LESS_THAN: return testLT(columnMap, filter);\n    case LESS_EQ: return testLE(columnMap, filter);\n    case STARTS_WITH: return testSW(columnMap, filter);\n    case NOT_STARTS_WITH: return testSW(columnMap, filter, true);\n    case AND: return testAND(columnMap, filter);\n    case OR: return testOR(columnMap, filter);\n    default:\n        console.log(`unrecognized filter type ${filter.type}`);\n        return () => true;\n    }\n}\n\nfunction applyFilter(rows, filter) {\n    const results = [];\n    for (let i = 0; i < rows.length; i++) {\n        if (filter(rows[i])) {\n            results.push(rows[i]);\n        }\n    }\n    return results;\n}\n\nfunction testAND(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.every(fn => fn(row));\n}\n\nfunction testOR(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.some(fn => fn(row));\n}\n\nfunction testSW(cols, f, inversed = false) {\n    const value = f.value.toLowerCase();\n    return inversed\n        ? row => row[cols[f.colName]].toLowerCase().indexOf(value) !== 0\n        : row => row[cols[f.colName]].toLowerCase().indexOf(value) === 0;\n   \n}\n\nfunction testGT(cols, f) {\n    return row => row[cols[f.colName]] > f.value;\n}\n\nfunction testGE(cols, f) {\n    return row => row[cols[f.colName]] >= f.value;\n}\n\nfunction testLT(cols, f) {\n    return row => row[cols[f.colName]] < f.value;\n}\n\nfunction testLE(cols, f) {\n    return row => row[cols[f.colName]] <= f.value;\n}\n\nfunction testInclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) !== -1;\n}\n\n// faster to convert values to a keyed map\nfunction testExclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) === -1;\n}\n\nfunction testEQ(cols, f) {\n    return row => row[cols[f.colName]] === f.value;\n}\n\nexport function shouldShowFilter(filterColumnName, column) {\n    const filterColumn = getFilterColumn(column);\n    if (filterColumn.isGroup) {\n        return filterColumn.columns.some(col => col.name === filterColumnName);\n    } else {\n        return filterColumnName === filterColumn.name;\n    }\n}\n\nexport function includesNoValues(filter) {\n    // TODO make sure we catch all cases...\n    if (!filter){\n        return false;\n    } else if (filter.type === IN && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === AND && filter.filters.some(f => includesNoValues(f))){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction includesAllValues(filter) {\n    if (!filter){\n        return false;\n    } else if (filter.type === NOT_IN && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === STARTS_WITH && filter.value === ''){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// does f2 only narrow the resultset from f1\nexport function extendsFilter(f1=null, f2=null) {\n    // ignore filters which are identical\n    // include or exclude filters which add values\n    if (f2 === null){\n        return false\n    } else if (f1 === null) {\n        return true;\n    }\n    if (f1.colName && f1.colName === f2.colName) {\n        if (f1.type === f2.type) {\n            switch (f1.type) {\n            case IN:\n                return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n            case NOT_IN: \n                return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n            case STARTS_WITH: return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n                // more cases here such as GT,LT\n            default:\n            }\n        }\n\n    } else if (f1.colname && f2.colName) {\n        // different columns,always false\n        return false;\n    } else if (f2.type === AND && extendsFilters(f1, f2)) {\n        return true;\n    }\n\n    // safe option is to assume false, causing filter to be re-applied to base data\n    return false;\n}\n\nconst byColName = (a, b) => a.colName === b.colName ? 0 : a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1, f2) {\n    if (f1.colName) {\n        const matchingFilter = f2.filters.find(f => f.colName === f1.colName);\n        return filterEquals(matchingFilter, f1, true);\n    } else if (f1.filters.length === f2.filters.length) {\n        // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n        // then we are still extending the filter (i.e. narrowing the resultset)\n        const a = f1.filters.sort(byColName);\n        const b = f2.filters.slice().sort(byColName);\n\n        for (let i = 0; i < a.length; i++) {\n            if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (f2.filters.length > f1.filters.length){\n        return f1.filters.every(filter1 => {\n            const filter2 = f2.filters.find(f => f.colName === filter1.colName);\n            return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n        });\n    }\n}\n\nexport function addFilter(existingFilter, filter) {\n\n    if (includesNoValues(filter)){\n        const {colName} = filter;\n        existingFilter = removeFilterForColumn(existingFilter, {name:colName});\n    } else if (includesAllValues(filter)){\n        // A filter that returns all values is a way to remove filtering for this column \n        return removeFilterForColumn(existingFilter, {name: filter.colName});\n    }\n\n    if (!existingFilter) {\n        return filter;\n    } else if (!filter) {\n        return existingFilter;\n    }\n   \n    if (existingFilter.type === AND && filter.type === AND) {\n        return { type: 'AND', filters: combine(existingFilter.filters, filter.filters) };\n    } else if (existingFilter.type === 'AND') {\n        const filters = replaceOrInsert(existingFilter.filters, filter);\n        return filters.length > 1\n            ? { type: 'AND', filters  }\n            : filters[0];\n    } else if (filter.type === 'AND') {\n        return { type: 'AND', filters: filter.filters.concat(existingFilter) };\n    } else if (filterEquals(existingFilter, filter, true)) {\n        return filter;\n    } else if (sameColumn(existingFilter, filter)){\n        return merge(existingFilter, filter);\n    } else {\n        return { type: 'AND', filters: [existingFilter, filter] };\n    }\n}\n\n// If we add an IN filter and there is an existing NOT_IN, we would always expect the IN\n// values to exist in the NOT_IN set (as long as user interaction is driving the filtering)\nfunction replaceOrInsert(filters, filter) {\n    const {type, colName, values} = filter;\n    if (type === IN || type === NOT_IN) {\n        const otherType = type === IN ? NOT_IN : IN; \n        // see if we have an 'other' entry\n        let idx = filters.findIndex(f => f.type === otherType && f.colName === colName);\n        if (idx !== -1){\n            const {values: existingValues} = filters[idx];\n            if (values.every(value => existingValues.indexOf(value) !== -1)){\n                if (values.length === existingValues.length){\n                    // we simply remove the existing 'other' filter ...\n                    return filters.filter((f, i) => i !== idx);\n                } else {\n                    // ... or strip the matching values from the 'other' filter values\n                    let newValues = existingValues.filter(value => !values.includes(value));\n                    return filters.map((filter,i) => i === idx ? {...filter, values: newValues}: filter)\n\n                }\n            }\n            else if (values.some(value => existingValues.indexOf(value) !== -1)){\n                console.log(`partial overlap between IN and NOT_IN`)\n\n            }\n        } else {\n            idx = filters.findIndex(f => f.type === type && f.colName === filter.colName);\n            if (idx !== -1) {\n                return filters.map((f, i) => i === idx ? merge(f, filter) : f);\n            }    \n        }\n    }\n\n    return filters.concat(filter);\n}\n\nfunction merge(f1, f2){\n    const {type: t1} = f1;\n    const {type: t2} = f2;      \n    const sameType = t1 === t2 ? t1 : '';\n\n    if (includesNoValues(f2)){\n        return f2;\n    } else if ((t1 === IN && t2 === NOT_IN) || (t1 === NOT_IN && t2 === IN)){\n        // do the two sets cancel each other out ?\n        if (f1.values.length === f2.values.length && f1.values.every(v => f2.values.includes(v))){  \n            if (t1 === IN && t2 === NOT_IN){\n                return {\n                    colName: f1.colName,\n                    type: IN,\n                    values: []\n                }\n            } else {\n                return null;\n            }\n            return null;\n        } else if (f1.values.length > f2.values.length){\n            if (f2.values.every(v => f1.values.includes(v))){\n                return {\n                    ...f1,\n                    values: f1.values.filter(v => !f2.values.includes(v))\n                }\n            }\n        }\n        \n    } else if (sameType === IN || sameType === NOT_IN){\n        return {\n            ...f1,\n            values: f1.values.concat(f2.values.filter(v => !f1.values.includes(v)))\n        }\n    } else if (sameType === STARTS_WITH){\n        return {\n            type: OR,\n            filters: [f1, f2]\n        }\n    } else if (sameType === NOT_STARTS_WITH){\n        return {\n            type: AND,\n            filters: [f1, f2]\n        }\n\n    }\n\n    return f2;\n\n}\n\nfunction combine(existingFilters, replacementFilters) {\n\n    // TODO need a safer REGEX here\n    function equivalentType({ type: t1 }, { type: t2 }) {\n        return (t1 === t2) || (t1[0] === t2[0]);\n    }\n\n    const replaces = (existingFilter, replacementFilter) => {\n        return existingFilter.colName === replacementFilter.colName &&\n            equivalentType(existingFilter, replacementFilter);\n    };\n\n    const stillApplicable = existingFilter => replacementFilters.some(\n        replacementFilter => replaces(existingFilter, replacementFilter)) === false;\n\n    return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nexport function removeFilter(sourceFilter, filterToRemove) {\n    if (filterEquals(sourceFilter, filterToRemove, true)) {\n        return null;\n    } else if (sourceFilter.type !== AND) {\n        throw Error(`removeFilter cannot remove ${JSON.stringify(filterToRemove)} from ${JSON.stringify(sourceFilter)}`);\n    } else {\n        const filters = sourceFilter.filters.filter(f => !filterEquals(f, filterToRemove));\n        return filters.length > 0 ? { type: AND, filters } : null;\n    }\n}\n\nexport function splitFilterOnColumn(filter, columnName) {\n    if (!filter){\n        return [null,null];\n    } else if (filter.colName === columnName) {\n        return [filter,null];\n    } else if (filter.type !== 'AND') {\n        return [null, filter];\n    } else {\n        const [[columnFilter=null], filters] = partition(filter.filters, f => f.colName === columnName);\n        return filters.length === 1\n            ? [columnFilter,filters[0]]\n            : [columnFilter, { type: 'AND', filters }];\n    }\n}\n\nexport const overrideColName = (filter, colName) => {\n    const {type} = filter;\n    if (type === AND || type === OR){\n        return {\n            type,\n            filters: filter.filters.map(f => overrideColName(f, colName))\n        }\n    } else {\n        return {...filter, colName}\n    }\n}\n\nexport function extractFilterForColumn(filter, columnName) {\n    if (!filter) {\n        return null;\n    }\n    const { type, colName } = filter;\n    switch (type) {\n        case AND: \n        case OR: \n            return collectFiltersForColumn(type, filter.filters, columnName);\n\n        default:\n            return colName === columnName ? filter : null;\n    }\n}\n\nfunction collectFiltersForColumn(type, filters, columName){\n    const results = [];\n    filters.forEach(filter => {\n        const ffc = extractFilterForColumn(filter, columName);\n        if (ffc !== null){\n            results.push(ffc);\n        }\n    })\n    if (results.length === 1){\n        return results[0];\n    } else {\n        return {\n            type,\n            filters: results\n        }\n    }\n}\n\nexport function includesColumn(filter, column) {\n    if (!filter) {\n        return false;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case AND: return filters.some(f => includesColumn(f, column));\n    default: return colName === column.name;\n    }\n}\n\nexport function removeFilterForColumn(sourceFilter, column) {\n    const colName = column.name;\n    if (!sourceFilter){\n        return null;\n    } else if (sourceFilter.colName === colName) {\n        return null;\n    } else if (sourceFilter.type === AND || sourceFilter.type === OR) {\n        const {type, filters} = sourceFilter;\n        const otherColFilters = filters.filter(f => f.colName !== colName);\n        switch(otherColFilters.length){\n            case 0: return null;\n            case 1: return otherColFilters[0];\n            default: return { type, otherColFilters } \n        }\n    } else {\n        return sourceFilter;\n    }\n}\n\nconst sameColumn = (f1, f2) => f1.colName === f2.colName;\n\nexport function filterEquals(f1, f2, strict = false) {\n    if (f1 && f1){\n        const isSameColumn = sameColumn(f1,f2);\n        if (!strict) {\n            return isSameColumn;\n        } else {\n            return isSameColumn &&\n                f1.type === f2.type && \n                f1.mode === f2.mode &&\n                f1.value === f2.value &&\n                sameValues(f1.values, f2.values);\n        }\n    } else {\n        return false;\n    }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1, f2) {\n    if (f1.type === IN && f2.type === IN) {\n        return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n    } else if (f1.type === NOT_IN && f2.type === NOT_IN) {\n        return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n    } else {\n        return false;\n    }\n}\n\n//TODO roll this into next function\nexport function projectFilterData(filterRows) {\n    return filterRows.map((row, idx) => [idx, 0, 0, null, row.name, row.count]);\n}\n\nexport function getBinnedValues(rows, key, numberOfBins = 20) {\n    const numbers = rows.map(row => row[key]);\n    // const start = performance.now();\n    const values = d3.histogram().thresholds(numberOfBins)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n    // const end = performance.now();\n    // onsole.log(`%ctook ${end - start} ms to build histogram`, 'font-weight:bold;color:red;');\n    // onsole.log(values);\n    return values;\n\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll(superList, subList) {\n    for (let i = 0, len = subList.length; i < len; i++) {\n        if (superList.indexOf(subList[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues(arr1, arr2) {\n    if (arr1 === arr2) {\n        return true;\n    } else if (arr1.length === arr2.length) {\n        const a = arr1.slice().sort();\n        const b = arr2.slice().sort();\n        return a.join('|') === b.join('|');\n    }\n    return false;\n}\n\nexport function partition(list, test1, test2=null) {\n    const results1 = [];\n    const misses = [];\n    const results2 = test2===null ? null : [];\n\n    for (let i = 0; i < list.length; i++) {\n        if (test1(list[i])) {\n            results1.push(list[i]);\n        } else if (test2 !== null && test2(list[i])) {\n            results2.push(list[i]);\n        } else {\n            misses.push(list[i]);\n        }\n    }\n\n    return test2 === null\n        ? [results1, misses]\n        : [results1, results2, misses];\n}\n"],
  "mappings": "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",
  "names": ["filter", "filterRows"]
}
