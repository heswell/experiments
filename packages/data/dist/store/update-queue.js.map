{
  "version": 3,
  "sources": ["../../src/store/update-queue.ts"],
  "sourcesContent": ["/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nexport default class UpdateQueue {\n\n    constructor(){\n        this._queue = [];\n    }\n\n      get length() { return this._queue.length; }\n\n      update(update) {\n          //TODO we could also coalesce updates into an insert or rowset, if present\n          const batch = this.getCurrentBatch('update');\n\n          const [rowIdx] = update;\n          const {updates} = batch;\n\n          for (let i = 0, len = updates.length; i < len; i++) {\n              if (updates[i][0] === rowIdx) {\n                  // we already have an update for this item, update the update...\n                  let d = updates[i];\n                  for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n                      const pos = d.indexOf(update[colIdx]);\n                      if (pos === -1) {// should check that it is really a colIdx,not a value\n                          d.push(update[colIdx], update[colIdx + 1]);\n                      } else {\n                          d[pos + 1] = update[colIdx + 1];\n                      }\n                  }\n\n                  return;\n              }\n          }\n          updates.push(update);\n      }\n\n      resize(size) {\n          const batch = this.getCurrentBatch('size');\n          batch.size = size;\n      }\n\n      append(row, offset) {\n          const batch = this.getCurrentBatch('insert');\n          //onsole.log(`UpdateQueue append ${row[0]}`);\n          batch.rows.push(row);\n          batch.offset = offset;\n      }\n\n      replace({rows, filter, size, range, offset}) {\n          const batch = this.getCurrentBatch('rowset');\n          batch.rows = rows;\n          batch.size = size;\n          batch.range = range;\n          batch.offset = offset;\n          // HM, think we should fire an immediate response for filter change\n          batch.filter = filter;\n      }\n\n      popAll() {\n          const results = this._queue;\n          this._queue = [];\n          return results;\n      }\n\n      getCurrentBatch(type) {\n\n          const q = this._queue;\n          const len = q.length;\n\n          let batch = len === 0 || type === 'rowset'\n              ? (q[0] = createBatch(type))\n              : q[len - 1];\n\n          if (batch.type !== type) {\n              // roll size recored into subsequent insert \n              if (type === 'insert' && batch.type === 'size') {\n                  batch.type = 'insert';\n                  batch.rows = [];\n              } else if (type === 'size' && batch.type === 'insert') {\n                  // that's ok - go ahead and update size on the insert batch\n              } else {\n                  batch = (q[len] = createBatch(type));\n              }\n          }\n\n          return batch;\n\n      }\n  }\n\nfunction createBatch(type) {\n    switch (type) {\n    case 'rowset': return { type, rows: [] };\n    case 'update': return { type, updates: [] };\n    case 'insert': return { type, rows: [] };\n    case 'size': return { type };\n    default: throw Error('Unknown batch type');\n    }\n}\n"],
  "mappings": "AAWA,MAAO,YAA0B;AAAA,EAE7B,cAAa;AACT,SAAK,SAAS,CAAC;AAAA,EACnB;AAAA,EAEE,IAAI,SAAS;AAAE,WAAO,KAAK,OAAO;AAAA,EAAQ;AAAA,EAE1C,OAAO,QAAQ;AAEX,UAAM,QAAQ,KAAK,gBAAgB,QAAQ;AAE3C,UAAM,CAAC,MAAM,IAAI;AACjB,UAAM,EAAC,QAAO,IAAI;AAElB,aAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,IAAI,KAAK,KAAK;AAChD,UAAI,QAAQ,GAAG,OAAO,QAAQ;AAE1B,YAAI,IAAI,QAAQ;AAChB,iBAAS,SAAS,GAAG,SAAS,OAAO,QAAQ,UAAU,GAAG;AACtD,gBAAM,MAAM,EAAE,QAAQ,OAAO,OAAO;AACpC,cAAI,QAAQ,IAAI;AACZ,cAAE,KAAK,OAAO,SAAS,OAAO,SAAS,EAAE;AAAA,UAC7C,OAAO;AACH,cAAE,MAAM,KAAK,OAAO,SAAS;AAAA,UACjC;AAAA,QACJ;AAEA;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,KAAK,MAAM;AAAA,EACvB;AAAA,EAEA,OAAO,MAAM;AACT,UAAM,QAAQ,KAAK,gBAAgB,MAAM;AACzC,UAAM,OAAO;AAAA,EACjB;AAAA,EAEA,OAAO,KAAK,QAAQ;AAChB,UAAM,QAAQ,KAAK,gBAAgB,QAAQ;AAE3C,UAAM,KAAK,KAAK,GAAG;AACnB,UAAM,SAAS;AAAA,EACnB;AAAA,EAEA,QAAQ,EAAC,MAAM,QAAQ,MAAM,OAAO,OAAM,GAAG;AACzC,UAAM,QAAQ,KAAK,gBAAgB,QAAQ;AAC3C,UAAM,OAAO;AACb,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,SAAS;AAEf,UAAM,SAAS;AAAA,EACnB;AAAA,EAEA,SAAS;AACL,UAAM,UAAU,KAAK;AACrB,SAAK,SAAS,CAAC;AACf,WAAO;AAAA,EACX;AAAA,EAEA,gBAAgB,MAAM;AAElB,UAAM,IAAI,KAAK;AACf,UAAM,MAAM,EAAE;AAEd,QAAI,QAAQ,QAAQ,KAAK,SAAS,WAC3B,EAAE,KAAK,YAAY,IAAI,IACxB,EAAE,MAAM;AAEd,QAAI,MAAM,SAAS,MAAM;AAErB,UAAI,SAAS,YAAY,MAAM,SAAS,QAAQ;AAC5C,cAAM,OAAO;AACb,cAAM,OAAO,CAAC;AAAA,MAClB,WAAW,SAAS,UAAU,MAAM,SAAS,UAAU;AAAA,MAEvD,OAAO;AACH,gBAAS,EAAE,OAAO,YAAY,IAAI;AAAA,MACtC;AAAA,IACJ;AAEA,WAAO;AAAA,EAEX;AACJ;AAEF,SAAS,YAAY,MAAM;AACvB,UAAQ;AAAA,SACH;AAAU,aAAO,EAAE,MAAM,MAAM,CAAC,EAAE;AAAA,SAClC;AAAU,aAAO,EAAE,MAAM,SAAS,CAAC,EAAE;AAAA,SACrC;AAAU,aAAO,EAAE,MAAM,MAAM,CAAC,EAAE;AAAA,SAClC;AAAQ,aAAO,EAAE,KAAK;AAAA;AAClB,YAAM,MAAM,oBAAoB;AAAA;AAE7C;",
  "names": []
}
