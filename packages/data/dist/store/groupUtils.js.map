{
  "version": 3,
  "sources": ["../../src/store/groupUtils.ts"],
  "sourcesContent": ["import { metaData } from './columnUtils.js';\nimport { GROUP_ROW_TEST, sortBy, sortPosition } from './sort.js';\nimport { ASC } from './types.js';\n\nconst LEAF_DEPTH = 0;\nconst DEFAULT_OPTIONS = {\n  startIdx: 0,\n  rootIdx: null,\n  rootExpanded: true,\n  baseGroupby: []\n};\n\nexport function lowestIdxPointer(groups, IDX, DEPTH, start, depth) {\n  let result = Number.MAX_SAFE_INTEGER;\n  for (let i = start; i < groups.length; i++) {\n    const group = groups[i];\n    const absDepth = Math.abs(group[DEPTH]);\n\n    if (absDepth > depth) {\n      break;\n    } else if (absDepth === depth) {\n      const idx = group[IDX];\n      if (typeof idx === 'number' && idx < result) {\n        result = idx;\n      }\n    }\n  }\n\n  return result === Number.MAX_SAFE_INTEGER ? undefined : result;\n}\n\nexport function getCount(groupRow, PRIMARY_COUNT, FALLBACK_COUNT) {\n  return typeof groupRow[PRIMARY_COUNT] === 'number'\n    ? groupRow[PRIMARY_COUNT]\n    : groupRow[FALLBACK_COUNT];\n}\n\nexport class SimpleTracker {\n  constructor(levels) {\n    this.levels = Array(levels)\n      .fill(0)\n      .reduce((acc, el, i) => {\n        acc[i + 1] = { key: null, pos: null, pPos: null };\n        return acc;\n      }, {});\n  }\n  set(depth, pos, groupKey) {\n    if (this.levels) {\n      const level = this.levels[Math.abs(depth)];\n      if (level && level.key !== groupKey) {\n        if (level.key !== null) {\n          level.pPos = level.pos;\n        }\n        level.key = groupKey;\n        level.pos = pos;\n      }\n    }\n  }\n\n  hasParentPos(level) {\n    return this.levels[level + 1] && this.levels[level + 1].pos !== null;\n  }\n\n  parentPos(level) {\n    return this.levels[level + 1].pos;\n  }\n\n  hasPreviousPos(level) {\n    return this.levels[level] && this.levels[level].pPos !== null;\n  }\n\n  previousPos(level) {\n    return this.levels[level].pPos;\n  }\n}\n\nexport class GroupIdxTracker {\n  constructor(levels) {\n    this.idxAdjustment = 0;\n    this.maxLevel = levels + 1;\n    this.levels =\n      levels > 0\n        ? Array(levels)\n            .fill(0)\n            .reduce((acc, el, i) => {\n              acc[i + 2] = { key: null, current: 0, previous: 0 };\n              return acc;\n            }, {})\n        : null;\n  }\n\n  increment(count) {\n    this.idxAdjustment += count;\n    if (this.levels) {\n      for (let i = 2; i < this.maxLevel + 1; i++) {\n        this.levels[i].current += count;\n      }\n    }\n  }\n\n  previous(level) {\n    return (this.levels && this.levels[level] && this.levels[level].previous) || 0;\n  }\n\n  hasPrevious(level) {\n    return this.previous(level) > 0;\n  }\n\n  get(idx) {\n    return this.levels === null ? null : this.levels[idx];\n  }\n\n  set(depth, groupKey) {\n    if (this.levels) {\n      const level = this.levels[depth];\n      if (level && level.key !== groupKey) {\n        if (level.key !== null) {\n          level.previous += level.current;\n          level.current = 0;\n        }\n        level.key = groupKey;\n      }\n    }\n  }\n}\n\nconst itemIsNumeric = (item) => !isNaN(parseInt(item, 10));\nconst numerically = (a, b) => parseInt(a) - parseInt(b);\n\nfunction sortKeys(o) {\n  const keys = Object.keys(o);\n  if (keys.every(itemIsNumeric)) {\n    return keys.sort(numerically);\n  } else {\n    return keys.sort();\n  }\n}\n\nexport function fillNavSetsFromGroups(\n  groups,\n  sortSet,\n  sortIdx = 0,\n  filterSet = null,\n  filterIdx,\n  filterLen\n) {\n  const keys = sortKeys(groups);\n  const filtered = filterSet !== null;\n  const filterIndices = filtered ? filterSet.slice(filterIdx, filterLen) : null;\n  for (let i = 0; i < keys.length; i++) {\n    const groupedRows = groups[keys[i]];\n    if (Array.isArray(groupedRows)) {\n      for (let j = 0, len = groupedRows.length; j < len; j++) {\n        const rowIdx = groupedRows[j];\n        sortSet[sortIdx] = rowIdx;\n        sortIdx += 1;\n        // this could be prohibitively slow (the includes test) ...\n        if (filtered && filterIndices.includes(rowIdx)) {\n          filterSet[filterIdx] = rowIdx;\n          filterIdx += 1;\n        }\n      }\n    } else {\n      sortIdx = fillNavSetsFromGroups(groupedRows, sortSet, sortIdx);\n    }\n  }\n  return sortIdx;\n}\n\n// WHY is param order different from groupLeafRows\nexport function groupRows(rows, sortSet, columns, columnMap, groupby, options = DEFAULT_OPTIONS) {\n  const {\n    startIdx = 0,\n    length = rows.length,\n    rootIdx = null,\n    baseGroupby = [],\n    groups = [],\n    rowParents = null,\n    filterLength,\n    filterSet,\n    filterFn: filter\n  } = options;\n  let { groupIdx = -1, filterIdx } = options;\n\n  const aggregations = findAggregatedColumns(columns, columnMap, groupby);\n  const groupedLeafRows = groupLeafRows(sortSet, rows, groupby, startIdx, length);\n  fillNavSetsFromGroups(groupedLeafRows, sortSet, startIdx, filterSet, filterIdx, filterLength);\n\n  const levels = groupby.length;\n  const currentGroups = Array(levels).fill(null);\n  const { IDX, DEPTH, FILTER_COUNT, NEXT_FILTER_IDX } = metaData(columns);\n\n  let parentIdx = rootIdx;\n  let leafCount = 0;\n\n  for (let i = startIdx, len = startIdx + length; i < len; i++) {\n    const rowIdx = sortSet[i];\n    const row = rows[rowIdx];\n\n    for (let level = 0; level < levels; level++) {\n      const [columnIdx] = groupby[level];\n      const currentGroup = currentGroups[level];\n      const groupValue = row[columnIdx];\n      // as soon as we identify a group change, each group at that level and below\n      // is then aggregated and new group(s) initiated.\n      if (currentGroup === null || currentGroup[columnIdx] !== groupValue) {\n        if (currentGroup !== null) {\n          // as soon as we know we're regrouping, aggregate the open groups, in reverse order\n          for (let ii = levels - 1; ii >= level; ii--) {\n            const group = currentGroups[ii];\n            aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n            if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0) {\n              group[NEXT_FILTER_IDX] = filterIdx;\n              filterIdx += group[FILTER_COUNT];\n            }\n          }\n\n          leafCount = 0;\n        }\n        for (let ii = level; ii < levels; ii++) {\n          groupIdx += 1;\n          parentIdx = ii === 0 ? rootIdx : currentGroups[ii - 1][IDX];\n          const depth = levels - ii;\n          // for first-level groups, row pointer is a pointer into the sortSet\n          const childIdx = depth === 1 ? i : groupIdx + 1;\n\n          const groupRow = (currentGroups[ii] = GroupRow(\n            row,\n            depth,\n            groupIdx,\n            childIdx,\n            parentIdx,\n            groupby,\n            columns,\n            columnMap,\n            baseGroupby\n          ));\n          groups.push(groupRow);\n        }\n        break; // do not continue looping once we identify the change point\n      }\n    }\n    rowParents && (rowParents[rowIdx] = groupIdx);\n    leafCount += 1;\n  }\n\n  for (let i = levels - 1; i >= 0; i--) {\n    if (currentGroups[i] !== null) {\n      const group = currentGroups[i];\n      aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n      if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0) {\n        group[NEXT_FILTER_IDX] = filterIdx;\n      }\n    }\n  }\n  return groups;\n}\n\n// Checks very specifically for new cols added at end\nexport function groupbyExtendsExistingGroupby(groupBy, existingGroupBy) {\n  return (\n    groupBy.length > existingGroupBy.length &&\n    existingGroupBy.every((g, i) => g[0] === groupBy[i][0])\n  );\n}\n\n// doesn't care from which position col is removed, as long as it is not the first\nexport function groupbyReducesExistingGroupby(groupby, existingGroupby) {\n  return (\n    existingGroupby.length > groupby.length &&\n    groupby[0][0] === existingGroupby[0][0] &&\n    groupby.every(([key]) => existingGroupby.find(([key2]) => key2 === key))\n  );\n}\n\nexport function groupbySortReversed(groupBy, existingGroupBy) {\n  const [col] = findSortedCol(groupBy, existingGroupBy);\n  return col !== null;\n}\n\nexport function findDoomedColumnDepths(groupby, existingGroupby) {\n  const count = existingGroupby.length;\n  return existingGroupby.reduce((results, [colIdx], idx) => {\n    if (!groupby.some((group) => group[0] === colIdx)) {\n      results.push(count - idx);\n    }\n    return results;\n  }, []);\n}\n\nexport function findSortedCol(groupby, existingGroupby) {\n  let results = [null];\n  let len1 = groupby && groupby.length;\n  let len2 = existingGroupby && existingGroupby.length;\n  if (len1 && len2 && len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      if (groupby[i][0] !== existingGroupby[i][0]) {\n        return results;\n      } else if (groupby[i][1] !== existingGroupby[i][1]) {\n        results[0] = i;\n        results[1] = len1 - i;\n      }\n    }\n  }\n  return results;\n}\n\nfunction byKey([key1], [key2]) {\n  return key1 > key2 ? 1 : key2 > key1 ? -1 : 0;\n}\n\nconst EMPTY = {};\nexport function getGroupStateChanges(\n  groupState,\n  existingGroupState = null,\n  baseKey = '',\n  groupIdx = 0\n) {\n  const results = [];\n  const entries = Object.entries(groupState);\n\n  entries.forEach(([key, value]) => {\n    if (value && (existingGroupState === null || !existingGroupState[key])) {\n      results.push([baseKey + key, groupIdx, true]);\n      if (value !== null && typeof value === 'object' && Object.keys(value).length > 0) {\n        const diff = getGroupStateChanges(value, EMPTY, baseKey + key + '/', groupIdx + 1);\n        if (diff.length) {\n          results.push(...diff);\n        }\n      }\n    } else if (value) {\n      const diff = getGroupStateChanges(\n        value,\n        existingGroupState[key],\n        baseKey + key + '/',\n        groupIdx + 1\n      );\n      if (diff.length) {\n        results.push(...diff);\n      }\n    }\n  });\n\n  if (existingGroupState !== null && typeof existingGroupState === 'object') {\n    Object.entries(existingGroupState).forEach(([key, value]) => {\n      if (value && !groupState[key]) {\n        results.push([baseKey + key, groupIdx, false]);\n      }\n    });\n  }\n\n  return results.sort(byKey);\n}\n\nexport function getDirection(depth, groupby) {\n  const idx = groupby.length - depth;\n  const [, direction] = groupby[idx];\n  return direction;\n}\n\n// should be called toggleColumnInGroupBy\nexport function updateGroupBy(existingGroupBy = null, column /*, replace = false*/) {\n  console.log(``);\n  if (existingGroupBy === null) {\n    return [[column.name, ASC]];\n  } else {\n    return indexOfCol(column.name, existingGroupBy) === -1\n      ? existingGroupBy.concat([[column.name, ASC]])\n      : existingGroupBy.length === 1\n      ? null\n      : existingGroupBy.filter(([colName]) => colName !== column.name);\n  }\n}\n\nexport function expanded(group, groupby, groupState) {\n  const groupIdx = groupby.length - Math.abs(group[1]);\n  let groupVal;\n  let stateEntry = groupState;\n  for (let i = 0; i <= groupIdx; i++) {\n    const [colIdx] = groupby[i];\n    groupVal = group[colIdx];\n    if (i === groupIdx) {\n      return stateEntry[groupVal];\n    } else {\n      stateEntry = stateEntry[groupVal];\n      if (!stateEntry) {\n        return false;\n      }\n    }\n  }\n  return false;\n}\n\nexport function indexOfCol(key, cols = null) {\n  if (cols !== null) {\n    for (let i = 0; i < cols.length; i++) {\n      // check both while we transition from groupBy to extendedGroupby\n      // groupBy = [colName, dir] extendedGroupby = [colIdx, dir,colName]\n      const [col1, , col2] = cols[i];\n      if (col1 === key || col2 === key) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n// export function countNestedRows(rows, idx, depth) {\n//     const DEPTH = Data.DEPTH_FIELD;\n//     let count = 0;\n//     for (let i = idx, len = rows.length;\n//         i < len && Math.abs(rows[i][DEPTH]) < depth;\n//         i++) {\n//         count += 1;\n//     }\n//     return count;\n// }\n\n// TBC\n// export function countGroupMembers(groupedRows) {\n//     const results = [];\n//     const groups = [];\n//     let currentGroup = null;\n\n//     for (let i = 0; i < groupedRows.length; i++) {\n//         let [, depth] = groupedRows[i];\n//         if (depth === LEAF_DEPTH) {\n//             currentGroup.count += 1;\n//         } else {\n//             depth = Math.abs(depth);\n//             while (currentGroup && depth >= currentGroup.depth) {\n//                 const completedGroup = groups.shift();\n//                 const group = results[completedGroup.i];\n//                 if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//                     const newGroup = group.slice();\n//                     newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//                     results[completedGroup.i] = newGroup;\n//                 }\n//                 groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//                 ([currentGroup] = groups);\n//             }\n\n//             currentGroup = { i, depth, count: 0 };\n//             groups.unshift(currentGroup);\n//         }\n\n//         results[i] = groupedRows[i];\n\n//     }\n\n//     while (currentGroup) {\n//         const completedGroup = groups.shift();\n//         const group = results[completedGroup.i];\n//         if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//             const newGroup = group.slice();\n//             newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//             results[completedGroup.i] = newGroup;\n//         }\n//         groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//         ([currentGroup] = groups);\n//     }\n\n//     return results;\n// }\n\nexport function allGroupsExpanded(groups, group, { DEPTH, PARENT_IDX }) {\n  do {\n    if (group[DEPTH] < 0) {\n      return false;\n    }\n    group = groups[group[PARENT_IDX]];\n  } while (group);\n\n  return true;\n}\n\nexport function adjustGroupIndices(\n  groups,\n  grpIdx,\n  { IDX, DEPTH, IDX_POINTER, PARENT_IDX },\n  adjustment = 1\n) {\n  for (let i = 0; i < groups.length; i++) {\n    if (groups[i][IDX] >= grpIdx) {\n      groups[i][IDX] += adjustment;\n      if (Math.abs(groups[i][DEPTH]) > 1) {\n        groups[i][IDX_POINTER] += adjustment;\n      }\n      let parentIdx = groups[i][PARENT_IDX];\n      if (parentIdx !== null && parentIdx >= grpIdx) {\n        groups[i][PARENT_IDX] += adjustment;\n      }\n    }\n  }\n}\n\nexport function adjustLeafIdxPointers(\n  groups,\n  insertionPoint,\n  { DEPTH, IDX_POINTER },\n  adjustment = 1\n) {\n  for (let i = 0; i < groups.length; i++) {\n    if (Math.abs(groups[i][DEPTH]) === 1 && groups[i][IDX_POINTER] >= insertionPoint) {\n      groups[i][IDX_POINTER] += adjustment;\n    }\n  }\n}\n\nexport function findGroupPositions(groups, groupby, row) {\n  const positions = [];\n\n  out: for (let i = 0; i < groupby.length; i++) {\n    const sorter = sortBy(groupby.slice(0, i + 1), GROUP_ROW_TEST);\n    const position = sortPosition(groups, sorter, row, 'first-available');\n    const group = groups[position];\n    // if all groups are missing and insert position is end of list ...\n    if (group === undefined) {\n      break;\n    }\n    // position is confirmed if all groupCol values in this comparison match values of row\n    // and other groupCol values  are null\n    for (let j = 0; j < groupby.length; j++) {\n      const colIdx = groupby[j][0];\n      const colValue = group[colIdx];\n      if (j > i) {\n        if (colValue !== null) {\n          break out;\n        }\n      } else if (colValue !== row[colIdx]) {\n        break out;\n      }\n    }\n    positions.push(position);\n  }\n\n  return positions;\n}\n\nexport const expandRow = (groupCols, row, meta) => {\n  const r = row.slice();\n  r[meta.IDX] = 0;\n  r[meta.DEPTH] = 0;\n  r[meta.COUNT] = 0;\n  r[meta.KEY] = buildGroupKey(groupCols, row);\n  r[meta.SELECTED] = 0;\n  return r;\n};\n\nfunction buildGroupKey(groupby, row) {\n  const extractKey = ([idx]) => row[idx];\n  return groupby.map(extractKey).join('/');\n}\n\n// Do we have to take columnMap out again ?\nexport function GroupRow(\n  row,\n  depth,\n  idx,\n  childIdx,\n  parentIdx,\n  groupby,\n  columns,\n  columnMap,\n  baseGroupby = []\n) {\n  const { IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED, PARENT_IDX, IDX_POINTER, count } =\n    metaData(columns);\n  const group = Array(count);\n  const groupIdx = groupby.length - depth;\n  let colIdx;\n\n  for (let i = 0; i < columns.length; i++) {\n    const column = columns[i];\n    const key = columnMap[column.name];\n    if (column.aggregate) {\n      // implies we can't group on aggregate columns, does the UI know that ?\n      group[key] = 0;\n    } else if ((colIdx = indexOfCol(key, groupby)) !== -1 && colIdx <= groupIdx) {\n      group[key] = row[key];\n    } else {\n      group[key] = null;\n    }\n  }\n\n  for (let i = 0; i < baseGroupby.length; i++) {\n    const [colIdx] = baseGroupby[i];\n    group[colIdx] = row[colIdx];\n  }\n\n  const extractKey = ([idx]) => row[idx];\n  const buildKey = (groupby) => groupby.map(extractKey).join('/');\n  //TODO build the composite key for the grouprow\n  const baseKey = baseGroupby.length > 0 ? buildKey(baseGroupby) + '/' : '';\n  const groupKey = buildKey(groupby.slice(0, groupIdx + 1));\n\n  group[IDX] = idx;\n  group[RENDER_IDX] = 0;\n  group[DEPTH] = -depth;\n  group[COUNT] = 0;\n  group[KEY] = baseKey + groupKey;\n  group[SELECTED] = 0;\n  group[IDX_POINTER] = childIdx;\n  group[PARENT_IDX] = parentIdx;\n\n  return group;\n}\n\nexport function groupLeafRows(sortSet, leafRows, groupby, startIdx = 0, length = sortSet.length) {\n  const groups = {};\n  const levels = groupby.length;\n  const lastLevel = levels - 1;\n  for (let i = startIdx, len = startIdx + length; i < len; i++) {\n    const idx = sortSet[i];\n    const leafRow = leafRows[idx];\n    let target = groups;\n    let targetKey;\n    let key;\n    for (let level = 0; level < levels; level++) {\n      const [colIdx] = groupby[level];\n      key = leafRow[colIdx];\n      targetKey = target[key];\n      if (targetKey && level === lastLevel) {\n        targetKey.push(idx);\n      } else if (targetKey) {\n        target = targetKey;\n      } else if (!targetKey && level < lastLevel) {\n        target = target[key] = {};\n      } else if (!targetKey) {\n        target[key] = [idx];\n      }\n    }\n  }\n  return groups;\n}\n\nexport function splitGroupsAroundDoomedGroup(groupby, doomed) {\n  const lastGroupIsDoomed = doomed === 1;\n  const doomedIdx = groupby.length - doomed;\n  const preDoomedGroupby = [];\n  const postDoomedGroupby = [];\n\n  groupby.forEach((col, i) => {\n    if (i < doomedIdx) {\n      preDoomedGroupby.push(col);\n    } else if (i > doomedIdx) {\n      postDoomedGroupby.push(col);\n    }\n  });\n\n  return [lastGroupIsDoomed, preDoomedGroupby, postDoomedGroupby];\n}\n\nexport function decrementDepth(depth) {\n  return (Math.abs(depth) - 1) * (depth < 0 ? -1 : 1);\n}\n\nexport function incrementDepth(depth) {\n  return (Math.abs(depth) + 1) * (depth < 0 ? -1 : 1);\n}\n\n// hardcode the index ref for now\n// When we build the group index, all groups are collapsed\nexport function indexGroupedRows(groupedRows) {\n  // TODO\n  const Fields = {\n    Depth: 1,\n    Key: 4\n  };\n\n  const groupedIndex = {};\n  const levels = [];\n  const COLLAPSED = -1;\n\n  for (let idx = 0; idx < groupedRows.length; idx++) {\n    let row = groupedRows[idx];\n    let rowDepth = row[Fields.Depth];\n\n    if (rowDepth === 0) {\n      let index = [idx];\n      levels.forEach((level) => {\n        index.push(level[1], COLLAPSED);\n      });\n      groupedIndex[row[Fields.Key]] = index;\n    } else {\n      while (levels.length && Math.abs(levels[levels.length - 1][0]) <= Math.abs(rowDepth)) {\n        levels.pop();\n      }\n      levels.push([rowDepth, idx]);\n    }\n  }\n\n  return groupedIndex;\n}\n\nexport function findAggregatedColumns(columns, columnMap, groupby) {\n  return columns.reduce((aggregations, column) => {\n    if (column.aggregate && indexOfCol(column.name, groupby) === -1) {\n      const key = columnMap[column.name];\n      aggregations.push([key, column.aggregate]);\n    }\n    return aggregations;\n  }, []);\n}\n\nexport function aggregateGroup(groups, grpIdx, sortSet, rows, columns, aggregations) {\n  const { DEPTH, COUNT } = metaData(columns);\n  const groupRow = groups[grpIdx];\n  let depth = groupRow[DEPTH];\n  let absDepth = Math.abs(depth);\n  let count = 0;\n  let idx = grpIdx;\n\n  // find the last nested group and work back - first build aggregates for level 1 groups,\n  // then use those to aggregate to level 2 etc.\n  while (idx < groups.length - 1 && Math.abs(groups[idx + 1][DEPTH]) < absDepth) {\n    idx += 1;\n    count += 1;\n  }\n\n  for (let i = grpIdx + count; i >= grpIdx; i--) {\n    for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n      const [colIdx] = aggregations[aggIdx];\n      groups[i][colIdx] = 0;\n    }\n    aggregate(groups[i], groups, sortSet, rows, columns, aggregations, groups[i][COUNT]);\n  }\n}\n\nfunction aggregate(\n  groupRow,\n  groupRows,\n  sortSet,\n  rows,\n  columns,\n  aggregations,\n  leafCount,\n  filter = null\n) {\n  const { DEPTH, COUNT, FILTER_COUNT } = metaData(columns);\n  const { IDX_POINTER } = metaData(columns);\n  let absDepth = Math.abs(groupRow[DEPTH]);\n  let count = 0;\n  let filteredCount = filter === null ? undefined : 0;\n\n  if (absDepth === 1) {\n    // The first group accumulates aggregates from the raw data...\n    let start = groupRow[IDX_POINTER];\n    let end = start + leafCount;\n    count = leafCount;\n    for (let i = start; i < end; i++) {\n      const row = rows[sortSet[i]];\n      const included = filter === null || filter(row);\n      if (filter && included) {\n        filteredCount += 1;\n      }\n      if (filter === null || included) {\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n          const [colIdx] = aggregations[aggIdx];\n          groupRow[colIdx] += row[colIdx];\n        }\n      }\n    }\n  } else {\n    // higher-level groups aggregate from child-groups ...\n    // we cannot blindly use the grpIndex of the groupRow, as we may be dealing with a smaller subset\n    // of groupRows, e,g, when inserting a new row and creating the missing groups\n    const startIdx = groupRows.indexOf(groupRow) + 1;\n    for (let i = startIdx; i < groupRows.length; i++) {\n      const nestedGroupRow = groupRows[i];\n      const nestedRowDepth = nestedGroupRow[DEPTH];\n      const nestedRowCount = nestedGroupRow[COUNT];\n      const absNestedRowDepth = Math.abs(nestedRowDepth);\n      if (absNestedRowDepth >= absDepth) {\n        break;\n      } else if (absNestedRowDepth === absDepth - 1) {\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n          const [colIdx, method] = aggregations[aggIdx];\n          if (method === 'avg') {\n            groupRow[colIdx] += nestedGroupRow[colIdx] * nestedRowCount;\n          } else {\n            groupRow[colIdx] += nestedGroupRow[colIdx];\n          }\n        }\n        count += nestedRowCount;\n      }\n    }\n  }\n\n  for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n    const [colIdx, method] = aggregations[aggIdx];\n    if (method === 'avg') {\n      groupRow[colIdx] = groupRow[colIdx] / count;\n    }\n  }\n\n  groupRow[COUNT] = count;\n  groupRow[FILTER_COUNT] = filteredCount;\n}\n"],
  "mappings": "AAAA,SAAS,gBAAgB;AACzB,SAAS,gBAAgB,QAAQ,oBAAoB;AACrD,SAAS,WAAW;AAEpB,MAAM,aAAa;AACnB,MAAM,kBAAkB;AAAA,EACtB,UAAU;AAAA,EACV,SAAS;AAAA,EACT,cAAc;AAAA,EACd,aAAa,CAAC;AAChB;AAEO,SAAS,iBAAiB,QAAQ,KAAK,OAAO,OAAO,OAAO;AACjE,MAAI,SAAS,OAAO;AACpB,WAAS,IAAI,OAAO,IAAI,OAAO,QAAQ,KAAK;AAC1C,UAAM,QAAQ,OAAO;AACrB,UAAM,WAAW,KAAK,IAAI,MAAM,MAAM;AAEtC,QAAI,WAAW,OAAO;AACpB;AAAA,IACF,WAAW,aAAa,OAAO;AAC7B,YAAM,MAAM,MAAM;AAClB,UAAI,OAAO,QAAQ,YAAY,MAAM,QAAQ;AAC3C,iBAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAEA,SAAO,WAAW,OAAO,mBAAmB,SAAY;AAC1D;AAEO,SAAS,SAAS,UAAU,eAAe,gBAAgB;AAChE,SAAO,OAAO,SAAS,mBAAmB,WACtC,SAAS,iBACT,SAAS;AACf;AAEO,MAAM,cAAc;AAAA,EACzB,YAAY,QAAQ;AAClB,SAAK,SAAS,MAAM,MAAM,EACvB,KAAK,CAAC,EACN,OAAO,CAAC,KAAK,IAAI,MAAM;AACtB,UAAI,IAAI,KAAK,EAAE,KAAK,MAAM,KAAK,MAAM,MAAM,KAAK;AAChD,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAAA,EACT;AAAA,EACA,IAAI,OAAO,KAAK,UAAU;AACxB,QAAI,KAAK,QAAQ;AACf,YAAM,QAAQ,KAAK,OAAO,KAAK,IAAI,KAAK;AACxC,UAAI,SAAS,MAAM,QAAQ,UAAU;AACnC,YAAI,MAAM,QAAQ,MAAM;AACtB,gBAAM,OAAO,MAAM;AAAA,QACrB;AACA,cAAM,MAAM;AACZ,cAAM,MAAM;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa,OAAO;AAClB,WAAO,KAAK,OAAO,QAAQ,MAAM,KAAK,OAAO,QAAQ,GAAG,QAAQ;AAAA,EAClE;AAAA,EAEA,UAAU,OAAO;AACf,WAAO,KAAK,OAAO,QAAQ,GAAG;AAAA,EAChC;AAAA,EAEA,eAAe,OAAO;AACpB,WAAO,KAAK,OAAO,UAAU,KAAK,OAAO,OAAO,SAAS;AAAA,EAC3D;AAAA,EAEA,YAAY,OAAO;AACjB,WAAO,KAAK,OAAO,OAAO;AAAA,EAC5B;AACF;AAEO,MAAM,gBAAgB;AAAA,EAC3B,YAAY,QAAQ;AAClB,SAAK,gBAAgB;AACrB,SAAK,WAAW,SAAS;AACzB,SAAK,SACH,SAAS,IACL,MAAM,MAAM,EACT,KAAK,CAAC,EACN,OAAO,CAAC,KAAK,IAAI,MAAM;AACtB,UAAI,IAAI,KAAK,EAAE,KAAK,MAAM,SAAS,GAAG,UAAU,EAAE;AAClD,aAAO;AAAA,IACT,GAAG,CAAC,CAAC,IACP;AAAA,EACR;AAAA,EAEA,UAAU,OAAO;AACf,SAAK,iBAAiB;AACtB,QAAI,KAAK,QAAQ;AACf,eAAS,IAAI,GAAG,IAAI,KAAK,WAAW,GAAG,KAAK;AAC1C,aAAK,OAAO,GAAG,WAAW;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,SAAS,OAAO;AACd,WAAQ,KAAK,UAAU,KAAK,OAAO,UAAU,KAAK,OAAO,OAAO,YAAa;AAAA,EAC/E;AAAA,EAEA,YAAY,OAAO;AACjB,WAAO,KAAK,SAAS,KAAK,IAAI;AAAA,EAChC;AAAA,EAEA,IAAI,KAAK;AACP,WAAO,KAAK,WAAW,OAAO,OAAO,KAAK,OAAO;AAAA,EACnD;AAAA,EAEA,IAAI,OAAO,UAAU;AACnB,QAAI,KAAK,QAAQ;AACf,YAAM,QAAQ,KAAK,OAAO;AAC1B,UAAI,SAAS,MAAM,QAAQ,UAAU;AACnC,YAAI,MAAM,QAAQ,MAAM;AACtB,gBAAM,YAAY,MAAM;AACxB,gBAAM,UAAU;AAAA,QAClB;AACA,cAAM,MAAM;AAAA,MACd;AAAA,IACF;AAAA,EACF;AACF;AAEA,MAAM,gBAAgB,CAAC,SAAS,CAAC,MAAM,SAAS,MAAM,EAAE,CAAC;AACzD,MAAM,cAAc,CAAC,GAAG,MAAM,SAAS,CAAC,IAAI,SAAS,CAAC;AAEtD,SAAS,SAAS,GAAG;AACnB,QAAM,OAAO,OAAO,KAAK,CAAC;AAC1B,MAAI,KAAK,MAAM,aAAa,GAAG;AAC7B,WAAO,KAAK,KAAK,WAAW;AAAA,EAC9B,OAAO;AACL,WAAO,KAAK,KAAK;AAAA,EACnB;AACF;AAEO,SAAS,sBACd,QACA,SACA,UAAU,GACV,YAAY,MACZ,WACA,WACA;AACA,QAAM,OAAO,SAAS,MAAM;AAC5B,QAAM,WAAW,cAAc;AAC/B,QAAM,gBAAgB,WAAW,UAAU,MAAM,WAAW,SAAS,IAAI;AACzE,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,cAAc,OAAO,KAAK;AAChC,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,eAAS,IAAI,GAAG,MAAM,YAAY,QAAQ,IAAI,KAAK,KAAK;AACtD,cAAM,SAAS,YAAY;AAC3B,gBAAQ,WAAW;AACnB,mBAAW;AAEX,YAAI,YAAY,cAAc,SAAS,MAAM,GAAG;AAC9C,oBAAU,aAAa;AACvB,uBAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF,OAAO;AACL,gBAAU,sBAAsB,aAAa,SAAS,OAAO;AAAA,IAC/D;AAAA,EACF;AACA,SAAO;AACT;AAGO,SAAS,UAAU,MAAM,SAAS,SAAS,WAAW,SAAS,UAAU,iBAAiB;AAC/F,QAAM;AAAA,IACJ,WAAW;AAAA,IACX,SAAS,KAAK;AAAA,IACd,UAAU;AAAA,IACV,cAAc,CAAC;AAAA,IACf,SAAS,CAAC;AAAA,IACV,aAAa;AAAA,IACb;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ,IAAI;AACJ,MAAI,EAAE,WAAW,IAAI,UAAU,IAAI;AAEnC,QAAM,eAAe,sBAAsB,SAAS,WAAW,OAAO;AACtE,QAAM,kBAAkB,cAAc,SAAS,MAAM,SAAS,UAAU,MAAM;AAC9E,wBAAsB,iBAAiB,SAAS,UAAU,WAAW,WAAW,YAAY;AAE5F,QAAM,SAAS,QAAQ;AACvB,QAAM,gBAAgB,MAAM,MAAM,EAAE,KAAK,IAAI;AAC7C,QAAM,EAAE,KAAK,OAAO,cAAc,gBAAgB,IAAI,SAAS,OAAO;AAEtE,MAAI,YAAY;AAChB,MAAI,YAAY;AAEhB,WAAS,IAAI,UAAU,MAAM,WAAW,QAAQ,IAAI,KAAK,KAAK;AAC5D,UAAM,SAAS,QAAQ;AACvB,UAAM,MAAM,KAAK;AAEjB,aAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AAC3C,YAAM,CAAC,SAAS,IAAI,QAAQ;AAC5B,YAAM,eAAe,cAAc;AACnC,YAAM,aAAa,IAAI;AAGvB,UAAI,iBAAiB,QAAQ,aAAa,eAAe,YAAY;AACnE,YAAI,iBAAiB,MAAM;AAEzB,mBAAS,KAAK,SAAS,GAAG,MAAM,OAAO,MAAM;AAC3C,kBAAM,QAAQ,cAAc;AAC5B,sBAAU,OAAO,QAAQ,SAAS,MAAM,SAAS,cAAc,WAAW,MAAM;AAChF,gBAAI,aAAa,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK,MAAM,gBAAgB,GAAG;AACxE,oBAAM,mBAAmB;AACzB,2BAAa,MAAM;AAAA,YACrB;AAAA,UACF;AAEA,sBAAY;AAAA,QACd;AACA,iBAAS,KAAK,OAAO,KAAK,QAAQ,MAAM;AACtC,sBAAY;AACZ,sBAAY,OAAO,IAAI,UAAU,cAAc,KAAK,GAAG;AACvD,gBAAM,QAAQ,SAAS;AAEvB,gBAAM,WAAW,UAAU,IAAI,IAAI,WAAW;AAE9C,gBAAM,WAAY,cAAc,MAAM;AAAA,YACpC;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,iBAAO,KAAK,QAAQ;AAAA,QACtB;AACA;AAAA,MACF;AAAA,IACF;AACA,mBAAe,WAAW,UAAU;AACpC,iBAAa;AAAA,EACf;AAEA,WAAS,IAAI,SAAS,GAAG,KAAK,GAAG,KAAK;AACpC,QAAI,cAAc,OAAO,MAAM;AAC7B,YAAM,QAAQ,cAAc;AAC5B,gBAAU,OAAO,QAAQ,SAAS,MAAM,SAAS,cAAc,WAAW,MAAM;AAChF,UAAI,aAAa,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK,MAAM,gBAAgB,GAAG;AACxE,cAAM,mBAAmB;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAGO,SAAS,8BAA8B,SAAS,iBAAiB;AACtE,SACE,QAAQ,SAAS,gBAAgB,UACjC,gBAAgB,MAAM,CAAC,GAAG,MAAM,EAAE,OAAO,QAAQ,GAAG,EAAE;AAE1D;AAGO,SAAS,8BAA8B,SAAS,iBAAiB;AACtE,SACE,gBAAgB,SAAS,QAAQ,UACjC,QAAQ,GAAG,OAAO,gBAAgB,GAAG,MACrC,QAAQ,MAAM,CAAC,CAAC,GAAG,MAAM,gBAAgB,KAAK,CAAC,CAAC,IAAI,MAAM,SAAS,GAAG,CAAC;AAE3E;AAEO,SAAS,oBAAoB,SAAS,iBAAiB;AAC5D,QAAM,CAAC,GAAG,IAAI,cAAc,SAAS,eAAe;AACpD,SAAO,QAAQ;AACjB;AAEO,SAAS,uBAAuB,SAAS,iBAAiB;AAC/D,QAAM,QAAQ,gBAAgB;AAC9B,SAAO,gBAAgB,OAAO,CAAC,SAAS,CAAC,MAAM,GAAG,QAAQ;AACxD,QAAI,CAAC,QAAQ,KAAK,CAAC,UAAU,MAAM,OAAO,MAAM,GAAG;AACjD,cAAQ,KAAK,QAAQ,GAAG;AAAA,IAC1B;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,cAAc,SAAS,iBAAiB;AACtD,MAAI,UAAU,CAAC,IAAI;AACnB,MAAI,OAAO,WAAW,QAAQ;AAC9B,MAAI,OAAO,mBAAmB,gBAAgB;AAC9C,MAAI,QAAQ,QAAQ,SAAS,MAAM;AACjC,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,UAAI,QAAQ,GAAG,OAAO,gBAAgB,GAAG,IAAI;AAC3C,eAAO;AAAA,MACT,WAAW,QAAQ,GAAG,OAAO,gBAAgB,GAAG,IAAI;AAClD,gBAAQ,KAAK;AACb,gBAAQ,KAAK,OAAO;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,MAAM,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG;AAC7B,SAAO,OAAO,OAAO,IAAI,OAAO,OAAO,KAAK;AAC9C;AAEA,MAAM,QAAQ,CAAC;AACR,SAAS,qBACd,YACA,qBAAqB,MACrB,UAAU,IACV,WAAW,GACX;AACA,QAAM,UAAU,CAAC;AACjB,QAAM,UAAU,OAAO,QAAQ,UAAU;AAEzC,UAAQ,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAChC,QAAI,UAAU,uBAAuB,QAAQ,CAAC,mBAAmB,OAAO;AACtE,cAAQ,KAAK,CAAC,UAAU,KAAK,UAAU,IAAI,CAAC;AAC5C,UAAI,UAAU,QAAQ,OAAO,UAAU,YAAY,OAAO,KAAK,KAAK,EAAE,SAAS,GAAG;AAChF,cAAM,OAAO,qBAAqB,OAAO,OAAO,UAAU,MAAM,KAAK,WAAW,CAAC;AACjF,YAAI,KAAK,QAAQ;AACf,kBAAQ,KAAK,GAAG,IAAI;AAAA,QACtB;AAAA,MACF;AAAA,IACF,WAAW,OAAO;AAChB,YAAM,OAAO;AAAA,QACX;AAAA,QACA,mBAAmB;AAAA,QACnB,UAAU,MAAM;AAAA,QAChB,WAAW;AAAA,MACb;AACA,UAAI,KAAK,QAAQ;AACf,gBAAQ,KAAK,GAAG,IAAI;AAAA,MACtB;AAAA,IACF;AAAA,EACF,CAAC;AAED,MAAI,uBAAuB,QAAQ,OAAO,uBAAuB,UAAU;AACzE,WAAO,QAAQ,kBAAkB,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC3D,UAAI,SAAS,CAAC,WAAW,MAAM;AAC7B,gBAAQ,KAAK,CAAC,UAAU,KAAK,UAAU,KAAK,CAAC;AAAA,MAC/C;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,QAAQ,KAAK,KAAK;AAC3B;AAEO,SAAS,aAAa,OAAO,SAAS;AAC3C,QAAM,MAAM,QAAQ,SAAS;AAC7B,QAAM,CAAC,EAAE,SAAS,IAAI,QAAQ;AAC9B,SAAO;AACT;AAGO,SAAS,cAAc,kBAAkB,MAAM,QAA8B;AAClF,UAAQ,IAAI,EAAE;AACd,MAAI,oBAAoB,MAAM;AAC5B,WAAO,CAAC,CAAC,OAAO,MAAM,GAAG,CAAC;AAAA,EAC5B,OAAO;AACL,WAAO,WAAW,OAAO,MAAM,eAAe,MAAM,KAChD,gBAAgB,OAAO,CAAC,CAAC,OAAO,MAAM,GAAG,CAAC,CAAC,IAC3C,gBAAgB,WAAW,IAC3B,OACA,gBAAgB,OAAO,CAAC,CAAC,OAAO,MAAM,YAAY,OAAO,IAAI;AAAA,EACnE;AACF;AAEO,SAAS,SAAS,OAAO,SAAS,YAAY;AACnD,QAAM,WAAW,QAAQ,SAAS,KAAK,IAAI,MAAM,EAAE;AACnD,MAAI;AACJ,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,KAAK,UAAU,KAAK;AAClC,UAAM,CAAC,MAAM,IAAI,QAAQ;AACzB,eAAW,MAAM;AACjB,QAAI,MAAM,UAAU;AAClB,aAAO,WAAW;AAAA,IACpB,OAAO;AACL,mBAAa,WAAW;AACxB,UAAI,CAAC,YAAY;AACf,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,WAAW,KAAK,OAAO,MAAM;AAC3C,MAAI,SAAS,MAAM;AACjB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAGpC,YAAM,CAAC,MAAM,EAAE,IAAI,IAAI,KAAK;AAC5B,UAAI,SAAS,OAAO,SAAS,KAAK;AAChC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AA4DO,SAAS,kBAAkB,QAAQ,OAAO,EAAE,OAAO,WAAW,GAAG;AACtE,KAAG;AACD,QAAI,MAAM,SAAS,GAAG;AACpB,aAAO;AAAA,IACT;AACA,YAAQ,OAAO,MAAM;AAAA,EACvB,SAAS;AAET,SAAO;AACT;AAEO,SAAS,mBACd,QACA,QACA,EAAE,KAAK,OAAO,aAAa,WAAW,GACtC,aAAa,GACb;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,OAAO,GAAG,QAAQ,QAAQ;AAC5B,aAAO,GAAG,QAAQ;AAClB,UAAI,KAAK,IAAI,OAAO,GAAG,MAAM,IAAI,GAAG;AAClC,eAAO,GAAG,gBAAgB;AAAA,MAC5B;AACA,UAAI,YAAY,OAAO,GAAG;AAC1B,UAAI,cAAc,QAAQ,aAAa,QAAQ;AAC7C,eAAO,GAAG,eAAe;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,sBACd,QACA,gBACA,EAAE,OAAO,YAAY,GACrB,aAAa,GACb;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,KAAK,IAAI,OAAO,GAAG,MAAM,MAAM,KAAK,OAAO,GAAG,gBAAgB,gBAAgB;AAChF,aAAO,GAAG,gBAAgB;AAAA,IAC5B;AAAA,EACF;AACF;AAEO,SAAS,mBAAmB,QAAQ,SAAS,KAAK;AACvD,QAAM,YAAY,CAAC;AAEnB;AAAK,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AAC5C,YAAM,SAAS,OAAO,QAAQ,MAAM,GAAG,IAAI,CAAC,GAAG,cAAc;AAC7D,YAAM,WAAW,aAAa,QAAQ,QAAQ,KAAK,iBAAiB;AACpE,YAAM,QAAQ,OAAO;AAErB,UAAI,UAAU,QAAW;AACvB;AAAA,MACF;AAGA,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,cAAM,SAAS,QAAQ,GAAG;AAC1B,cAAM,WAAW,MAAM;AACvB,YAAI,IAAI,GAAG;AACT,cAAI,aAAa,MAAM;AACrB,kBAAM;AAAA,UACR;AAAA,QACF,WAAW,aAAa,IAAI,SAAS;AACnC,gBAAM;AAAA,QACR;AAAA,MACF;AACA,gBAAU,KAAK,QAAQ;AAAA,IACzB;AAEA,SAAO;AACT;AAEO,MAAM,YAAY,CAAC,WAAW,KAAK,SAAS;AACjD,QAAM,IAAI,IAAI,MAAM;AACpB,IAAE,KAAK,OAAO;AACd,IAAE,KAAK,SAAS;AAChB,IAAE,KAAK,SAAS;AAChB,IAAE,KAAK,OAAO,cAAc,WAAW,GAAG;AAC1C,IAAE,KAAK,YAAY;AACnB,SAAO;AACT;AAEA,SAAS,cAAc,SAAS,KAAK;AACnC,QAAM,aAAa,CAAC,CAAC,GAAG,MAAM,IAAI;AAClC,SAAO,QAAQ,IAAI,UAAU,EAAE,KAAK,GAAG;AACzC;AAGO,SAAS,SACd,KACA,OACA,KACA,UACA,WACA,SACA,SACA,WACA,cAAc,CAAC,GACf;AACA,QAAM,EAAE,KAAK,YAAY,OAAO,OAAO,KAAK,UAAU,YAAY,aAAa,MAAM,IACnF,SAAS,OAAO;AAClB,QAAM,QAAQ,MAAM,KAAK;AACzB,QAAM,WAAW,QAAQ,SAAS;AAClC,MAAI;AAEJ,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,SAAS,QAAQ;AACvB,UAAM,MAAM,UAAU,OAAO;AAC7B,QAAI,OAAO,WAAW;AAEpB,YAAM,OAAO;AAAA,IACf,YAAY,SAAS,WAAW,KAAK,OAAO,OAAO,MAAM,UAAU,UAAU;AAC3E,YAAM,OAAO,IAAI;AAAA,IACnB,OAAO;AACL,YAAM,OAAO;AAAA,IACf;AAAA,EACF;AAEA,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,UAAM,CAACA,OAAM,IAAI,YAAY;AAC7B,UAAMA,WAAU,IAAIA;AAAA,EACtB;AAEA,QAAM,aAAa,CAAC,CAACC,IAAG,MAAM,IAAIA;AAClC,QAAM,WAAW,CAACC,aAAYA,SAAQ,IAAI,UAAU,EAAE,KAAK,GAAG;AAE9D,QAAM,UAAU,YAAY,SAAS,IAAI,SAAS,WAAW,IAAI,MAAM;AACvE,QAAM,WAAW,SAAS,QAAQ,MAAM,GAAG,WAAW,CAAC,CAAC;AAExD,QAAM,OAAO;AACb,QAAM,cAAc;AACpB,QAAM,SAAS,CAAC;AAChB,QAAM,SAAS;AACf,QAAM,OAAO,UAAU;AACvB,QAAM,YAAY;AAClB,QAAM,eAAe;AACrB,QAAM,cAAc;AAEpB,SAAO;AACT;AAEO,SAAS,cAAc,SAAS,UAAU,SAAS,WAAW,GAAG,SAAS,QAAQ,QAAQ;AAC/F,QAAM,SAAS,CAAC;AAChB,QAAM,SAAS,QAAQ;AACvB,QAAM,YAAY,SAAS;AAC3B,WAAS,IAAI,UAAU,MAAM,WAAW,QAAQ,IAAI,KAAK,KAAK;AAC5D,UAAM,MAAM,QAAQ;AACpB,UAAM,UAAU,SAAS;AACzB,QAAI,SAAS;AACb,QAAI;AACJ,QAAI;AACJ,aAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AAC3C,YAAM,CAAC,MAAM,IAAI,QAAQ;AACzB,YAAM,QAAQ;AACd,kBAAY,OAAO;AACnB,UAAI,aAAa,UAAU,WAAW;AACpC,kBAAU,KAAK,GAAG;AAAA,MACpB,WAAW,WAAW;AACpB,iBAAS;AAAA,MACX,WAAW,CAAC,aAAa,QAAQ,WAAW;AAC1C,iBAAS,OAAO,OAAO,CAAC;AAAA,MAC1B,WAAW,CAAC,WAAW;AACrB,eAAO,OAAO,CAAC,GAAG;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,6BAA6B,SAAS,QAAQ;AAC5D,QAAM,oBAAoB,WAAW;AACrC,QAAM,YAAY,QAAQ,SAAS;AACnC,QAAM,mBAAmB,CAAC;AAC1B,QAAM,oBAAoB,CAAC;AAE3B,UAAQ,QAAQ,CAAC,KAAK,MAAM;AAC1B,QAAI,IAAI,WAAW;AACjB,uBAAiB,KAAK,GAAG;AAAA,IAC3B,WAAW,IAAI,WAAW;AACxB,wBAAkB,KAAK,GAAG;AAAA,IAC5B;AAAA,EACF,CAAC;AAED,SAAO,CAAC,mBAAmB,kBAAkB,iBAAiB;AAChE;AAEO,SAAS,eAAe,OAAO;AACpC,UAAQ,KAAK,IAAI,KAAK,IAAI,MAAM,QAAQ,IAAI,KAAK;AACnD;AAEO,SAAS,eAAe,OAAO;AACpC,UAAQ,KAAK,IAAI,KAAK,IAAI,MAAM,QAAQ,IAAI,KAAK;AACnD;AAIO,SAAS,iBAAiB,aAAa;AAE5C,QAAM,SAAS;AAAA,IACb,OAAO;AAAA,IACP,KAAK;AAAA,EACP;AAEA,QAAM,eAAe,CAAC;AACtB,QAAM,SAAS,CAAC;AAChB,QAAM,YAAY;AAElB,WAAS,MAAM,GAAG,MAAM,YAAY,QAAQ,OAAO;AACjD,QAAI,MAAM,YAAY;AACtB,QAAI,WAAW,IAAI,OAAO;AAE1B,QAAI,aAAa,GAAG;AAClB,UAAI,QAAQ,CAAC,GAAG;AAChB,aAAO,QAAQ,CAAC,UAAU;AACxB,cAAM,KAAK,MAAM,IAAI,SAAS;AAAA,MAChC,CAAC;AACD,mBAAa,IAAI,OAAO,QAAQ;AAAA,IAClC,OAAO;AACL,aAAO,OAAO,UAAU,KAAK,IAAI,OAAO,OAAO,SAAS,GAAG,EAAE,KAAK,KAAK,IAAI,QAAQ,GAAG;AACpF,eAAO,IAAI;AAAA,MACb;AACA,aAAO,KAAK,CAAC,UAAU,GAAG,CAAC;AAAA,IAC7B;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,sBAAsB,SAAS,WAAW,SAAS;AACjE,SAAO,QAAQ,OAAO,CAAC,cAAc,WAAW;AAC9C,QAAI,OAAO,aAAa,WAAW,OAAO,MAAM,OAAO,MAAM,IAAI;AAC/D,YAAM,MAAM,UAAU,OAAO;AAC7B,mBAAa,KAAK,CAAC,KAAK,OAAO,SAAS,CAAC;AAAA,IAC3C;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,eAAe,QAAQ,QAAQ,SAAS,MAAM,SAAS,cAAc;AACnF,QAAM,EAAE,OAAO,MAAM,IAAI,SAAS,OAAO;AACzC,QAAM,WAAW,OAAO;AACxB,MAAI,QAAQ,SAAS;AACrB,MAAI,WAAW,KAAK,IAAI,KAAK;AAC7B,MAAI,QAAQ;AACZ,MAAI,MAAM;AAIV,SAAO,MAAM,OAAO,SAAS,KAAK,KAAK,IAAI,OAAO,MAAM,GAAG,MAAM,IAAI,UAAU;AAC7E,WAAO;AACP,aAAS;AAAA,EACX;AAEA,WAAS,IAAI,SAAS,OAAO,KAAK,QAAQ,KAAK;AAC7C,aAAS,SAAS,GAAG,SAAS,aAAa,QAAQ,UAAU;AAC3D,YAAM,CAAC,MAAM,IAAI,aAAa;AAC9B,aAAO,GAAG,UAAU;AAAA,IACtB;AACA,cAAU,OAAO,IAAI,QAAQ,SAAS,MAAM,SAAS,cAAc,OAAO,GAAG,MAAM;AAAA,EACrF;AACF;AAEA,SAAS,UACP,UACAC,YACA,SACA,MACA,SACA,cACA,WACA,SAAS,MACT;AACA,QAAM,EAAE,OAAO,OAAO,aAAa,IAAI,SAAS,OAAO;AACvD,QAAM,EAAE,YAAY,IAAI,SAAS,OAAO;AACxC,MAAI,WAAW,KAAK,IAAI,SAAS,MAAM;AACvC,MAAI,QAAQ;AACZ,MAAI,gBAAgB,WAAW,OAAO,SAAY;AAElD,MAAI,aAAa,GAAG;AAElB,QAAI,QAAQ,SAAS;AACrB,QAAI,MAAM,QAAQ;AAClB,YAAQ;AACR,aAAS,IAAI,OAAO,IAAI,KAAK,KAAK;AAChC,YAAM,MAAM,KAAK,QAAQ;AACzB,YAAM,WAAW,WAAW,QAAQ,OAAO,GAAG;AAC9C,UAAI,UAAU,UAAU;AACtB,yBAAiB;AAAA,MACnB;AACA,UAAI,WAAW,QAAQ,UAAU;AAC/B,iBAAS,SAAS,GAAG,SAAS,aAAa,QAAQ,UAAU;AAC3D,gBAAM,CAAC,MAAM,IAAI,aAAa;AAC9B,mBAAS,WAAW,IAAI;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AAIL,UAAM,WAAWA,WAAU,QAAQ,QAAQ,IAAI;AAC/C,aAAS,IAAI,UAAU,IAAIA,WAAU,QAAQ,KAAK;AAChD,YAAM,iBAAiBA,WAAU;AACjC,YAAM,iBAAiB,eAAe;AACtC,YAAM,iBAAiB,eAAe;AACtC,YAAM,oBAAoB,KAAK,IAAI,cAAc;AACjD,UAAI,qBAAqB,UAAU;AACjC;AAAA,MACF,WAAW,sBAAsB,WAAW,GAAG;AAC7C,iBAAS,SAAS,GAAG,SAAS,aAAa,QAAQ,UAAU;AAC3D,gBAAM,CAAC,QAAQ,MAAM,IAAI,aAAa;AACtC,cAAI,WAAW,OAAO;AACpB,qBAAS,WAAW,eAAe,UAAU;AAAA,UAC/C,OAAO;AACL,qBAAS,WAAW,eAAe;AAAA,UACrC;AAAA,QACF;AACA,iBAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAEA,WAAS,SAAS,GAAG,SAAS,aAAa,QAAQ,UAAU;AAC3D,UAAM,CAAC,QAAQ,MAAM,IAAI,aAAa;AACtC,QAAI,WAAW,OAAO;AACpB,eAAS,UAAU,SAAS,UAAU;AAAA,IACxC;AAAA,EACF;AAEA,WAAS,SAAS;AAClB,WAAS,gBAAgB;AAC3B;",
  "names": ["colIdx", "idx", "groupby", "groupRows"]
}
