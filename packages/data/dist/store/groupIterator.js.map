{
  "version": 3,
  "sources": ["../../src/store/groupIterator.ts"],
  "sourcesContent": ["import { getCount } from './groupUtils.js';\nimport {\n  compareRanges,\n  getDeltaRange,\n  getFullRange,\n  NULL_RANGE,\n  RangeFlags\n} from './rangeUtils.js';\n\nconst RANGE_POS_TUPLE_SIZE = 4;\nconst NO_RESULT = [null, null, null];\n\nexport const FORWARDS = 0;\nexport const BACKWARDS = 1;\nexport default function GroupIterator(groups, navSet, data, NAV_IDX, NAV_COUNT, meta) {\n  let _idx = 0;\n  let _grpIdx = null;\n  let _rowIdx = null;\n  let _direction = FORWARDS;\n  let _range = NULL_RANGE;\n  let _range_position_lo = [0, null, null];\n  let _range_positions = [];\n  let _range_position_hi = [null, null, null];\n\n  return {\n    get direction() {\n      return _direction;\n    },\n    get rangePositions() {\n      return _range_positions;\n    },\n    setRange,\n    currentRange,\n    getRangeIndexOfGroup,\n    getRangeIndexOfRow,\n    setNavSet,\n    refresh: currentRange,\n    clear\n  };\n\n  function getRangeIndexOfGroup(grpIdx) {\n    const list = _range_positions;\n    for (let i = 0; i < list.length; i += RANGE_POS_TUPLE_SIZE) {\n      if (list[i + 1] === grpIdx) {\n        if (list[i + 2] === null) {\n          return i / RANGE_POS_TUPLE_SIZE;\n        } else {\n          // first row encountere should be the group, if it\n          // isn't it means it is crolled out of viewport\n          return -1;\n        }\n      }\n    }\n    return -1;\n  }\n\n  function getRangeIndexOfRow(idx) {\n    const list = _range_positions;\n    for (let i = 0; i < list.length; i += RANGE_POS_TUPLE_SIZE) {\n      if (list[i + 3] === idx) {\n        return i / RANGE_POS_TUPLE_SIZE;\n      }\n    }\n    return -1;\n  }\n\n  function clear() {\n    _idx = 0;\n    _grpIdx = null;\n    _rowIdx = null;\n    _direction = FORWARDS;\n    _range = NULL_RANGE;\n    _range_position_lo = [0, null, null];\n    _range_positions = [];\n    _range_position_hi = [null, null, null];\n  }\n\n  function setNavSet([newNavSet, navIdx, navCount]) {\n    navSet = newNavSet;\n    NAV_IDX = navIdx;\n    NAV_COUNT = navCount;\n  }\n\n  function currentRange() {\n    const rows = [];\n    const { IDX } = meta;\n    [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n    if (_idx === 0 && _grpIdx === null && _rowIdx === null) {\n      _idx = -1;\n    }\n    _range_positions.length = 0;\n\n    let startIdx = _idx;\n    let row;\n    let i = _range.lo;\n    do {\n      _direction = FORWARDS;\n      [row, _grpIdx, _rowIdx] = next(\n        groups,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT,\n        meta\n      );\n      if (row) {\n        rows.push(row);\n        _idx += 1;\n        const absRowIdx = _rowIdx === null ? null : row[IDX];\n        _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n        i += 1;\n      }\n    } while (row && i < _range.hi);\n    if (row) {\n      _direction = FORWARDS;\n      const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n      [row, _grpIdx, _rowIdx] = next(\n        groups,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT,\n        meta\n      );\n      _idx += 1;\n      _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n      [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n    } else {\n      _range_position_hi = [null, null, null];\n    }\n\n    return [rows, startIdx + 1];\n  }\n\n  function setRange(range, useDelta = true) {\n    const rangeDiff = compareRanges(_range, range);\n    const { lo: resultLo, hi: resultHi } = useDelta\n      ? getDeltaRange(_range, range)\n      : getFullRange(range);\n    const { IDX } = meta;\n\n    if (rangeDiff === RangeFlags.NULL) {\n      _range_position_lo = [0, null, null];\n      _range_position_hi = [null, null, null];\n      _range_positions.length = 0;\n      return [[], null];\n    } else if (range.lo === _range.lo && useDelta === false) {\n      // when we're asked for the same range again, rebuild the range\n      [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n      _range_positions.length = 0;\n    } else {\n      if (_direction === FORWARDS && rangeDiff & RangeFlags.BWD) {\n        [_idx, _grpIdx, _rowIdx] = _range_positions;\n      } else if (_direction === BACKWARDS && rangeDiff & RangeFlags.FWD) {\n        [_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE);\n        _idx += 1;\n      }\n\n      if (rangeDiff === RangeFlags.FWD) {\n        skip(range.lo - _range.hi, next);\n        _range_positions.length = 0;\n      } else if (rangeDiff === RangeFlags.BWD) {\n        skip(_range.lo - range.hi, previous);\n        _range_positions.length = 0;\n      }\n\n      const loDiff = range.lo - _range.lo;\n      const hiDiff = _range.hi - range.hi;\n      // allow for a range that overshoots data\n      const missingQuota = _range.hi - _range.lo - _range_positions.length / RANGE_POS_TUPLE_SIZE;\n\n      if (loDiff > 0) {\n        const removed = _range_positions.splice(0, loDiff * RANGE_POS_TUPLE_SIZE);\n        if (removed.length) {\n          _range_position_lo = removed.slice(-RANGE_POS_TUPLE_SIZE);\n\n          // experiment - is this A) always correct B) enough\n          if (useDelta === false) {\n            [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n          }\n        }\n      }\n      if (hiDiff > 0) {\n        //TODO allow for scenatio where both lo and HI have changed\n        if (hiDiff > missingQuota) {\n          const absDiff = hiDiff - missingQuota;\n          const removed = _range_positions.splice(\n            -absDiff * RANGE_POS_TUPLE_SIZE,\n            absDiff * RANGE_POS_TUPLE_SIZE\n          );\n          if (removed.length) {\n            _range_position_hi = removed.slice(0, RANGE_POS_TUPLE_SIZE);\n          }\n        }\n      }\n    }\n\n    const rows = [];\n    let row;\n    let startIdx = null;\n\n    if ((rangeDiff & RangeFlags.REDUCE) === 0) {\n      if (rangeDiff & RangeFlags.FWD || rangeDiff === RangeFlags.SAME) {\n        let i = resultLo;\n        startIdx = _idx;\n        do {\n          _direction = FORWARDS;\n          [row, _grpIdx, _rowIdx] = next(\n            groups,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT,\n            meta\n          );\n          if (row) {\n            rows.push(row);\n            const absRowIdx = _rowIdx === null ? null : row[IDX];\n            _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n            i += 1;\n            _idx += 1;\n          }\n        } while (row && i < resultHi);\n        if (row) {\n          _direction = FORWARDS;\n          const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n          [row, _grpIdx, _rowIdx] = next(\n            groups,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT,\n            meta\n          );\n          _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n          [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n        } else {\n          _range_position_hi = [null, null, null];\n        }\n      } else {\n        let i = resultHi - 1;\n        do {\n          _direction = BACKWARDS;\n          [row, _grpIdx, _rowIdx] = previous(\n            groups,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT,\n            meta\n          );\n          if (row) {\n            _idx -= 1;\n            rows.unshift(row);\n            const absRowIdx = _rowIdx === null ? null : row[IDX];\n            _range_positions.unshift(_idx, _grpIdx, _rowIdx, absRowIdx);\n            i -= 1;\n          }\n        } while (row && i >= resultLo);\n        startIdx = _idx;\n        if (row) {\n          const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n          _direction = BACKWARDS;\n          [row, _grpIdx, _rowIdx] = previous(\n            groups,\n            data,\n            _grpIdx,\n            _rowIdx,\n            navSet,\n            NAV_IDX,\n            NAV_COUNT,\n            meta\n          );\n          _range_position_lo = [row ? _idx - 1 : 0, _grpIdx, _rowIdx];\n          [_grpIdx, _rowIdx] = [grpIdx, rowIdx];\n        } else {\n          _range_position_lo = [0, null, null];\n        }\n      }\n    } else {\n      // reduced range, adjust the current pos. DIrection can only be a guess, but if it's wrong\n      // the appropriate adjustment will be made nest time range is set\n      if (rangeDiff & RangeFlags.FWD) {\n        console.log(`adjust thye idx`);\n        [_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE);\n        _idx += 1;\n      } else {\n        [_idx, _grpIdx, _rowIdx] = _range_positions;\n      }\n    }\n\n    _range = range;\n    return [rows, startIdx];\n  }\n\n  function skip(n, fn) {\n    let i = 0;\n    let row;\n\n    do {\n      [row, _grpIdx, _rowIdx] = fn(\n        groups,\n        data,\n        _grpIdx,\n        _rowIdx,\n        navSet,\n        NAV_IDX,\n        NAV_COUNT,\n        meta\n      );\n      if (fn === next) {\n        _idx += 1;\n      } else {\n        _idx -= 1;\n      }\n      i += 1;\n    } while (row && i < n);\n    if (fn === next) {\n      _range_position_lo = [_idx - 1, _grpIdx, _rowIdx];\n    } else {\n      _range_position_hi = [_idx, _grpIdx, _rowIdx];\n    }\n  }\n}\n\nfunction getAbsRowIdx(group, relRowIdx, navSet, NAV_IDX) {\n  return navSet[group[NAV_IDX] + relRowIdx];\n}\n\nfunction next(groups, rows, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta) {\n  if (grpIdx === null) {\n    grpIdx = -1;\n    do {\n      grpIdx += 1;\n    } while (grpIdx < groups.length && getCount(groups[grpIdx], NAV_COUNT) === 0);\n\n    if (grpIdx >= groups.length) {\n      return NO_RESULT;\n    } else {\n      return [groups[grpIdx], grpIdx, null];\n    }\n  } else if (grpIdx >= groups.length) {\n    return NO_RESULT;\n  } else {\n    let groupRow = groups[grpIdx];\n    const depth = groupRow[meta.DEPTH];\n    const count = getCount(groupRow, NAV_COUNT);\n    // Note: we're unlikely to be passed the row if row count is zero\n    if (depth === 1 && count !== 0 && (rowIdx === null || rowIdx < count - 1)) {\n      rowIdx = rowIdx === null ? 0 : rowIdx + 1;\n      const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX);\n      // the equivalent of project row\n      const row = rows[absRowIdx].slice();\n      row[meta.IDX] = absRowIdx;\n      row[meta.RENDER_IDX] = 0;\n      row[meta.DEPTH] = 0;\n      row[meta.COUNT] = 0;\n      row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n      return [row, grpIdx, rowIdx === null ? 0 : rowIdx];\n    } else if (depth > 0) {\n      do {\n        grpIdx += 1;\n      } while (grpIdx < groups.length && getCount(groups[grpIdx], NAV_COUNT) === 0);\n      if (grpIdx >= groups.length) {\n        return NO_RESULT;\n      } else {\n        return [groups[grpIdx], grpIdx, null];\n      }\n    } else {\n      const absDepth = Math.abs(depth);\n      do {\n        grpIdx += 1;\n      } while (\n        grpIdx < groups.length &&\n        (Math.abs(groups[grpIdx][meta.DEPTH]) < absDepth ||\n          getCount(groups[grpIdx], NAV_COUNT) === 0)\n      );\n      if (grpIdx >= groups.length) {\n        return NO_RESULT;\n      } else {\n        return [groups[grpIdx], grpIdx, null];\n      }\n    }\n  }\n}\n\nfunction previous(groups, data, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta) {\n  if (grpIdx !== null && groups[grpIdx][meta.DEPTH] === 1 && typeof rowIdx === 'number') {\n    let lastGroup = groups[grpIdx];\n    if (rowIdx === 0) {\n      return [lastGroup, grpIdx, null];\n    } else {\n      rowIdx -= 1;\n      const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX);\n      const row = data[absRowIdx].slice();\n      // row[meta.IDX] = idx;\n      row[meta.RENDER_IDX] = 0; // is this right ?\n      row[meta.DEPTH] = 0;\n      row[meta.COUNT] = 0;\n      row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n      return [row, grpIdx, rowIdx];\n    }\n  } else {\n    if (grpIdx === null) {\n      grpIdx = groups.length - 1;\n    } else if (grpIdx === 0) {\n      return NO_RESULT;\n    } else {\n      grpIdx -= 1;\n    }\n    let lastGroup = groups[grpIdx];\n    if (lastGroup[meta.DEPTH] === 1) {\n      rowIdx = getCount(lastGroup, NAV_COUNT) - 1;\n      const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX);\n      const row = data[absRowIdx].slice();\n      row[meta.RENDER_IDX] = 0; // is tis right ?\n      row[meta.DEPTH] = 0;\n      row[meta.COUNT] = 0;\n      row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n      return [row, grpIdx, rowIdx];\n    }\n    while (\n      lastGroup[meta.PARENT_IDX] !== null &&\n      groups[lastGroup[meta.PARENT_IDX]][meta.DEPTH] < 0\n    ) {\n      grpIdx = lastGroup[meta.PARENT_IDX];\n      lastGroup = groups[grpIdx];\n    }\n    return [lastGroup, grpIdx, null];\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
