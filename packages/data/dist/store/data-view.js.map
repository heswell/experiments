{
  "version": 3,
  "sources": ["../../src/store/data-view.ts"],
  "sourcesContent": ["import { buildColumnMap, getFilterType, toColumn } from './columnUtils.js';\nimport { addFilter, IN, NOT_IN } from './filter.js';\nimport { resetRange } from './rangeUtils.js';\nimport { GroupRowSet, RowSet } from './rowset/index.js';\nimport { DataTypes } from './types.js';\nimport UpdateQueue from './update-queue.js';\n\nconst DEFAULT_INDEX_OFFSET = 100;\nconst WITH_STATS = true;\nexport default class DataView {\n  constructor(\n    table,\n    { columns = [], sort = null, groupBy = null, filterSpec = null },\n    updateQueue = new UpdateQueue()\n  ) {\n    this._table = table;\n    this._index_offset = DEFAULT_INDEX_OFFSET;\n    this._filter = filterSpec;\n    this._groupState = null;\n    this._sortCriteria = sort;\n\n    this._columns = null;\n    this._columnMap = null;\n    // column defs come from client, this is where we assign column keys\n    this.columns = columns;\n\n    this._groupby = groupBy;\n    this._update_queue = updateQueue;\n    // TODO we should pass columns into the rowset as it will be needed for computed columns\n    this.rowSet = new RowSet(table, this._columns, this._index_offset);\n    // Is one filterRowset enough, or should we manage one for each column ?\n    this.filterRowSet = null;\n\n    // What if data is BOTH grouped and sorted ...\n    if (groupBy !== null) {\n      // more efficient to compute this directly from the table projection\n      this.rowSet = new GroupRowSet(this.rowSet, this._columns, this._groupby, this._groupState);\n    } else if (this._sortCriteria !== null) {\n      this.rowSet.sort(this._sortCriteria);\n    }\n\n    this.rowUpdated = this.rowUpdated.bind(this);\n    this.rowInserted = this.rowInserted.bind(this);\n\n    table.on('rowUpdated', this.rowUpdated);\n    table.on('rowInserted', this.rowInserted);\n  }\n\n  // Set the columns from client\n  set columns(columns) {\n    this._columns = columns.map(toColumn);\n    this._columnMap = buildColumnMap(this._columns);\n  }\n\n  destroy() {\n    this._table.removeListener('rowUpdated', this.rowUpdated);\n    this._table.removeListener('rowInserted', this.rowInserted);\n    this._table = null;\n    this.rowSet = null;\n    this.filterRowSet = null;\n    this._update_queue = null;\n  }\n\n  get status() {\n    return this._table.status;\n  }\n\n  rowInserted(event, idx, row) {\n    const { _update_queue, rowSet } = this;\n    const { size = null, replace, updates } = rowSet.insert(idx, row);\n    if (size !== null) {\n      _update_queue.resize(size);\n    }\n    if (replace) {\n      const { rows, size, offset } = rowSet.currentRange();\n      _update_queue.replace({ rows, size, offset });\n    } else if (updates) {\n      updates.forEach((update) => {\n        _update_queue.update(update);\n      });\n    }\n    // what about offset change only ?\n  }\n\n  rowUpdated(event, idx, updates) {\n    const { rowSet, _update_queue } = this;\n    const result = rowSet.update(idx, updates);\n\n    if (result) {\n      if (rowSet instanceof RowSet) {\n        _update_queue.update(result);\n      } else {\n        result.forEach((rowUpdate) => {\n          _update_queue.update(rowUpdate);\n        });\n      }\n    }\n  }\n\n  getData(dataType) {\n    return dataType === DataTypes.ROW_DATA\n      ? this.rowSet\n      : dataType === DataTypes.FILTER_DATA\n      ? this.filterRowSet\n      : null;\n  }\n\n  //TODO we seem to get a setRange when we reverse sort order, is that correct ?\n  setRange(range, useDelta = true, dataType = DataTypes.ROW_DATA) {\n    return this.getData(dataType).setRange(range, useDelta);\n  }\n\n  select(idx, rangeSelect, keepExistingSelection, dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    const updates = rowset.select(idx, rangeSelect, keepExistingSelection);\n    if (dataType === DataTypes.ROW_DATA) {\n      return this.selectResponse(updates, dataType, rowset);\n    } else {\n      console.log(`[dataView] select on filterSet (range ${JSON.stringify(rowset.range)})`);\n      // we need to handle this case here, as the filter we construct depends on the selection details\n      // TODO we shouldn't be using the sortSet here, need an API method\n      const value = rowset.getSelectedValue(idx);\n      const isSelected = rowset.selected.rows.includes(idx);\n      const filter = {\n        type: isSelected ? IN : NOT_IN,\n        colName: rowset.columnName,\n        values: [value]\n      };\n      this.applyFilterSetChangeToFilter(filter);\n\n      if (updates.length > 0) {\n        return {\n          dataType,\n          updates,\n          stats: rowset.stats\n        };\n      }\n    }\n  }\n\n  selectAll(dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    return this.selectResponse(rowset.selectAll(), dataType, rowset, true);\n  }\n\n  selectNone(dataType = DataTypes.ROW_DATA) {\n    const rowset = this.getData(dataType);\n    return this.selectResponse(rowset.selectNone(), dataType, rowset, false);\n  }\n\n  // Handle response to a selecAll / selectNode operation. This may be operating on\n  // the entire resultset, or a filtered subset\n  selectResponse(updates, dataType, rowset, allSelected) {\n    const updatesInViewport = updates.length > 0;\n    const { stats } = rowset;\n    if (dataType === DataTypes.ROW_DATA) {\n      if (updatesInViewport) {\n        return { updates };\n      }\n    } else {\n      const { totalRowCount, totalSelected } = stats;\n\n      // Maybe defer the filter operation ?\n      if (totalSelected === 0) {\n        this.applyFilterSetChangeToFilter({ colName: rowset.columnName, type: IN, values: [] });\n      } else if (totalSelected === totalRowCount) {\n        this.applyFilterSetChangeToFilter({ colName: rowset.columnName, type: NOT_IN, values: [] });\n      } else {\n        // we are not operating on the whole dataset, therefore it is a filtered subset\n        if (allSelected) {\n          this.applyFilterSetChangeToFilter({\n            colName: rowset.columnName,\n            type: IN,\n            values: rowset.values\n          });\n        } else {\n          this.applyFilterSetChangeToFilter({\n            colName: rowset.columnName,\n            type: NOT_IN,\n            values: rowset.values\n          });\n        }\n      }\n\n      // always return, as the stats might be needed\n      // if (updatesInViewport){\n      return {\n        dataType,\n        updates,\n        stats: rowset.stats\n      };\n      // }\n    }\n  }\n\n  sort(sortCriteria) {\n    this._sortCriteria = sortCriteria;\n    this.rowSet.sort(sortCriteria);\n    // assuming the only time we would not useDelta is when we want to reset ?\n    return this.setRange(resetRange(this.rowSet.range), false);\n  }\n\n  // filter may be called directly from client, in which case changes should be propagated, where\n  // appropriate, to any active filterSet(s). However, if the filterset has been changed, e.g. selection\n  // within a set, then filter applied here in consequence must not attempt to reset the same filterSet\n  // that originates the change.\n  filter(filter, dataType = DataTypes.ROW_DATA, incremental = false, ignoreFilterRowset = false) {\n    if (dataType === DataTypes.FILTER_DATA) {\n      return [undefined, this.filterFilterData(filter)];\n    } else {\n      if (incremental) {\n        filter = addFilter(this._filter, filter);\n      }\n      const { rowSet, _filter, filterRowSet } = this;\n      const { range } = rowSet;\n      this._filter = filter;\n      let filterResultset;\n\n      if (filter === null && _filter) {\n        rowSet.clearFilter();\n      } else if (filter) {\n        this.rowSet.filter(filter);\n      } else {\n        throw Error(`InMemoryView.filter setting null filter when we had no filter anyway`);\n      }\n\n      if (filterRowSet && dataType === DataTypes.ROW_DATA && !ignoreFilterRowset) {\n        if (filter) {\n          if (filterRowSet.type === DataTypes.FILTER_DATA) {\n            filterResultset = filterRowSet.setSelectedFromFilter(filter);\n          } else if (filterRowSet.type === DataTypes.FILTER_BINS) {\n            this.filterRowSet = rowSet.getBinnedValuesForColumn({\n              name: this.filterRowSet.columnName\n            });\n            filterResultset = this.filterRowSet.setRange();\n          }\n        } else {\n          // TODO examine this. Must be a more efficient way to reset counts in filterRowSet\n          const { columnName, range } = filterRowSet;\n          this.filterRowSet = rowSet.getDistinctValuesForColumn({ name: columnName });\n          filterResultset = this.filterRowSet.setRange(range, false);\n        }\n      }\n\n      const resultSet = {\n        ...this.rowSet.setRange(resetRange(range), false),\n        filter\n      };\n\n      return filterResultset ? [resultSet, filterResultset] : [resultSet];\n    }\n  }\n\n  //TODO merge with method above\n  filterFilterData(filter) {\n    const { filterRowSet } = this;\n    if (filterRowSet) {\n      if (filter === null) {\n        filterRowSet.clearFilter();\n      } else if (filter) {\n        filterRowSet.filter(filter);\n      }\n\n      return filterRowSet.setRange(resetRange(filterRowSet.range), false, WITH_STATS);\n    } else {\n      console.error(`[InMemoryView] filterfilterRowSet no filterRowSet`);\n    }\n  }\n\n  applyFilterSetChangeToFilter(partialFilter) {\n    const [result] = this.filter(partialFilter, DataTypes.ROW_DATA, true, true);\n    this._update_queue.replace(result);\n  }\n\n  applyFilter() {}\n\n  groupBy(groupby) {\n    const { rowSet, _columns, _groupState, _sortCriteria, _groupby } = this;\n    const { range: _range } = rowSet;\n    this._groupby = groupby;\n\n    if (groupby === null) {\n      this.rowSet = RowSet.fromGroupRowSet(this.rowSet);\n    } else {\n      if (_groupby === null) {\n        this.rowSet = new GroupRowSet(rowSet, _columns, groupby, _groupState, _sortCriteria);\n      } else {\n        rowSet.groupBy(groupby);\n      }\n    }\n    return this.rowSet.setRange(_range, false);\n  }\n\n  setGroupState(groupState) {\n    this._groupState = groupState;\n    const { rowSet } = this;\n    rowSet.setGroupState(groupState);\n    // TODO should we have setRange return the following directly, so IMV doesn't have to decide how to call setRange ?\n    // should we reset the range ?\n    return rowSet.setRange(rowSet.range, false);\n  }\n\n  get updates() {\n    const {\n      _update_queue,\n      rowSet: { range }\n    } = this;\n    let results = {\n      updates: _update_queue.popAll(),\n      range: {\n        lo: range.lo,\n        hi: range.hi\n      }\n    };\n    return results;\n  }\n\n  getFilterData(column, range) {\n    console.log(`dataView.getFilterData for column ${column.name} range ${JSON.stringify(range)}`);\n    const { rowSet, filterRowSet, _filter: filter, _columnMap } = this;\n    // If our own dataset has been filtered by the column we want values for, we cannot use it, we have\n    // to go back to the source, using a filter which excludes the one in place on the target column.\n    const columnName = column.name;\n    const colDef = this._columns.find((col) => col.name === columnName);\n    // No this should be decided beforehand (on client)\n    const type = getFilterType(colDef);\n\n    if (type === 'number') {\n      // // we need a notification from server to tell us when this is closed.\n      // we should assign to filterRowset\n      this.filterRowSet = rowSet.getBinnedValuesForColumn(column);\n    } else if (!filterRowSet || filterRowSet.columnName !== column.name) {\n      console.log(`create the filterRowset`);\n      this.filterRowSet = rowSet.getDistinctValuesForColumn(column);\n    } else if (filterRowSet && filterRowSet.columnName === column.name) {\n      // if we already have the data for this filter, nothing further to do except reset the filterdata range\n      // so next request will return full dataset.\n      filterRowSet.setRange({ lo: 0, hi: 0 });\n    }\n    // If we already have a filterRowset for this column, but a filter on another column has changed, we need to\n    // recreate the filterRowset: SHould this happen when filter happens ?\n\n    if (filter) {\n      this.filterRowSet.setSelectedFromFilter(filter);\n    } else {\n      this.filterRowSet.selectAll();\n    }\n\n    // do we need to returtn searchText ? If so, it should\n    // be returned by the rowSet\n\n    // TODO wrap this, we use it  alot\n    console.log(`[dataView] return filterSet range ${JSON.stringify(range)}`);\n    return this.filterRowSet.setRange(range, false, WITH_STATS);\n  }\n}\n"],
  "mappings": "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",
  "names": ["size", "range"]
}
