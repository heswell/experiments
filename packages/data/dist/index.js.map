{"version":3,"file":"index.js","sources":["../src/store/filter.js","../src/store/columnUtils.js","../src/store/types.js","../src/store/sort.js","../src/store/rangeUtils.js","../src/store/groupUtils.js","../src/store/rowUtils.js","../src/store/table.js","../src/store/selection-model.js","../src/store/rowset/rowSet.js","../src/store/groupIterator.js","../src/store/rowset/group-rowset.js","../src/store/updateQueue.js","../src/store/DataView.js","../src/store/localUpdateQueue.js","../src/view/local-data-view.js","../src/view/binned-data-view.js","../src/view/filter-data-view.js","../index.js"],"sourcesContent":["import * as d3 from 'd3-array';\n\nexport const EQUALS = 'EQ';\nexport const GREATER_THAN = 'GT';\nexport const GREATER_EQ = 'GE';\nexport const LESS_THAN = 'LT';\nexport const LESS_EQ = 'LE';\nexport const AND = 'AND';\nexport const OR = 'OR';\nexport const STARTS_WITH = 'SW';\nexport const NOT_STARTS_WITH = 'NOT_SW';\nexport const IN = 'IN';\nexport const NOT_IN = 'NOT_IN';\n\nexport const SET_FILTER_DATA_COLUMNS = [\n    {name: 'name'}, \n    {name: 'count', width: 40}, \n    {name: 'totalCount', width: 40}\n];\n\nexport const BIN_FILTER_DATA_COLUMNS = [\n    {name: 'bin'}, \n    {name: 'count'}, \n    {name: 'bin-lo'},\n    {name: 'bin-hi'}\n];\nexport default function filterRows(rows, columnMap, filter) {\n    return applyFilter(rows, functor(columnMap, filter));\n}\n\n\nexport function getFilterColumn(column) {\n    return column.isGroup ? column.columns[0] : column;\n}\nexport function functor(columnMap, filter) {\n    //TODO convert filter to include colIdx ratherthan colName, so we don't have to pass cols\n    switch (filter.type) {\n    case IN: return testInclude(columnMap, filter);\n    case NOT_IN: return testExclude(columnMap, filter);\n    case EQUALS: return testEQ(columnMap, filter);\n    case GREATER_THAN: return testGT(columnMap, filter);\n    case GREATER_EQ: return testGE(columnMap, filter);\n    case LESS_THAN: return testLT(columnMap, filter);\n    case LESS_EQ: return testLE(columnMap, filter);\n    case STARTS_WITH: return testSW(columnMap, filter);\n    case NOT_STARTS_WITH: return testSW(columnMap, filter, true);\n    case AND: return testAND(columnMap, filter);\n    case OR: return testOR(columnMap, filter);\n    default:\n        console.log(`unrecognized filter type ${filter.type}`);\n        return () => true;\n    }\n}\n\nfunction applyFilter(rows, filter) {\n    const results = [];\n    for (let i = 0; i < rows.length; i++) {\n        if (filter(rows[i])) {\n            results.push(rows[i]);\n        }\n    }\n    return results;\n}\n\nfunction testAND(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.every(fn => fn(row));\n}\n\nfunction testOR(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.some(fn => fn(row));\n}\n\nfunction testSW(cols, f, inversed = false) {\n    const value = f.value.toLowerCase();\n    return inversed\n        ? row => row[cols[f.colName]].toLowerCase().indexOf(value) !== 0\n        : row => row[cols[f.colName]].toLowerCase().indexOf(value) === 0;\n   \n}\n\nfunction testGT(cols, f) {\n    return row => row[cols[f.colName]] > f.value;\n}\n\nfunction testGE(cols, f) {\n    return row => row[cols[f.colName]] >= f.value;\n}\n\nfunction testLT(cols, f) {\n    return row => row[cols[f.colName]] < f.value;\n}\n\nfunction testLE(cols, f) {\n    return row => row[cols[f.colName]] <= f.value;\n}\n\nfunction testInclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) !== -1;\n}\n\n// faster to convert values to a keyed map\nfunction testExclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) === -1;\n}\n\nfunction testEQ(cols, f) {\n    return row => row[cols[f.colName]] === f.value;\n}\n\nexport function shouldShowFilter(filterColumnName, column) {\n    const filterColumn = getFilterColumn(column);\n    if (filterColumn.isGroup) {\n        return filterColumn.columns.some(col => col.name === filterColumnName);\n    } else {\n        return filterColumnName === filterColumn.name;\n    }\n}\n\nexport function includesNoValues(filter) {\n    // TODO make sure we catch all cases...\n    if (!filter){\n        return false;\n    } else if (filter.type === IN && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === AND && filter.filters.some(f => includesNoValues(f))){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction includesAllValues(filter) {\n    if (!filter){\n        return false;\n    } else if (filter.type === NOT_IN && filter.values.length === 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// does f2 only narrow the resultset from f1\nexport function extendsFilter(f1=null, f2=null) {\n    // ignore filters which are identical\n    // include or exclude filters which add values\n    if (f2 === null){\n        return false\n    } else if (f1 === null) {\n        return true;\n    }\n    if (f1.colName && f1.colName === f2.colName) {\n        if (f1.type === f2.type) {\n            switch (f1.type) {\n            case IN:\n                return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n            case NOT_IN: \n                return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n            case STARTS_WITH: return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n                // more cases here such as GT,LT\n            default:\n            }\n        }\n\n    } else if (f1.colname && f2.colName) {\n        // different columns,always false\n        return false;\n    } else if (f2.type === AND && extendsFilters(f1, f2)) {\n        return true;\n    }\n\n    // safe option is to assume false, causing filter to be re-applied to base data\n    return false;\n}\n\nconst byColName = (a, b) => a.colName === b.colName ? 0 : a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1, f2) {\n    if (f1.colName) {\n        const matchingFilter = f2.filters.find(f => f.colName === f1.colName);\n        return filterEquals(matchingFilter, f1, true);\n    } else if (f1.filters.length === f2.filters.length) {\n        // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n        // then we are still extending the filter (i.e. narrowing the resultset)\n        const a = f1.filters.sort(byColName);\n        const b = f2.filters.slice().sort(byColName);\n\n        for (let i = 0; i < a.length; i++) {\n            if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (f2.filters.length > f1.filters.length){\n        return f1.filters.every(filter1 => {\n            const filter2 = f2.filters.find(f => f.colName === filter1.colName);\n            return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n        });\n    }\n}\n\nexport function addFilter(existingFilter, filter) {\n\n    if (includesNoValues(filter)){\n        const {colName} = filter;\n        existingFilter = removeFilterForColumn(existingFilter, {name:colName});\n    } else if (includesAllValues(filter)){\n        // A filter that returns all values is a way to remove filtering for this column \n        return removeFilterForColumn(existingFilter, {name: filter.colName});\n    }\n\n    if (!existingFilter) {\n        return filter;\n    } else if (!filter) {\n        return existingFilter;\n    }\n   \n    if (existingFilter.type === AND && filter.type === AND) {\n        return { type: 'AND', filters: combine(existingFilter.filters, filter.filters) };\n    } else if (existingFilter.type === 'AND') {\n        const filters = replaceOrInsert(existingFilter.filters, filter);\n        return filters.length > 1\n            ? { type: 'AND', filters  }\n            : filters[0];\n    } else if (filter.type === 'AND') {\n        return { type: 'AND', filters: filter.filters.concat(existingFilter) };\n    } else if (filterEquals(existingFilter, filter, true)) {\n        return filter;\n    } else if (sameColumn(existingFilter, filter)){\n        return merge(existingFilter, filter);\n    } else {\n        return { type: 'AND', filters: [existingFilter, filter] };\n    }\n}\n\n// If we add an IN filter and there is an existing NOT_IN, we would always expect the IN\n// values to exist in the NOT_IN set (as long as user interaction is driving the filtering)\nfunction replaceOrInsert(filters, filter) {\n    const {type, colName, values} = filter;\n    if (type === IN) {\n        // see if we have a NOT_IN entry\n        let idx = filters.findIndex(f => f.type === NOT_IN && f.colName === colName);\n        if (idx !== -1){\n            const {values: existingValues} = filters[idx];\n            if (values.every(value => existingValues.indexOf(value) !== -1)){\n                if (values.length === existingValues.length){\n                    // we simply remove the existing NOT_IN filter ...\n                    return filters.filter((f, i) => i !== idx);\n                } else {\n                    // ... or strip the IN values from the NOT_IN values\n                    let newValues = existingValues.filter(value => !values.includes(value));\n                    return filters.map((filter,i) => i === idx ? {...filter, values: newValues}: filter)\n\n                }\n            }\n            else if (values.some(value => existingValues.indexOf(value) !== -1)){\n                console.log(`partial overlap between IN and NOT_IN`)\n\n            }\n        }\n\n\n        idx = filters.findIndex(f => f.type === IN && f.colName === filter.colName);\n        if (idx !== -1) {\n            return filters.map((f, i) => i === idx ? merge(f, filter) : f);\n        }\n    }\n\n    return filters.concat(filter);\n}\n\nfunction merge(f1, f2){\n    const {type: t1} = f1;\n    const {type: t2} = f2;      \n    const sameType = t1 === t2 ? t1 : '';\n\n    if (includesNoValues(f2)){\n        return f2;\n    } else if ((t1 === IN && t2 === NOT_IN) || (t1 === NOT_IN && t2 === IN)){\n        // do the two sets cancel each other out ?\n        if (f1.values.length === f2.values.length && f1.values.every(v => f2.values.includes(v))){  \n            // DOn't think this is right\n            return null;\n        } else if (t1 === NOT_IN){\n            if (f2.values.every(v => f1.values.includes(v))){\n                return {\n                    ...f1,\n                    values: f1.values.filter(v => !f2.values.includes(v))\n                }\n            }\n        }\n    } else if (sameType === IN || sameType === NOT_IN){\n        return {\n            ...f1,\n            values: f1.values.concat(f2.values.filter(v => !f1.values.includes(v)))\n        }\n    } else if (sameType === STARTS_WITH){\n        return {\n            type: OR,\n            filters: [f1, f2]\n        }\n    } else if (sameType === NOT_STARTS_WITH){\n        return {\n            type: AND,\n            filters: [f1, f2]\n        }\n\n    }\n\n    return f2;\n\n}\n\nfunction combine(existingFilters, replacementFilters) {\n\n    // TODO need a safer REGEX here\n    function equivalentType({ type: t1 }, { type: t2 }) {\n        return (t1 === t2) || (t1[0] === t2[0]);\n    }\n\n    const replaces = (existingFilter, replacementFilter) => {\n        return existingFilter.colName === replacementFilter.colName &&\n            equivalentType(existingFilter, replacementFilter);\n    };\n\n    const stillApplicable = existingFilter => replacementFilters.some(\n        replacementFilter => replaces(existingFilter, replacementFilter)) === false;\n\n    return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nexport function removeFilter(sourceFilter, filterToRemove) {\n    if (filterEquals(sourceFilter, filterToRemove, true)) {\n        return null;\n    } else if (sourceFilter.type !== AND) {\n        throw Error(`removeFilter cannot remove ${JSON.stringify(filterToRemove)} from ${JSON.stringify(sourceFilter)}`);\n    } else {\n        const filters = sourceFilter.filters.filter(f => !filterEquals(f, filterToRemove));\n        return filters.length > 0 ? { type: AND, filters } : null;\n    }\n}\n\nexport function splitFilterOnColumn(filter, columnName) {\n    if (!filter){\n        return [null,null];\n    } else if (filter.colName === columnName) {\n        return [filter,null];\n    } else if (filter.type !== 'AND') {\n        return [null, filter];\n    } else {\n        const [[columnFilter=null], filters] = partition(filter.filters, f => f.colName === columnName);\n        return filters.length === 1\n            ? [columnFilter,filters[0]]\n            : [columnFilter, { type: 'AND', filters }];\n    }\n}\n\nexport const overrideColName = (filter, colName) => {\n    const {type} = filter;\n    if (type === AND || type === OR){\n        return {\n            type,\n            filters: filter.filters.map(f => overrideColName(f, colName))\n        }\n    } else {\n        return {...filter, colName}\n    }\n}\n\nexport function extractFilterForColumn(filter, columnName) {\n    if (!filter) {\n        return null;\n    }\n    const { type, colName } = filter;\n    switch (type) {\n        case AND: \n        case OR: \n            return collectFiltersForColumn(type, filter.filters, columnName);\n\n        default:\n            return colName === columnName ? filter : null;\n    }\n}\n\nfunction collectFiltersForColumn(type, filters, columName){\n    const results = [];\n    filters.forEach(filter => {\n        const ffc = extractFilterForColumn(filter, columName);\n        if (ffc !== null){\n            results.push(ffc);\n        }\n    })\n    if (results.length === 1){\n        return results[0];\n    } else {\n        return {\n            type,\n            filters: results\n        }\n    }\n}\n\nexport function includesColumn(filter, column) {\n    if (!filter) {\n        return false;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case AND: return filters.some(f => includesColumn(f, column));\n    default: return colName === column.name;\n    }\n}\n\nexport function removeFilterForColumn(sourceFilter, column) {\n    const colName = column.name;\n    if (!sourceFilter){\n        return null;\n    } else if (sourceFilter.colName === colName) {\n        return null;\n    } else if (sourceFilter.type === AND || sourceFilter.type === OR) {\n        const {type, filters} = sourceFilter;\n        const otherColFilters = filters.filter(f => f.colName !== colName);\n        switch(otherColFilters.length){\n            case 0: return null;\n            case 1: return otherColFilters[0];\n            default: return { type, otherColFilters } \n        }\n    } else {\n        return sourceFilter;\n    }\n}\n\nconst sameColumn = (f1, f2) => f1.colName === f2.colName;\n\nexport function filterEquals(f1, f2, strict = false) {\n    if (f1 && f1){\n        const isSameColumn = sameColumn(f1,f2);\n        if (!strict) {\n            return isSameColumn;\n        } else {\n            return isSameColumn &&\n                f1.type === f2.type && \n                f1.mode === f2.mode &&\n                f1.value === f2.value &&\n                sameValues(f1.values, f2.values);\n        }\n    } else {\n        return false;\n    }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1, f2) {\n    if (f1.type === IN && f2.type === IN) {\n        return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n    } else if (f1.type === NOT_IN && f2.type === NOT_IN) {\n        return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n    } else {\n        return false;\n    }\n}\n\n//TODO roll this into next function\nexport function projectFilterData(filterRows) {\n    return filterRows.map((row, idx) => [idx, 0, 0, null, row.name, row.count]);\n}\n\nexport function getBinnedValues(rows, key, numberOfBins = 20) {\n    const numbers = rows.map(row => row[key]);\n    // const start = performance.now();\n    const values = d3.histogram().thresholds(numberOfBins)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n    // const end = performance.now();\n    // onsole.log(`%ctook ${end - start} ms to build histogram`, 'font-weight:bold;color:red;');\n    // onsole.log(values);\n    return values;\n\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll(superList, subList) {\n    for (let i = 0, len = subList.length; i < len; i++) {\n        if (superList.indexOf(subList[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues(arr1, arr2) {\n    if (arr1 === arr2) {\n        return true;\n    } else if (arr1.length === arr2.length) {\n        const a = arr1.slice().sort();\n        const b = arr2.slice().sort();\n        return a.join('|') === b.join('|');\n    }\n    return false;\n}\n\nexport function partition(list, test1, test2=null) {\n    const results1 = [];\n    const misses = [];\n    const results2 = test2===null ? null : [];\n\n    for (let i = 0; i < list.length; i++) {\n        if (test1(list[i])) {\n            results1.push(list[i]);\n        } else if (test2 !== null && test2(list[i])) {\n            results2.push(list[i]);\n        } else {\n            misses.push(list[i]);\n        }\n    }\n\n    return test2 === null\n        ? [results1, misses]\n        : [results1, results2, misses];\n}\n","import {\n    functor, \n    overrideColName, \n    SET_FILTER_DATA_COLUMNS, \n    BIN_FILTER_DATA_COLUMNS} from './filter';\n\nconst SORT_ASC = 'asc';\n\nexport const setFilterColumnMeta = metaData(SET_FILTER_DATA_COLUMNS)\nexport const binFilterColumnMeta = metaData(BIN_FILTER_DATA_COLUMNS)\n\nexport function mapSortCriteria(sortCriteria, columnMap) {\n    return sortCriteria.map(s => {\n        if (typeof s === 'string') {\n            return [columnMap[s], 'asc'];\n        } else if (Array.isArray(s)) {\n            const [columnName, sortDir] = s;\n            return [columnMap[columnName], sortDir || SORT_ASC];\n        } else {\n            throw Error('columnUtils.mapSortCriteria invalid input');\n        }\n\n    });\n}\n\nexport const toKeyedColumn = (column, key) =>\n    typeof column === 'string'\n        ? { key, name: column }\n        : typeof column.key === 'number'\n            ? column\n            : {...column, key};\n\nexport const toColumn = column =>\n    typeof column === 'string'\n        ? { name: column }\n        : column;\n\nexport function buildColumnMap(columns){\n    if (columns){\n        return columns.reduce((map, column, i) => {\n            if (typeof column === 'string'){\n                map[column] = i;\n            } else if (typeof column.key === 'number') {\n                map[column.name] = column.key;\n            } else {\n                map[column.name] = i;\n            }\n            return map;\n        },{})\n    } else {\n        return null;\n    }\n}\n\nexport function projectColumns(map, columns, meta){\n    const length = columns.length;\n    const {IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n    return (startIdx, selectedRows=[]) => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[RENDER_IDX] = 0;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = 0;\n        return out;\n    }\n}\n\nexport function projectColumnsFilter(map, columns, meta, filter){\n    const length = columns.length;\n    const {IDX, RENDER_IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n\n    // this is filterset specific where first col is always value\n    const fn = filter ? functor(map, overrideColName(filter, 'name'), true)  : () => true;\n    return startIdx => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[RENDER_IDX] = 0;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = fn(row) ? 1 : 0;\n\n        return out;\n    }\n}\n\nexport function getFilterType(column){\n    return column.filter || getDataType(column);\n}\n\n// {name: 'Price', 'type': {name: 'price'}, 'aggregate': 'avg'},\n// {name: 'MarketCap', 'type': {name: 'number','format': 'currency'}, 'aggregate': 'sum'},\n\nexport function getDataType({type=null}){\n    if (type === null){\n        return 'set';\n    } else if (typeof type === 'string'){\n        return type;\n    } else {\n        switch(type.name){\n            case 'price':\n                return 'number';\n            default:\n                return type.name;\n        }\n    }\n\n}\n\n//TODO cache result by length\nexport function metaData(columns){\n    const start = Math.max(...columns.map((column, idx) => typeof column.key === 'number' ? column.key : idx));\n    return {\n        IDX: start + 1,\n        RENDER_IDX: start + 2,\n        DEPTH: start + 3,\n        COUNT: start + 4,\n        KEY: start + 5,\n        SELECTED: start + 6,\n        PARENT_IDX: start + 7,\n        IDX_POINTER: start + 8,\n        FILTER_COUNT: start + 9,\n        NEXT_FILTER_IDX: start + 10,\n        count: start + 11\n    }\n}\n","export const DataTypes = {\n    ROW_DATA: 'rowData',\n    FILTER_DATA: 'filterData',\n    FILTER_BINS: 'filterBins'\n};\n\nexport const ASC = 'asc';\nexport const DSC = 'dsc';\n","import {ASC} from './types';\nimport {mapSortCriteria} from './columnUtils';\n\nconst EMPTY_MAP = {};\n\nexport function sortableFilterSet(filterSet){\n    if (filterSet.length === 0){\n        return filterSet;\n    } else if (Array.isArray(filterSet[0])){\n        return filterSet;\n    } else {\n        return filterSet.map(idx => [idx,null]);\n    }\n}\n\nexport function sortExtend(sortSet, rows, sortCols, newSortCols, columnMap){\n    sort2ColsAdd1(sortSet, rows, newSortCols, columnMap)\n}\n\nexport function sort(sortSet,rows,sortCols,columnMap){\n    const sortCriteria = mapSortCriteria(sortCols, columnMap);\n    const count = sortCriteria.length;\n    const sortFn = count === 1 ? sort1 : count === 2 ? sort2 : count === 3 ? sort3 : sortAll;\n    sortFn(sortSet,rows,sortCriteria);\n}\n\nfunction sort2ColsAdd1(sortSet, rows, sortCols, columnMap){\n    const len = sortSet.length;\n    const sortCriteria = mapSortCriteria(sortCols, columnMap);\n    const [colIdx2] = sortCriteria[1];\n    for (let i=0;i<len;i++){\n        sortSet[i][2] = rows[sortSet[i][0]][colIdx2];\n    }\n    sortSet.sort((a,b) => {\n        return a[1] > b[1] ? 1 : b[1] > a[1] ? -1\n            : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n    });\n}\n\nfunction sort1(sortSet,rows,[[colIdx, direction]]){\n    const len = sortSet.length;\n    for (let i=0;i<len;i++){\n        const idx = sortSet[i][0];\n        sortSet[i][1] = rows[idx][colIdx];\n    }\n    if (direction === ASC){\n        sortSet.sort((a,b) => {\n            return a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : 0;\n        });\n    } else {\n        sortSet.sort((a,b) => {\n            return a[1] > b[1] ? -1 : b[1] > a[1] ? 1 : 0;\n        });\n    }\n}\n\nfunction sort2(sortSet,rows,sortCriteria){\n    const len = rows.length;\n    const [colIdx1] = sortCriteria[0];\n    const [colIdx2] = sortCriteria[1];\n    for (let i=0;i<len;i++){\n        sortSet[i][0] = i;\n        sortSet[i][1] = rows[i][colIdx1];\n        sortSet[i][2] = rows[i][colIdx2];\n    }\n    sortSet.sort((a,b) => {\n        return a[1] > b[1] ? 1 : b[1] > a[1] ? -1\n            : a[2] > b[2] ? 1 : b[2] > a[2] ? -1 : 0;\n    });\n}\n\nfunction sort3(/*sortSet,rows,sortCriteria*/){\n\n}\nfunction sortAll(/*sortSet,rows,sortCriteria*/){\n\n}\n\nexport function binarySearch(items, item, comparator) {\n    let l = 0;\n    let h = items.length - 1;\n    let m;\n    let comparison;\n\n    while (l <= h) {\n        m = (l + h) >>> 1; /* equivalent to Math.floor((l + h) / 2) but faster */\n        comparison = comparator(items[m], item);\n        if (comparison < 0) {\n            l = m + 1;\n        } else if (comparison > 0) {\n            h = m - 1;\n        } else {\n            return m;\n        }\n    }\n    return ~l;\n}\n\nexport function binaryInsert(rows, row, comparator) {\n    var i = binarySearch(rows, row, comparator);\n    /* if the binarySearch return value was zero or positive, a matching object was found */\n    /* if the return value was negative, the bitwise complement of the return value is the correct index for this object */\n    if (i < 0){\n        i = ~i;\n    }\n    rows.splice(i, 0, row);\n    return i;\n}\n\nfunction processTail(tail, row, tailGateKeeper, n, compare){\n    const diff = tailGateKeeper === null\n        ? -1\n        : compare(row, tailGateKeeper);\n\n    if (diff > 0 || tail.length < n){\n        binaryInsert(tail, row, compare);\n        if (tail.length > n) {\n            tail.shift();\n        }\n        tailGateKeeper = tail[0];\n    }\n    return tailGateKeeper;\n}\n\n// this is always called with a single col sort\nexport function sortedLowestAndHighest(rows, sortCriteria, offset, n=1000){\n    const s1 = new Date().getTime();\n    const compare = sortBy(sortCriteria);\n    const head = rows.slice(0,n).sort(compare);\n    const tail = [];\n    const len = rows.length;\n\n    let headGateKeeper = head[n-1];\n    let tailGateKeeper = null\n\n    for (let i=n;i<len;i++){\n        if (compare(rows[i], headGateKeeper) < 0){\n            binaryInsert(head, rows[i], compare);\n            // We need to remove largest item from head, does it belong in tail ?\n            tailGateKeeper = processTail(tail, head.pop(), tailGateKeeper, n, compare)\n            headGateKeeper = head[n-1];\n        } else {\n            tailGateKeeper = processTail(tail, rows[i], tailGateKeeper, n, compare)\n        }\n    }\n\n    for (let i=0;i<head.length;i++){\n        const row = head[i].slice();\n        row[0] = i + offset;\n        head[i] = row;\n    }\n\n    for (let i=0,idx=len-n;i<tail.length;i++,idx++){\n        const row = tail[i].slice();\n        row[0] = idx + offset;\n        tail[i] = row;\n    }\n\n    const s2 = new Date().getTime();\n    console.log(`lowest ${n} took ${s2-s1} ms , producing ${head.length} lowest `);\n\n    return [head, tail];\n}\n\nexport function sortByToMap(sortCriteria=null){\n    return sortCriteria === null\n        ? EMPTY_MAP\n        : sortCriteria.reduce((map, col, i) => {\n            if (typeof col === 'string') {\n                map[col] = i + 1;\n            } else {\n                const [colName, sortDir] = col;\n                map[colName] = sortDir === ASC ? (i + 1) : -1 * (i + 1);\n            }\n            return map;\n        }, {});\n\n}\n\nexport function sortReversed(cols1, cols2, colCount=cols1.length){\n    if (cols1 && cols2 && cols1.length > 0 && cols2.length === colCount){\n        for (let i=0;i<cols1.length; i++){\n            let [col1, direction1=ASC] = cols1[i];\n            let [col2, direction2=ASC] = cols2[i];\n            if (col1 !== col2 || direction1 === direction2){\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nexport function GROUP_ROW_TEST(group, row, [colIdx, direction]) {\n    if (group === row) {\n        return 0;\n    } else {\n        let a1 = direction === 'dsc' ? row[colIdx] : group[colIdx];\n        let b1 = direction === 'dsc' ? group[colIdx] : row[colIdx];\n        if (b1 === null || a1 > b1) {\n            return 1;\n        } else if (a1 == null || a1 < b1) {\n            return -1;\n        }\n    }\n}\n\nfunction ROW_SORT_TEST(a, b, [colIdx, direction]) {\n    if (a === b) {\n        return 0;\n    } else {\n        let a1 = direction === 'dsc' ? b[colIdx] : a[colIdx];\n        let b1 = direction === 'dsc' ? a[colIdx] : b[colIdx];\n        if (b1 === null || a1 > b1) {\n            return 1;\n        } else if (a1 == null || a1 < b1) {\n            return -1;\n        }\n    }\n}\n\n// sort null as low. not high\nexport function sortBy(cols, test=ROW_SORT_TEST) {\n    return function (a, b) {\n        for (let i = 0, result = 0, len=cols.length; i < len; i++) {\n            if (result = test(a, b, cols[i])) {\n                return result;\n            }\n        }\n        return 0;\n    };\n}\n\n// sorter is the sort comparator used to sort rows, we want to know\n// where row would be positioned in this sorted array. Return the\n// last valid position.\nexport function sortPosition(rows, sorter, row, positionWithinRange = 'last-available') {\n\n    function selectFromRange(pos) {\n\n        const len = rows.length;\n        const matches = p => sorter(rows[p], row) === 0;\n\n        //TODO this will depend on the sort direction\n        if (positionWithinRange === 'last-available') {\n            while (pos < len && matches(pos)) {\n                pos += 1;\n            }\n        } else if (positionWithinRange === 'first-available') {\n            while (pos > 0 && matches(pos - 1)) {\n                pos -= 1;\n            }\n        }\n\n        return pos;\n\n    }\n\n    function find(lo, hi) {\n\n        let mid = lo + Math.floor((hi - lo) / 2);\n        let pos = sorter(rows[mid], row);\n\n        if (lo === mid) {\n            return selectFromRange(pos >= 0 ? lo : hi);\n        }\n        if (pos >= 0) {\n            hi = mid;\n        } else {\n            lo = mid;\n        }\n        return find(lo, hi);\n    }\n\n    if (rows.length === 0){\n        return 0;\n    } else {\n        return find(0, rows.length);\n    }\n\n}\n","export const NULL_RANGE = {lo: 0,hi: 0};\n\n// If the requested range overlaps the last sent range, we only need send the\n// newly exposed section of the range. The client will manage dropping off\n// the expired section.\n//\n// |----------------------------------| _range\n//  ++++++|----------------------------------| prevRange\n//  \n//\n//\n//  |------------------------------------| _range\n//  |----------------------------------|+  prevRange\n//TODO do we still need these calls to getFullRange ?\nexport function getDeltaRange(oldRange, newRange){\n    const {lo: oldLo, hi: oldHi} = oldRange /*getFullRange(oldRange)*/;\n    const {lo: newLo, hi: newHi} = newRange /*getFullRange(newRange)*/;\n\n    if (newLo >= oldLo && newHi <= oldHi){\n        // reduced range, no delta\n        return {lo: newHi, hi: newHi};\n\n    } else if (newLo >= oldHi || newHi < oldLo){\n        return {lo: newLo, hi: newHi};\n    } else if (newLo === oldLo && newHi === oldHi){\n        return {lo: oldHi,hi: oldHi};\n    } else {\n        return {\n            lo: newLo < oldLo ? newLo: oldHi,\n            hi: newHi > oldHi ? newHi: oldLo\n        };\n    }\n}\n\nexport function resetRange({lo,hi,bufferSize=0}){\n    return {\n        lo: 0,\n        hi: hi-lo,\n        bufferSize,\n        reset: true\n    };\n}\n\nexport function getFullRange({lo,hi,bufferSize=0}){\n    return {\n        lo: Math.max(0, lo - bufferSize),\n        hi: hi + bufferSize\n    };\n}\n\nexport function withinRange(range, index, offset=0) {\n    return index-offset >= range.lo && index-offset < range.hi;\n}\n\nconst SAME = 0;\nconst FWD = 2;\nconst BWD = 4;\nconst CONTIGUOUS = 8;\nconst OVERLAP = 16;\nconst REDUCE = 32;\nconst EXPAND = 64;\nconst NULL = 128;\n\nexport const RangeFlags = {\n    SAME,\n    FWD,\n    BWD,\n    CONTIGUOUS,\n    OVERLAP,\n    REDUCE,\n    EXPAND,\n    NULL\n}\n\nRangeFlags.GAP = ~(CONTIGUOUS | OVERLAP | REDUCE)\n\nexport function compareRanges(range1, range2){\n    if (range2.lo === 0 && range2.hi === 0){\n        return NULL;\n    } else if (range1.lo === range2.lo && range1.hi === range2.hi){\n        return SAME;\n    } else if (range2.hi > range1.hi){\n        if (range2.lo > range1.hi){\n            return FWD;\n        } else if (range2.lo === range1.hi){\n            return FWD + CONTIGUOUS;\n        } else if (range2.lo >= range1.lo){\n            return FWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo < range1.lo){\n        if (range2.hi < range1.lo){\n            return BWD;\n        } else if (range2.hi === range1.lo){\n            return BWD + CONTIGUOUS;\n        } else if (range2.hi > range1.lo){\n            return BWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo > range1.lo) {\n        return REDUCE + FWD;\n    } else {\n        return REDUCE + BWD\n    }\n}\n","\nimport { sortBy, sortPosition, GROUP_ROW_TEST } from './sort';\nimport { ASC } from './types';\nimport { metaData } from './columnUtils';\n\nconst LEAF_DEPTH = 0;\nconst DEFAULT_OPTIONS = {\n    startIdx: 0,\n    rootIdx: null,\n    rootExpanded: true,\n    baseGroupby: []\n};\n\nexport function lowestIdxPointer(groups, IDX, DEPTH, start, depth){\n    let result = Number.MAX_SAFE_INTEGER;\n    for (let i=start; i<groups.length; i++){\n        const group = groups[i];\n        const absDepth = Math.abs(group[DEPTH]);\n\n        if (absDepth > depth){\n            break;\n        } else if (absDepth === depth) {\n            const idx = group[IDX];\n            if (typeof idx === 'number' && idx < result){\n                result = idx;\n            }\n        }\n    }\n\n    return result === Number.MAX_SAFE_INTEGER ? undefined : result;\n\n}\n\nexport function getCount(groupRow, PRIMARY_COUNT, FALLBACK_COUNT){\n    return typeof groupRow[PRIMARY_COUNT] === 'number'\n        ? groupRow[PRIMARY_COUNT]\n        : groupRow[FALLBACK_COUNT];\n}\n\nexport class SimpleTracker {\n    constructor(levels){\n        this.levels = Array(levels).fill(0).reduce((acc,el,i) => {\n            acc[i+1] = {key: null, pos: null, pPos: null};\n            return acc;\n        },{});\n    }\n    set(depth,pos,groupKey){\n        if (this.levels){\n            const level = this.levels[Math.abs(depth)];\n            if (level && level.key !== groupKey){\n                if (level.key !== null){\n                    level.pPos = level.pos;\n                }\n                level.key = groupKey;\n                level.pos = pos;\n            }\n        }\n    }\n    \n    hasParentPos(level){\n        return this.levels[level+1] && this.levels[level+1].pos !== null\n    }\n    \n    parentPos(level){\n        return this.levels[level+1].pos\n    }\n    \n    hasPreviousPos(level){\n        return this.levels[level] && this.levels[level].pPos !== null\n    }\n    \n    previousPos(level){\n        return this.levels[level].pPos;\n    }\n}\n\nexport class GroupIdxTracker {\n    constructor(levels){\n        this.idxAdjustment = 0;\n        this.maxLevel = levels+1;\n        this.levels = levels > 0\n            ? Array(levels).fill(0).reduce((acc,el,i) => {\n                acc[i+2] = {key: null, current: 0, previous: 0};\n                return acc;\n            },{})\n            : null;\n    }\n\n    increment(count){\n        this.idxAdjustment += count;\n        if (this.levels){\n            for (let i=2; i<this.maxLevel+1;i++){\n                this.levels[i].current += count;\n            }\n        }\n    }\n\n    previous(level){\n        return (this.levels && this.levels[level] && this.levels[level].previous) || 0\n    }\n\n    hasPrevious(level){\n        return this.previous(level) > 0;\n    }\n\n    get(idx){\n        return this.levels === null ? null: this.levels[idx]\n    }\n\n    set(depth,groupKey){\n        if (this.levels){\n            const level = this.levels[depth];\n            if (level && level.key !== groupKey){\n                if (level.key !== null){\n                    level.previous += level.current;\n                    level.current = 0;\n                }\n                level.key = groupKey;\n            }\n        }\n    }\n}\n\nconst itemIsNumeric = item => !isNaN(parseInt(item,10));\nconst numerically = (a,b) => parseInt(a)-parseInt(b);\n\nfunction sortKeys(o){\n    const keys = Object.keys(o);\n    if (keys.every(itemIsNumeric)){\n        return keys.sort(numerically)\n    } else {\n        return keys.sort()\n    }\n}\n\nexport function fillNavSetsFromGroups(groups, sortSet, sortIdx=0, filterSet=null, filterIdx, filterLen){\n    const keys = sortKeys(groups);\n    const filtered = filterSet !== null;\n    const filterIndices = filtered ? filterSet.slice(filterIdx,filterLen) : null;\n    for (let i = 0 ; i<keys.length;i++){\n        const groupedRows = groups[keys[i]]\n        if (Array.isArray(groupedRows)){\n            for (let j=0,len=groupedRows.length;j<len;j++){\n                const rowIdx = groupedRows[j];\n                sortSet[sortIdx] = rowIdx;\n                sortIdx += 1\n                // this could be prohibitively slow (the includes test) ...\n                if (filtered && filterIndices.includes(rowIdx)){\n                    filterSet[filterIdx] = rowIdx;\n                    filterIdx += 1;\n                }\n            }\n        } else {\n            sortIdx = fillNavSetsFromGroups(groupedRows, sortSet, sortIdx);\n        }\n    }\n    return sortIdx;\n}\n\n// WHY is param order different from groupLeafRows\nexport function groupRows(rows, sortSet, columns, columnMap, groupby, options = DEFAULT_OPTIONS) {\n    const { startIdx = 0, length=rows.length, rootIdx = null, baseGroupby = [], groups=[], rowParents=null,\n        filterLength, filterSet, filterFn: filter } = options;\n    let {groupIdx=-1, filterIdx} = options;\n\n    const aggregations = findAggregatedColumns(columns, columnMap, groupby);\n    const groupedLeafRows = groupLeafRows(sortSet, rows, groupby, startIdx, length)\n    fillNavSetsFromGroups(groupedLeafRows, sortSet, startIdx, filterSet, filterIdx, filterLength);\n\n    const levels = groupby.length;\n    const currentGroups = Array(levels).fill(null);\n    const { IDX, DEPTH, FILTER_COUNT, NEXT_FILTER_IDX } = metaData(columns);\n\n    let parentIdx = rootIdx;\n    let leafCount = 0;\n\n    for (let i = startIdx, len=startIdx+length; i < len; i++){\n        const rowIdx = sortSet[i];\n        const row = rows[rowIdx];\n\n        for (let level = 0; level < levels; level++) {\n            const [columnIdx] = groupby[level];\n            const currentGroup = currentGroups[level];\n            const groupValue = row[columnIdx];\n            // as soon as we identify a group change, each group at that level and below\n            // is then aggregated and new group(s) initiated. \n            if (currentGroup === null || currentGroup[columnIdx] !== groupValue) {\n                if (currentGroup !== null) {\n                    // as soon as we know we're regrouping, aggregate the open groups, in reverse order\n                    for (let ii = levels - 1; ii >= level; ii--) {\n                        const group = currentGroups[ii];\n                        aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n                        if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0){\n                            group[NEXT_FILTER_IDX] = filterIdx;\n                            filterIdx += group[FILTER_COUNT];\n                        }\n                    }\n\n                    leafCount = 0;\n                }\n                for (let ii = level; ii < levels; ii++) {\n                    groupIdx += 1;\n                    parentIdx = ii === 0 ? rootIdx : currentGroups[ii - 1][IDX];\n                    const depth = levels - ii;\n                    // for first-level groups, row pointer is a pointer into the sortSet\n                    const childIdx = depth === 1\n                        ? i\n                        : groupIdx+1;\n\n                    const groupRow = currentGroups[ii] = GroupRow(row, depth, groupIdx, childIdx, parentIdx, groupby, columns, columnMap, baseGroupby);\n                    groups.push(groupRow);\n                }\n                break; // do not continue looping once we identify the change point\n            }\n        }\n        rowParents && (rowParents[rowIdx] = groupIdx);\n        leafCount += 1;\n    }\n\n    for (let i = levels - 1; i >= 0; i--) {\n        if (currentGroups[i] !== null){\n            const group = currentGroups[i];\n            aggregate(group, groups, sortSet, rows, columns, aggregations, leafCount, filter);\n            if (filterSet && Math.abs(group[DEPTH]) === 1 && group[FILTER_COUNT] > 0){\n                group[NEXT_FILTER_IDX] = filterIdx;\n            }\n        }\n    }\n    return groups;\n\n}\n\n// Checks very specifically for new cols added at end \nexport function groupbyExtendsExistingGroupby(groupBy, existingGroupBy) {\n    return (groupBy.length > existingGroupBy.length &&\n        existingGroupBy.every((g, i) => g[0] === groupBy[i][0]));\n}\n\n// doesn't care from which position col is removed, as long as it is not the first\nexport function groupbyReducesExistingGroupby(groupby, existingGroupby) {\n    return (existingGroupby.length > groupby.length &&\n        groupby[0][0] === existingGroupby[0][0] &&\n        groupby.every(([key]) => existingGroupby.find(([key2]) => key2 === key)));\n}\n\nexport function groupbySortReversed(groupBy, existingGroupBy) {\n    const [col] = findSortedCol(groupBy, existingGroupBy)\n    return col !== null;\n}\n\nexport function findDoomedColumnDepths(groupby, existingGroupby) {\n    const count = existingGroupby.length;\n    return existingGroupby.reduce(\n        (results, [colIdx], idx) => {\n            if (!groupby.some(group => group[0] === colIdx)) {\n                results.push(count - idx);\n            }\n            return results;\n        }, []);\n}\n\nexport function findSortedCol(groupby, existingGroupby) {\n    let results = [null];\n    let len1 = groupby && groupby.length;\n    let len2 = existingGroupby && existingGroupby.length;\n    if (len1 && len2 && len1 === len2) {\n\n        for (let i = 0; i < len1; i++) {\n            if (groupby[i][0] !== existingGroupby[i][0]) {\n                return results;\n            } else if (groupby[i][1] !== existingGroupby[i][1]) {\n                results[0] = i;\n                results[1] = len1 - i;\n            }\n        }\n    }\n    return results;\n}\n\nfunction byKey([key1], [key2]) {\n    return key1 > key2 ? 1 : key2 > key1 ? -1 : 0;\n}\n\nconst EMPTY = {};\nexport function getGroupStateChanges(groupState, existingGroupState = null, baseKey = '', groupIdx = 0) {\n    const results = [];\n    const entries = Object.entries(groupState);\n\n    entries.forEach(([key, value]) => {\n        if (value && (existingGroupState === null || !existingGroupState[key])) {\n            results.push([baseKey + key, groupIdx, true]);\n            if (value !== null && typeof value === 'object' && Object.keys(value).length > 0) {\n                const diff = getGroupStateChanges(value, EMPTY, baseKey + key + '/', groupIdx + 1);\n                if (diff.length) {\n                    results.push(...diff)\n                }\n            }\n        } else if (value) {\n            const diff = getGroupStateChanges(value, existingGroupState[key], baseKey + key + '/', groupIdx + 1);\n            if (diff.length) {\n                results.push(...diff)\n            }\n        }\n    })\n\n    if (existingGroupState !== null && typeof existingGroupState === 'object') {\n        Object.entries(existingGroupState).forEach(([key, value]) => {\n            if (value && !groupState[key]) {\n                results.push([baseKey + key, groupIdx, false]);\n            }\n        });\n    }\n\n    return results.sort(byKey);\n}\n\nexport function getDirection(depth, groupby) {\n    const idx = groupby.length - depth;\n    const [, direction] = groupby[idx];\n    return direction;\n}\n\n// should be called toggleColumnInGroupBy\nexport function updateGroupBy(existingGroupBy = null, column/*, replace = false*/) {\n    console.log(``)\n    if (existingGroupBy === null) {\n        return [[column.name, ASC]];\n    } else {\n        return indexOfCol(column.name, existingGroupBy) === -1\n            ? existingGroupBy.concat([[column.name, ASC]])\n            : existingGroupBy.length === 1\n                ? null\n                : existingGroupBy.filter(([colName]) => colName !== column.name);\n    }\n}\n\nexport function expanded(group, groupby, groupState) {\n    const groupIdx = groupby.length - Math.abs(group[1]);\n    let groupVal;\n    let stateEntry = groupState;\n    for (let i = 0; i <= groupIdx; i++) {\n        const [colIdx] = groupby[i];\n        groupVal = group[colIdx];\n        if (i === groupIdx) {\n            return stateEntry[groupVal];\n        } else {\n            stateEntry = stateEntry[groupVal];\n            if (!stateEntry) {\n                return false;\n            }\n        }\n    }\n    return false;\n}\n\nexport function indexOfCol(key, cols = null) {\n    if (cols !== null) {\n        for (let i = 0; i < cols.length; i++) {\n            // check both while we transition from groupBy to extendedGroupby\n            // groupBy = [colName, dir] extendedGroupby = [colIdx, dir,colName]\n            const [col1, , col2] = cols[i];\n            if (col1 === key || col2 === key) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\n// export function countNestedRows(rows, idx, depth) {\n//     const DEPTH = Data.DEPTH_FIELD;\n//     let count = 0;\n//     for (let i = idx, len = rows.length;\n//         i < len && Math.abs(rows[i][DEPTH]) < depth;\n//         i++) {\n//         count += 1;\n//     }\n//     return count;\n// }\n\n// TBC\n// export function countGroupMembers(groupedRows) {\n//     const results = [];\n//     const groups = [];\n//     let currentGroup = null;\n\n//     for (let i = 0; i < groupedRows.length; i++) {\n//         let [, depth] = groupedRows[i];\n//         if (depth === LEAF_DEPTH) {\n//             currentGroup.count += 1;\n//         } else {\n//             depth = Math.abs(depth);\n//             while (currentGroup && depth >= currentGroup.depth) {\n//                 const completedGroup = groups.shift();\n//                 const group = results[completedGroup.i];\n//                 if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//                     const newGroup = group.slice();\n//                     newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//                     results[completedGroup.i] = newGroup;\n//                 }\n//                 groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//                 ([currentGroup] = groups);\n//             }\n\n//             currentGroup = { i, depth, count: 0 };\n//             groups.unshift(currentGroup);\n//         }\n\n//         results[i] = groupedRows[i];\n\n//     }\n\n//     while (currentGroup) {\n//         const completedGroup = groups.shift();\n//         const group = results[completedGroup.i];\n//         if (group[Data.COUNT_FIELD] !== completedGroup.count) {\n//             const newGroup = group.slice();\n//             newGroup[Data.COUNT_FIELD] = completedGroup.count;\n//             results[completedGroup.i] = newGroup;\n//         }\n//         groups.forEach(higherLevelGroup => higherLevelGroup.count += completedGroup.count);\n//         ([currentGroup] = groups);\n//     }\n\n//     return results;\n// }\n\nexport function allGroupsExpanded(groups, group, {DEPTH, PARENT_IDX}){\n\n    do {\n        if (group[DEPTH] < 0){\n            return false;\n        }\n        group = groups[group[PARENT_IDX]];\n\n    } while (group)\n    \n    return true;\n}\n\nexport function adjustGroupIndices(groups, grpIdx, {IDX, DEPTH, IDX_POINTER, PARENT_IDX}, adjustment=1){\n    for (let i=0;i<groups.length;i++){\n        if (groups[i][IDX] >= grpIdx){\n            groups[i][IDX] += adjustment;\n            if (Math.abs(groups[i][DEPTH]) > 1){\n                groups[i][IDX_POINTER] += adjustment;\n            }\n            let parentIdx = groups[i][PARENT_IDX];\n            if (parentIdx !== null && parentIdx >= grpIdx){\n                groups[i][PARENT_IDX] += adjustment;\n            }\n        }\n    }\n}\n\nexport function adjustLeafIdxPointers(groups, insertionPoint, {DEPTH, IDX_POINTER}, adjustment=1){\n    for (let i=0;i<groups.length;i++){\n        if (Math.abs(groups[i][DEPTH]) === 1 && groups[i][IDX_POINTER] >= insertionPoint){\n            groups[i][IDX_POINTER] += adjustment;\n        }\n    }\n}\n\nexport function findGroupPositions(groups, groupby, row) {\n\n    const positions = [];\n\n    out: for (let i = 0; i < groupby.length; i++) {\n        const sorter = sortBy(groupby.slice(0, i + 1), GROUP_ROW_TEST);\n        const position = sortPosition(groups, sorter, row, 'first-available');\n        const group = groups[position];\n        // if all groups are missing and insert position is end of list ...\n        if (group === undefined) {\n            break;\n        }\n        // position is confirmed if all groupCol values in this comparison match values of row \n        // and other groupCol values  are null\n        for (let j = 0; j < groupby.length; j++) {\n            const colIdx = groupby[j][0];\n            const colValue = group[colIdx];\n            if (j > i) {\n                if (colValue !== null) {\n                    break out;\n                }\n            } else if (colValue !== row[colIdx]) {\n                break out;\n            }\n\n        }\n        positions.push(position);\n    }\n\n    return positions;\n\n}\n\nexport const expandRow = (groupCols, row, meta) => {\n    const r = row.slice();\n    r[meta.IDX] = 0;\n    r[meta.DEPTH] = 0; \n    r[meta.COUNT] = 0;\n    r[meta.KEY] = buildGroupKey(groupCols, row);\n    r[meta.SELECTED] = 0;\n    return r;\n}\n\nfunction buildGroupKey(groupby, row){\n    const extractKey = ([idx]) => row[idx];\n    return groupby.map(extractKey).join('/');\n}\n\n// Do we have to take columnMap out again ?\nexport function GroupRow(row, depth, idx, childIdx, parentIdx, groupby, columns, columnMap, baseGroupby = []) {\n\n    const { IDX, DEPTH, COUNT, KEY, SELECTED, PARENT_IDX, IDX_POINTER, count } = metaData(columns);\n    const group = Array(count);\n    const groupIdx = groupby.length - depth;\n    let colIdx;\n\n    for (let i = 0; i < columns.length; i++) {\n        const column = columns[i];\n        const key = columnMap[column.name];\n        if (column.aggregate) { // implies we can't group on aggregate columns, does the UI know that ?\n            group[key] = 0;\n        } else if ((colIdx = indexOfCol(key, groupby)) !== -1 && colIdx <= groupIdx) {\n            group[key] = row[key];\n        } else {\n            group[key] = null;\n        }\n    }\n\n    for (let i = 0; i < baseGroupby.length; i++) {\n        const [colIdx] = baseGroupby[i];\n        group[colIdx] = row[colIdx];\n    }\n\n    const extractKey = ([idx]) => row[idx];\n    const buildKey = groupby => groupby.map(extractKey).join('/');\n    //TODO build the composite key for the grouprow\n    const baseKey = baseGroupby.length > 0\n        ? buildKey(baseGroupby) + '/'\n        : '';\n    const groupKey = buildKey(groupby.slice(0, groupIdx + 1));\n\n    group[IDX] = idx;\n    group[DEPTH] = -depth;\n    group[COUNT] = 0;\n    group[KEY] = baseKey + groupKey;\n    group[SELECTED] = 0;\n    group[IDX_POINTER] = childIdx;\n    group[PARENT_IDX] = parentIdx;\n\n    return group;\n\n}\n\nexport function groupLeafRows(sortSet, leafRows, groupby, startIdx=0, length=sortSet.length) {\n    const groups = {};\n    const levels = groupby.length;\n    const lastLevel = levels - 1;\n    for (let i=startIdx, len=startIdx+length; i < len; i++) {\n        const idx = sortSet[i]\n        const leafRow = leafRows[idx];\n        let target = groups;\n        let targetKey\n        let key;\n        for (let level = 0; level < levels; level++) {\n            const [colIdx] = groupby[level];\n            key = leafRow[colIdx];\n            targetKey = target[key]\n            if (targetKey && level === lastLevel) {\n                targetKey.push(idx);\n            } else if (targetKey) {\n                target = targetKey;\n            } else if (!targetKey && level < lastLevel) {\n                target = (target[key] = {});\n            } else if (!targetKey) {\n                target[key] = [idx];\n            }\n        }\n    }\n    return groups;\n}\n\nexport function splitGroupsAroundDoomedGroup(groupby, doomed) {\n    const lastGroupIsDoomed = doomed === 1;\n    const doomedIdx = groupby.length - doomed;\n    const preDoomedGroupby = [];\n    const postDoomedGroupby = [];\n\n    groupby.forEach((col, i) => {\n        if (i < doomedIdx) {\n            preDoomedGroupby.push(col)\n        } else if (i > doomedIdx) {\n            postDoomedGroupby.push(col);\n        }\n    });\n\n    return [lastGroupIsDoomed, preDoomedGroupby, postDoomedGroupby];\n}\n\nexport function decrementDepth(depth) {\n    return (Math.abs(depth) - 1) * (depth < 0 ? -1 : 1);\n}\n\nexport function incrementDepth(depth) {\n    return (Math.abs(depth) + 1) * (depth < 0 ? -1 : 1);\n}\n\n// hardcode the index ref for now\n// When we build the group index, all groups are collapsed\nexport function indexGroupedRows(groupedRows) {\n\n    // TODO\n    const Fields = {\n        Depth: 1,\n        Key: 4\n    };\n\n    const groupedIndex = {};\n    const levels = [];\n    const COLLAPSED = -1;\n\n    for (let idx = 0; idx < groupedRows.length; idx++) {\n\n        let row = groupedRows[idx];\n        let rowDepth = row[Fields.Depth];\n\n        if (rowDepth === 0) {\n            let index = [idx];\n            levels.forEach(level => {\n                index.push(level[1], COLLAPSED);\n            });\n            groupedIndex[row[Fields.Key]] = index;\n        } else {\n            while (levels.length && Math.abs(levels[levels.length - 1][0]) <= Math.abs(rowDepth)) {\n                levels.pop();\n            }\n            levels.push([rowDepth, idx]);\n        }\n    }\n\n    return groupedIndex;\n}\n\nexport function findAggregatedColumns(columns, columnMap, groupby) {\n    return columns.reduce((aggregations, column) => {\n        if (column.aggregate && indexOfCol(column.name, groupby) === -1) {\n            const key = columnMap[column.name];\n            aggregations.push([key, column.aggregate]);\n        }\n        return aggregations;\n    }, []);\n}\n\nexport function aggregateGroup(groups, grpIdx, sortSet, rows, columns, aggregations) {\n\n    const {DEPTH, COUNT} = metaData(columns);\n    const groupRow = groups[grpIdx];\n    let depth = groupRow[DEPTH];\n    let absDepth = Math.abs(depth);\n    let count = 0;\n    let idx = grpIdx;\n\n    // find the last nested group and work back - first build aggregates for level 1 groups,\n    // then use those to aggregate to level 2 etc.\n    while (idx < groups.length - 1 && Math.abs(groups[idx+1][DEPTH]) < absDepth){\n        idx += 1;\n        count += 1;\n    }\n\n    for (let i=grpIdx+count; i >= grpIdx; i--){\n        for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n            const [colIdx] = aggregations[aggIdx];\n            groups[i][colIdx] = 0;\n        }\n        aggregate(groups[i], groups, sortSet, rows, columns, aggregations, groups[i][COUNT])\n    }\n\n}\n\nfunction aggregate(groupRow, groupRows, sortSet, rows, columns, aggregations, leafCount, filter=null) {\n\n    const {DEPTH, COUNT, FILTER_COUNT} = metaData(columns);\n    const { IDX_POINTER } = metaData(columns);\n    let absDepth = Math.abs(groupRow[DEPTH]);\n    let count = 0;\n    let filteredCount = filter === null ? undefined : 0;\n\n    if (absDepth === 1) {\n        // The first group accumulates aggregates from the raw data...\n        let start = groupRow[IDX_POINTER];\n        let end = start + leafCount;\n        count = leafCount;\n        for (let i = start; i < end; i++) {\n            const row = rows[sortSet[i]];\n            const included = filter === null || filter(row);\n            if (filter && included){\n                filteredCount += 1;\n            }\n            if (filter === null || included){\n                for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n                    const [colIdx] = aggregations[aggIdx];\n                    groupRow[colIdx] += row[colIdx];\n                }\n            }\n        }\n    } else {\n        // higher-level groups aggregate from child-groups ...\n        // we cannot blindly use the grpIndex of the groupRow, as we may be dealing with a smaller subset\n        // of groupRows, e,g, when inserting a new row and creating the missing groups\n        const startIdx = groupRows.indexOf(groupRow) + 1;\n        for (let i=startIdx;i<groupRows.length;i++){\n            const nestedGroupRow = groupRows[i];\n            const nestedRowDepth = nestedGroupRow[DEPTH];\n            const nestedRowCount = nestedGroupRow[COUNT];\n            const absNestedRowDepth = Math.abs(nestedRowDepth);\n            if (absNestedRowDepth >= absDepth){\n                break;\n            } else if (absNestedRowDepth === absDepth - 1) {\n                for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n                    const [colIdx, method] = aggregations[aggIdx];\n                    if (method === 'avg') {\n                        groupRow[colIdx] += nestedGroupRow[colIdx] * nestedRowCount;\n                    } else {\n                        groupRow[colIdx] += nestedGroupRow[colIdx];\n                    }\n                }\n                count += nestedRowCount;\n            }\n        }\n    }\n\n    for (let aggIdx = 0; aggIdx < aggregations.length; aggIdx++) {\n        const [colIdx, method] = aggregations[aggIdx];\n        if (method === 'avg') {\n            groupRow[colIdx] = groupRow[colIdx] / count;\n        }\n    }\n\n    groupRow[COUNT] = count;\n    groupRow[FILTER_COUNT] = filteredCount;\n\n}\n","\nexport function isEmptyRow(row){\n    return row[0] === undefined;\n}\n\n// export function assignRowIndices(rows, offset) {\n//     const s1 = new Date().getTime()\n//     for (let i = 0, len = rows.length; i < len; i++) {\n//         rows[i][Data.INDEX_FIELD] = i + offset;\n//     }\n//     const s2 = new Date().getTime()\n//     console.log(`assignRowIndices took ${s2-s1} ms`)\n//     return rows;\n// }\n\nexport function indexRows(rows, indexField) {\n    return addRowsToIndex(rows, {}, indexField)\n}\n\nexport function addRowsToIndex(rows, index, indexField){\n    for (let idx = 0, len=rows.length; idx < len; idx++) {\n        index[rows[idx][indexField]] = idx;\n    }\n    return index;\n}\n\nexport function update(rows, range, updates, {IDX}) {\n    const results = rows.slice();\n\n    for (let i = 0; i < updates.length; i++) {\n        const [idx, ...fieldUpdates] = updates[i];\n        // slow, refactor for performance\n\n        let row;\n        for (let ii = 0; ii < rows.length; ii++) {\n            if (rows[ii][IDX] === idx) {\n                row = rows[ii].slice();\n                // updates = [colIdx, oldValue, newValue]*\n                for (let j = 0; j < fieldUpdates.length; j += 3) {\n                    row[fieldUpdates[j]] = fieldUpdates[j + 2];\n                }\n                results[ii] = row;\n\n                break;\n\n            }\n        }\n    }\n\n    return results;\n}\n\n\n// export so we can test - see if we can't use rewire\n// Called when client calls setRange, locally cached data is immediately\n// trimmed to new range and missing data filled with empty rows. \nexport function purgeAndFill({range:{lo, hi}, rows, offset = 0}, meta) {\n\n    const {IDX} = meta;\n    const results = [];\n    const len = rows.length;\n    const low = lo + offset;\n    const high = hi + offset;\n\n    let row;\n    let firstRowIdx = -1;\n\n\n    // 1) do we need any fills at the beginning ? \n    while (row === undefined && firstRowIdx < len) {\n        firstRowIdx += 1;\n        row = rows[firstRowIdx];\n    }\n\n    let idx = row ? row[IDX] : high;\n\n    const end = Math.min(idx, high);\n    for (let i = low; i < end; i++) {\n        results.push(emptyRow(i, meta));\n    }\n\n    if (end === high) {\n        // we're done if we've already filled the results\n        return results;\n    }\n\n    // 2) existing rows that still fall within range go into results\n    for (let i = firstRowIdx; i < len; i++) {\n        row = rows[i];\n        if (row) {\n            idx = row[IDX];\n            if (idx >= low && idx < high) {\n                results.push(row);\n            }\n        } else {\n            //onsole.log(`rowUtils.purgeAndFill gap at ${i}`);\n            results.push(emptyRow(i, meta));\n        }\n    }\n\n    // 3) pad results to end of range\n    const start = Math.max(idx + 1, low);\n    for (let i = start; i < high; i++) {\n        results.push(emptyRow(i, meta));\n    }\n\n    return results;\n\n}\n\n// TODO create a pool of these and reuse them\nfunction emptyRow(idx, {IDX, count}){\n    const row = Array(count);\n    row[IDX] = idx;\n    return row;\n}\n\n\n// New data is merged into local cache\nexport function mergeAndPurge({range:{lo, hi}, rows, offset = 0}, newRows, size, meta) {\n    // console.groupCollapsed(`mergeAndPurge  existing range: ${lo} - ${hi} \n    //  old   rows: [${rows.length ? rows[0][0]: null} - ${rows.length ? rows[rows.length-1][0]: null}]\n    //  new   rows: [${newRows.length ? newRows[0][0]: null} - ${newRows.length ? newRows[newRows.length-1][0]: null}]\n    //     `);\n    const {IDX} = meta;\n    const results = [];\n    const low = lo + offset;\n    const high = Math.min(hi + offset, size + offset);\n\n    let idx;\n    let row;\n\n    for (let i = 0; i < rows.length; i++) {\n        if (row = rows[i]) {\n            idx = row[IDX];\n            if (idx >= low && idx < high) {\n                results[idx - low] = rows[i];\n            }\n        }\n    }\n\n    for (let i = 0; i < newRows.length; i++) {\n        if (row = newRows[i]) {\n            idx = row[IDX];\n\n            if (idx >= low && idx < high) {\n                results[idx - low] = newRows[i];\n            }\n        }\n    }\n\n    // make sure the resultset contains entries for the full range\n    // TODO make this more efficient\n    const rowCount = hi - lo;\n    for (let i=0;i<rowCount;i++){\n        if (results[i] === undefined){\n            results[i] = emptyRow(i+low, meta);\n        }\n    }\n    // console.log(`results ${JSON.stringify(results,null,2)}`);\n    // console.groupEnd();\n    return results;\n\n}\n\n","/*global fetch */\nimport {EventEmitter} from '@heswell/utils';\nimport {buildColumnMap} from './columnUtils'\n\nconst defaultUpdateConfig = {\n    applyUpdates: false,\n    applyInserts: false,\n    interval: 500\n}\n\nexport default class Table extends EventEmitter {\n\n    constructor(config){\n        super();\n\n        const {name, columns=null, primaryKey, dataPath, data, updates = {}} = config;\n\n        this.name = name;\n        this.primaryKey = primaryKey;\n        this.columns = columns;\n        this.keys = {};\n        this.index = {};\n        this.rows = [];\n        this.updateConfig = {\n            ...defaultUpdateConfig,\n            ...updates\n        }\n        this.columnMap = buildColumnMap(columns);\n        this.columnCount = 0;\n        this.status = null;\n\n        // console.log(`Table \n        //     columns = ${JSON.stringify(columns,null,2)}\n        //     columnMap = ${JSON.stringify(this.columnMap,null,2)}    \n        //     `)\n\n\n        if (data){\n            this.parseData(data);\n        } else if (dataPath){\n            this.loadData(dataPath);\n        }\n\n        this.installDataGenerators(config);\n    }\n\n    // ...updates = one or more pairs of (colIdx, colValue)\n    update(rowIdx, ...updates){\n        //onsole.log(`Table.update ${this.name} idx: ${rowIdx}  ${JSON.stringify(updates)}` );\n        const results = [];\n        let row = this.rows[rowIdx];\n        for (let i=0;i<updates.length;i+=2){\n            const colIdx = updates[i];\n            const value = updates[i+1];\n            results.push(colIdx, row[colIdx], value);\n            row[colIdx] = value;\n        }\n        this.emit('rowUpdated', rowIdx, results);\n    }\n\n    insert(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const idx = this.rows.length;\n        let row = this.rowFromData(idx, data, columnnameList);\n        this.rows.push(row);\n        this.emit('rowInserted', idx, row);\n    }\n\n    remove(key){\n        if (this.keys[key]){\n            const index = this.indices[key];\n            delete this.keys[key];\n            delete this.indices[key];\n            this.rows.splice(index,1);\n\n            for (let k in this.indices){\n                if (this.indices[k] > index){\n                    this.indices[k] -= 1;\n                }\n            }\n\n            this.emit('rowRemoved', this.name, key);\n\n        }\n    }\n\n    clear(){\n\n    }\n\n    toString(){\n        const out = ['\\n' + this.name];\n        out.splice.apply(out, [1,0].concat(this.rows.map(function(row){return row.toString();})));\n        return out.join('\\n');\n    }\n\n    async loadData(url){\n        fetch(url,{\n\n        })\n            .then(data => data.json())\n            .then(json => {\n                console.log(`Table.loadData: got ${json.length} rows`);\n                this.parseData(json);\n            })\n            .catch(err => {\n                console.error(err);\n            });\n\n    }\n\n    parseData(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const rows = [];\n        for (let i=0;i<data.length;i++){\n            let row = this.rowFromData(i, data[i], columnnameList);\n            rows.push(row);\n        }\n        this.rows = rows;\n\n        if (this.columns === null){\n            this.columns = columnsFromColumnMap(this.inputColumnMap);\n            this.columnMap = buildColumnMap(this.columns);\n        }\n        this.status = 'ready';\n        this.emit('ready');\n        if (this.updateConfig && this.updateConfig.applyUpdates !== false){\n            setTimeout(() => {\n                this.applyUpdates();\n            },1000);\n        }\n        // move this\n        if (this.updateConfig && this.updateConfig.applyInserts !== false){\n            setTimeout(() => {\n                this.applyInserts();\n            },10000);\n        }\n    }\n\n    rowFromData(idx, data, columnnameList){\n        // 2 metadata items for each row, the idx and unique key\n        const {index, primaryKey=null, columnMap: map} = this;\n\n        if (Array.isArray(data)){\n            const key = data[map[this.primaryKey]];\n            index[key] = idx;\n            return [...data, idx, key];\n        } else {\n            // This allows us to load data from objects as rows, without predefined columns, where\n            // not every row may have every column. How would we handle primary key ?\n            const columnMap = map || (this.columnMap = {});\n            const colnames = columnnameList || Object.getOwnPropertyNames(data);\n            const row = [idx];\n            let colIdx;\n            let key;\n\n            for (let i=0; i<colnames.length; i++){\n                const name = colnames[i];\n                const value = data[name];\n                if ((colIdx = columnMap[name]) === undefined){\n                    colIdx = columnMap[name] = this.columnCount++;\n                }\n                row[colIdx] = value;\n                // If we don't know the primary key, assume it is the first column for now\n                if ((name === primaryKey) || (primaryKey === null && i === 0)){\n                    key = value;\n                    index[value] = idx;\n                }\n            }\n            // doesn't this risk pushing the metadata into the wrong slots if not every row has every \n            // field\n            row.push(idx, key)\n            return row;\n        }\n    }\n\n    //TODO move all these methods into an external helper\n    applyInserts(){\n\n        const idx = this.rows.length;\n        const newRow = this.createRow(idx);\n        if (newRow){\n            this.insert(newRow);\n        } else {\n            console.log(`createRow did not return a new row`);\n        }\n\n        setTimeout(() => this.applyInserts(),5000);\n\n    }\n\n    applyUpdates(){\n        const {rows} = this;\n        // const count = Math.round(rows.length / 50);\n        const count = 100;\n\n        for (let i=0; i<count; i++){\n            const rowIdx = getRandomInt(rows.length - 1);\n            const update = this.updateRow(rowIdx, this.rows[rowIdx], this.columnMap);\n            if (update){\n                this.update(rowIdx, ...update);\n            }\n        }\n\n        setTimeout(() => this.applyUpdates(),this.updateConfig.interval);\n\n    }\n\n    createRow(idx){\n        console.warn(`createRow ${idx} must be implemented as a plugin`);\n    }\n\n    updateRow(/*idx, row, columnMap*/){\n        return null;\n    }\n\n    async installDataGenerators(/*config*/){\n        //console.warn(`installDataGenerators must be implemented by a more specific subclass`);\n    }\n\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction columnsFromColumnMap(columnMap){\n\n    const columnNames = Object.getOwnPropertyNames(columnMap);\n\n    return columnNames\n        .map(name => ({name, key: columnMap[name]}))\n        .sort(byKey)\n        .map(({name}) => ({name}));\n\n}\n\nfunction byKey(col1, col2){\n    return col1.key - col2.key;\n}\n","export const CHECKBOX = 'checkbox';\nexport const SINGLE_ROW = 'single-row';\nexport const MULTIPLE_ROW = 'multiple-row';\n\nexport const SelectionModelType = {\n  Checkbox: CHECKBOX,\n  SingleRow: SINGLE_ROW,\n  MultipleRow: MULTIPLE_ROW\n};\n\nconst {Checkbox, SingleRow, MultipleRow} = SelectionModelType;\n\nconst EMPTY = [];\n\nexport function selectionDiffers(selected1, selected2){\n  const len = selected1.length;\n  if (len !== selected2.length){\n      return true;\n  }\n  for (let i=0;i<len;i++){\n      if (selected1[i] !== selected2[i]){\n          return true;\n      }\n  }\n  return false;\n}\n\nexport default class SelectionModel {\n\n    constructor(selectionModelType=MultipleRow){\n      this.modelType = selectionModelType;\n    }\n\n    select({rows:selection, lastTouchIdx}, idx, rangeSelect, keepExistingSelection){\n        \n        let selected, deselected;\n\n        if (this.modelType === SingleRow){\n            [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n            lastTouchIdx = idx;\n        } else if (rangeSelect){\n            [selection, selected, deselected] = this.handleRangeSelection(selection, lastTouchIdx, idx);\n        } else if (keepExistingSelection || this.modelType === Checkbox){\n            [selection, selected, deselected] = this.handleIncrementalSelection(selection, idx);\n            lastTouchIdx = idx;\n        } else {\n            [selection, selected, deselected] = this.handleRegularSelection(selection, idx);\n            lastTouchIdx = idx;\n        }\n\n        return {\n          focusedIdx: idx,\n          lastTouchIdx,\n          rows: selection,\n          selected,\n          deselected\n        };\n\n    }\n\n    handleRegularSelection(selected, idx){\n        const pos = selected.indexOf(idx);\n        if (pos === -1){\n            const selection = [idx];\n            return [selection, selection, selected];\n        } else if (selected.length === 1){\n            return [EMPTY, EMPTY, selected];\n        } else {\n          return [EMPTY, EMPTY, remove(selected,idx)];\n        }\n    }\n\n    handleIncrementalSelection(selected, idx){\n        const pos = selected.indexOf(idx);\n        const len = selected.length;\n        const selection = [idx];\n\n        if (pos === -1){\n          if (len === 0){\n              return [selection, selection,EMPTY];\n            } else {\n                return [insert(selected,idx), selection, EMPTY];\n            }\n        } else {\n            if (len === 1){\n                return [EMPTY, EMPTY, selected];\n            } else {\n                return [remove(selected,idx), EMPTY, selection];\n            }\n        }\t\t\n    }\n\n    handleRangeSelection(selected, lastTouchIdx, idx){\n\n        const pos = selected.indexOf(idx);\n        const len = selected.length;\n\n        if (pos === -1){\n\n            if (len === 0){\n                const selection = makeRange(0,idx);\n                return [selection, selection, EMPTY];\n            } else if (len === 1){\n                const selection = makeRange(selected[0],idx);\n                selected = selected[0] < idx\n                  ? selection.slice(1)\n                  : selection.slice(0,-1);\n                return [selection, selected, EMPTY];\n            } else {\n                const selection = applyRange(selected,lastTouchIdx,idx);\n                return [selection, selection.filter(i => !selected.includes(i)), EMPTY];\n            }\n        } else {\n          // TODO <<<<<<<<<<<<<<<<<\n        }\n    }\n\n};\n\nfunction applyRange(arr, lo, hi){\n\n    if (lo > hi) {[lo, hi] = [hi, lo];}\n\n    const ranges = getRanges(arr);\n    const newRange = new Range(lo,hi);\n    let newRangeAdded = false;\n    const ret = [];\n\n    for (let i=0;i<ranges.length;i++){\n        const range = ranges[i];\n\n        if (!range.overlaps(newRange)){\n            if (range.start < newRange.start){\n                for (let idx=range.start;idx<=range.end;idx++){\n                    ret.push(idx);\n                }\n            } else {\n                for (let idx=newRange.start;idx<=newRange.end;idx++){\n                    ret.push(idx);\n                }\n                newRangeAdded = true;\n                for (let idx=range.start;idx<=range.end;idx++){\n                    ret.push(idx);\n                }\n            }\n        } else if (!newRangeAdded){\n            for (let idx=newRange.start;idx<=newRange.end;idx++){\n                ret.push(idx);\n            }\n            newRangeAdded = true;\n        }\n    }\n\n    if (!newRangeAdded){\n        for (let idx=newRange.start;idx<=newRange.end;idx++){\n            ret.push(idx);\n        }\n    }\n\n    return ret;\n}\n\nfunction getRanges(arr){\n\n    const ranges = [];\n    let range;\n\n    for (let i=0;i<arr.length;i++){\n        if (range && range.touches(arr[i])){\n            range.extend(arr[i]);\n        } else {\n            ranges.push(range = new Range(arr[i]));\n        }\n    }\n\n    return ranges;\n\n}\n\nclass Range {\n\n    constructor(start, end=start){\n        this.start = start;\n        this.end = end;\n    }\n\n    extend(idx){\n        if (idx >= this.start && idx > this.end){\n            this.end = idx;\n        }\n    }\n\n    touches(idx){\n        return this.end === idx-1;\n    }\n\n    overlaps(that){\n        return !(this.end < that.start || this.start > that.end);\n    }\n\n    contains(idx){\n        return this.start <= idx && this.end >= idx;\n    }\n\n    toString(){\n        return `[${this.start}:${this.end}]`;\n    }\n}\n\nfunction makeRange(lo, hi){\n    if (lo > hi) {[lo, hi] = [hi, lo];}\n\n    const range = [];\n    for (let idx=lo;idx<=hi;idx++){\n        range.push(idx);\n    }\n    return range;\n}\n\nfunction remove(arr, idx){\n    const ret = [];\n    for (let i=0;i<arr.length;i++){\n        if (idx !== arr[i]){\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\n\nfunction insert(arr, idx){\n    const ret = [];\n    for (let i=0;i<arr.length;i++){\n        if (idx !== null && idx < arr[i]){\n            ret.push(idx);\n            idx = null;\n        }\n        ret.push(arr[i]);\n    }\n    if (idx !== null){\n        ret.push(idx);\n    }\n    return ret;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","/**\n * Keep all except for groupRowset in this file to avoid circular reference warnings\n */\nimport * as d3 from 'd3-array';\nimport Table from '../table';\nimport SelectionModel from '../selection-model';\nimport { sort, sortExtend, sortReversed, sortBy, sortPosition, sortableFilterSet } from '../sort';\nimport { \n    BIN_FILTER_DATA_COLUMNS,\n    SET_FILTER_DATA_COLUMNS,\n    extendsFilter,\n    extractFilterForColumn,\n    functor as filterPredicate,\n    splitFilterOnColumn,\n    overrideColName\n} from '../filter';\nimport { addRowsToIndex } from '../rowUtils';\nimport { groupbyExtendsExistingGroupby } from '../groupUtils';\nimport { projectColumns, projectColumnsFilter, mapSortCriteria, metaData } from '../columnUtils';\nimport { DataTypes } from '../types';\nimport { getDeltaRange, getFullRange, NULL_RANGE } from '../rangeUtils';\n\nconst SINGLE_COLUMN = 1;\n\nconst NO_OPTIONS = {\n    filter: null\n}\n\nexport default class BaseRowSet {\n\n    constructor(table, columns, offset = 0) {\n        this.table = table;\n        this.offset = offset;\n        this.baseOffset = offset;\n        this.range = NULL_RANGE;\n        this.columns = columns;\n        this.currentFilter = null;\n        this.filterSet = null;\n        this.columnMap = table.columnMap;\n        this.meta = metaData(columns);\n        this.data = table.rows;\n        this.selected = {rows: [], focusedIdx: -1, lastTouchIdx: -1};\n        this.selectionModel = new SelectionModel();\n    }\n\n    // used by binned rowset\n    get filteredData() {\n        if (this.filterSet) {\n            return this.filterSet;\n        } else {\n            const { IDX } = this.meta;\n            return this.data.map(row => row[IDX])\n        }\n    }\n\n    get filterCount(){\n        return this.filterSet\n            ? this.filterSet.length\n            : this.data.length;\n    }\n\n    setRange(range=this.range, useDelta = true) {\n\n        const { lo, hi } = useDelta ? getDeltaRange(this.range, range) : getFullRange(range);\n        const resultset = this.slice(lo, hi);\n        this.range = range;\n        return {\n            rows: resultset,\n            range,\n            size: this.size,\n            offset: this.offset\n        };\n    }\n\n    currentRange() {\n        const { lo, hi } = this.range;\n        const resultset = this.slice(lo, hi);\n        return {\n            rows: resultset,\n            range: this.range,\n            size: this.size,\n            offset: this.offset\n        };\n    }\n\n    select(idx, rangeSelect, keepExistingSelection){\n        console.log(`RowSet.select ${idx} rangeSelect:${rangeSelect}, keepExistingSelection: ${keepExistingSelection}`)\n        \n        const {selected, deselected, ...selectionState} = this.selectionModel.select(\n            this.selected,\n            idx,\n            rangeSelect,\n            keepExistingSelection\n        );\n        \n        this.selected = selectionState;\n\n        return {selected, deselected};\n    }\n\n    selectNavigationSet(useFilter) {\n        const { COUNT, IDX_POINTER, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        return useFilter\n            ? [this.filterSet, NEXT_FILTER_IDX, FILTER_COUNT]\n            : [this.sortSet, IDX_POINTER, COUNT];\n    }\n\n    //TODO cnahge to return a rowSet, same as getDistinctValuesForColumn\n    getBinnedValuesForColumn(column) {\n        const key = this.columnMap[column.name];\n        const { data: rows, filteredData } = this;\n        const numbers = filteredData.map(rowIdx => rows[rowIdx][key]);\n        const data = d3.histogram().thresholds(20)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n\n        const table = new Table({ data, primaryKey: 'bin', columns: BIN_FILTER_DATA_COLUMNS });\n        const filterRowset = new BinFilterRowSet(table, BIN_FILTER_DATA_COLUMNS, column.name);\n        return filterRowset;\n    }\n\n    getDistinctValuesForColumn(column) {\n        const { data: rows, columnMap, currentFilter } = this;\n        const colIdx = columnMap[column.name]\n        const resultMap = {};\n        const data = [];\n        const dataRowCount = rows.length;\n        const [/*columnFilter*/, otherFilters] = splitFilterOnColumn(currentFilter, column)\n        // this filter for column that we remove will provide our selected values   \n        let dataRowAllFilters = 0;\n\n        if (otherFilters === null) {\n            let result;\n            for (let i = 0; i < dataRowCount; i++) {\n                const val = rows[i][colIdx];\n                if (result = resultMap[val]) {\n                    result[2] = ++result[1];\n                } else {\n                    result = [val, 1, 1]\n                    resultMap[val] = result;\n                    data.push(result)\n                }\n            }\n            dataRowAllFilters = dataRowCount;\n        } else {\n\n            const fn = filterPredicate(columnMap, otherFilters);\n            let result;\n\n            for (let i = 0; i < dataRowCount; i++) {\n                const row = rows[i];\n                const val = row[colIdx];\n                const isIncluded = fn(row) ? 1 : 0;\n                if (result = resultMap[val]) {\n                    result[1] += isIncluded;\n                    result[2]++;\n                } else {\n                    result = [val, isIncluded, 1]\n                    resultMap[val] = result;\n                    data.push(result)\n                }\n                dataRowAllFilters += isIncluded;\n            }\n        }\n\n        //TODO primary key should be indicated in columns\n        const table = new Table({ data, primaryKey: 'name', columns: SET_FILTER_DATA_COLUMNS });\n        return new SetFilterRowSet(table, SET_FILTER_DATA_COLUMNS, column.name, dataRowAllFilters, dataRowCount);\n\n    }\n}\n\n//TODO should range be baked into the concept of RowSet ?\nexport class RowSet extends BaseRowSet {\n\n    // TODO stream as above\n    static fromGroupRowSet({ table, columns, offset, currentFilter: filter }) {\n        return new RowSet(table, columns, offset, {\n            filter\n        });\n    }\n    //TODO consolidate API of rowSet, groupRowset\n    constructor(table, columns, offset = 0, { filter = null } = NO_OPTIONS) {\n        super(table, columns, offset);\n        this.project = projectColumns(table.columnMap, columns, this.meta);\n        this.sortCols = null;\n        this.sortReverse = false;\n        this.sortSet = this.buildSortSet();\n        this.filterSet = null;\n        this.sortRequired = false;\n        if (filter) {\n            this.currentFilter = filter;\n            this.filter(filter);\n        }\n\n    }\n\n    buildSortSet() {\n        const len = this.data.length;\n        const arr = Array(len);\n        for (let i = 0; i < len; i++) {\n            arr[i] = [i, null, null];\n        }\n        return arr;\n    }\n\n    slice(lo, hi) {\n        const {selectedSet} = this;\n        if (this.filterSet) {\n            const filteredData = this.filterSet.slice(lo, hi);\n            const filterMapper = typeof filteredData[0] === 'number'\n                ? idx => this.data[idx]\n                : ([idx]) => this.data[idx];\n            return filteredData\n                .map(filterMapper)\n                .map(this.project(lo + this.offset, selectedSet));\n        } else if (this.sortCols) {\n            const sortSet = this.sortSet;\n            const results = []\n            for (let i = lo, rows = this.data, len = rows.length; i < len && i < hi; i++) {\n                const idx = this.sortReverse\n                    ? sortSet[len - i - 1][0]\n                    : sortSet[i][0];\n                const row = rows[idx];\n                results.push(row);\n            }\n            return results.map(this.project(lo + this.offset, selectedSet));\n        } else {\n            return this.data.slice(lo, hi).map(this.project(lo + this.offset, selectedSet));\n        }\n    }\n\n    // deprecated\n    get size() {\n        return this.filterSet === null\n            ? this.data.length\n            : this.filterSet.length\n    }\n\n    get first() {\n        return this.data[0];\n    }\n    get last() {\n        return this.data[this.data.length - 1];\n    }\n    get rawData() {\n        return this.data;\n    }\n\n    setStatus(status) {\n        this.status = status;\n    }\n\n    addRows(rows) {\n        addRowsToIndex(rows, this.index, this.meta.IDX);\n        this.data = this.data.concat(rows);\n    }\n\n    sort(sortCols) {\n\n        const sortSet = this.currentFilter === null\n            ? this.sortSet\n            : this.filterSet = sortableFilterSet(this.filterSet);\n\n        this.sortRequired = this.currentFilter !== null;\n\n        if (sortReversed(this.sortCols, sortCols, SINGLE_COLUMN)) {\n            this.sortReverse = !this.sortReverse;\n        } else if (this.sortCols !== null && groupbyExtendsExistingGroupby(sortCols, this.sortCols)) {\n            this.sortReverse = false;\n            sortExtend(sortSet, this.data, this.sortCols, sortCols, this.columnMap)\n        } else {\n            this.sortReverse = false;\n            sort(sortSet, this.data, sortCols, this.columnMap)\n        }\n\n        this.sortCols = sortCols;\n\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        if (this.sortRequired) {\n            this.sort(this.sortCols);\n        }\n    }\n\n    filter(filter) {\n        const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n        const fn = filter && filterPredicate(this.columnMap, filter);\n        const { data: rows } = this;\n        let [navSet] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet)\n        const newFilterSet = [];\n\n        for (let i = 0; i < navSet.length; i++) {\n            const rowIdx = navSet === this.filterSet ? navSet[i] : navSet[i][0];\n            const row = rows[rowIdx];\n            if (fn(row)) {\n                newFilterSet.push(rowIdx)\n            }\n\n        }\n        this.filterSet = newFilterSet;\n        this.currentFilter = filter;\n        if (!extendsCurrentFilter && this.sortRequired) {\n            // TODO this might be very expensive for large dataset\n            // WHEN DO WE DO THIS - IS THIS CORRECT !!!!!\n            this.sort(this.sortCols)\n        }\n        return newFilterSet.length;\n\n    }\n\n    update(idx, updates) {\n        if (this.currentFilter === null && this.sortCols === null) {\n            if (idx >= this.range.lo && idx < this.range.hi) {\n                return [idx + this.offset, ...updates];\n            }\n        } else if (this.currentFilter === null) {\n            const { sortSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const [rowIdx] = sortSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        } else {\n            // sorted AND/OR filtered\n            const { filterSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const rowIdx = Array.isArray(filterSet[i]) ? filterSet[i][0] : filterSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        }\n    }\n\n    insert(idx, row) {\n        // TODO multi colun sort sort DSC \n        if (this.sortCols === null && this.currentFilter === null) {\n            // simplest scenario, row will be at end of sortset ...\n            this.sortSet.push([idx, null, null]);\n            if (idx >= this.range.hi) {\n                // ... row is beyond viewport\n                return {\n                    size: this.size\n                }\n            } else {\n                // ... row is within viewport\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            }\n        } else if (this.currentFilter === null) {\n            // sort only\n            const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n            const [[colIdx]] = sortCols;\n            const sortRow = [idx, row[colIdx]];\n            const sorter = sortBy([[1, 'asc']]);\n            const sortPos = sortPosition(this.sortSet, sorter, sortRow, 'last-available');\n            this.sortSet.splice(sortPos, 0, sortRow);\n\n            if (sortPos >= this.range.hi) {\n                return {\n                    size: this.size\n                }\n            } else if (sortPos >= this.range.lo) {\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            } else {\n                return {\n                    size: this.size,\n                    offset: this.offset - 1\n                }\n            }\n\n        } else if (this.sortCols === null) {\n            // filter only\n            const fn = filterPredicate(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                const navIdx = this.filterSet.length;\n                this.filterSet.push(idx);\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n        } else {\n            // sort AND filter\n            const fn = filterPredicate(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                // TODO what about totalCOunt\n\n                const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n                const [[colIdx]] = sortCols; // TODO multi-colun sort\n                const sortRow = [idx, row[colIdx]];\n                const sorter = sortBy([[1, 'asc']]); // TODO DSC\n                const navIdx = sortPosition(this.filterSet, sorter, sortRow, 'last-available');\n                this.filterSet.splice(navIdx, 0, sortRow);\n\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n\n        }\n    }\n}\n\n// TODO need to retain and return any searchText\nexport class SetFilterRowSet extends RowSet {\n    constructor(table, columns, columnName, dataRowAllFilters, dataRowTotal) {\n        super(table, columns);        \n        this.columnName = columnName;\n        this._searchText = null;\n        this.dataRowFilter = null;\n        this.dataCounts = {\n            dataRowTotal,\n            dataRowAllFilters,\n            dataRowCurrentFilter : 0,\n            filterRowTotal : this.data.length,\n            filterRowSelected : this.data.length,\n            filterRowHidden : 0\n        };\n        this.setProjection();\n        this.sort([['name', 'asc']]);\n    }\n\n    get searchText() {\n        return this._searchText;\n    }\n\n    set searchText(text) {\n        // TODO\n        console.log(`FilterRowset set text = '${text}'`)\n        this.selectedCount = this.filter({ type: 'SW', colName: 'name', value: text });\n        const {filterSet, data: rows} = this;\n        // let totalCount = 0;\n        const colIdx = this.columnMap.totalCount;\n        for (let i=0;i<filterSet.length;i++){\n            const row = rows[filterSet[i]];\n            // totalCount += row[colIdx];\n        }\n        // this.totalCount = totalCount;\n        this._searchText = text;\n    }\n\n\n    currentRange(){\n        //TODO move these into a single struct\n\n            return {\n                ...super.currentRange(),\n                //TODO is this necessary, these won't change on a range request\n                dataCounts: this.dataCounts\n            }\n    \n    }\n    \n    setRange(range, useDelta){\n\n        return {\n            ...super.setRange(range, useDelta),\n            //TODO is this necessary, these won't change on a range request\n            dataCounts: this.dataCounts\n        }\n    }\n\n    filter(filter){\n        super.filter(filter);\n\n        const {dataCounts, filterSet, data: rows, dataRowFilter, table, columnName} = this;\n        let columnFilter;\n\n        if (dataRowFilter && (columnFilter = extractFilterForColumn(dataRowFilter, columnName))){\n            const columnMap = table.columnMap;\n            const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'name'), true);\n            dataCounts.filterRowSelected = filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0) \n                \n        } else {\n            dataCounts.filterRowSelected = filterSet.length;\n        }\n\n        dataCounts.filterRowTotal = filterSet.length;\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        this._searchText = '';\n    }\n\n\n    get values() {\n        const key = this.columnMap['name'];\n        return this.filterSet.map(idx => this.data[idx][key])\n    }\n\n    setSelected(dataRowFilter, dataRowAllFilters) {\n\n        const columnFilter = extractFilterForColumn(dataRowFilter, this.columnName);\n        const columnMap = this.table.columnMap;\n        const {dataCounts, data: rows, filterSet} = this;\n\n        this.dataRowFilter = dataRowFilter;\n        \n        if (columnFilter){\n            const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'name'), true);\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0) \n                : rows.reduce((count, row) => count + (fn(row) ? 1 : 0),0) \n        } else {\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.length\n                : rows.length;\n        }\n\n        dataCounts.dataRowAllFilters = dataRowAllFilters;\n\n        this.setProjection(columnFilter);\n\n        console.log(`SetFilterRowSet.setSelected selectedCount ${dataCounts.filterRowSelected} current range ${JSON.stringify(this.range)}`)\n        return this.currentRange();\n\n    }\n\n    setProjection(columnFilter = null){\n\n        const columnMap = this.table.columnMap;\n\n        this.project = projectColumnsFilter(\n            columnMap,\n            this.columns,\n            this.meta,\n            columnFilter\n        );\n\n    }\n\n}\n\nexport class BinFilterRowSet extends RowSet {\n    constructor(table, columns, columnName) {\n        super(table, columns);\n        this.type = DataTypes.FILTER_BINS;\n        this.columnName = columnName;\n    }\n\n    setSelected(filter){\n        console.log(`need to apply filter to selected BinRowset`, filter)\n    }\n    // we don't currently have a concept of range here, but it will\n    // be used in the future\n    // Note: currently no projection here, we don't currently need metadata\n    setRange() {\n        console.log(`BinFilterRowset.setRange`)\n        return {\n            type: this.type,\n            rows: this.data,\n            range: null,\n            size: this.size,\n            offset: 0\n        };\n    }\n\n}\n","import { NULL_RANGE, compareRanges, RangeFlags, getFullRange, getDeltaRange } from './rangeUtils';\nimport {getCount} from './groupUtils';\n\n\nconst RANGE_POS_TUPLE_SIZE = 4;\nconst NO_RESULT = [null,null,null]\n\nexport const FORWARDS = 0;\nexport const BACKWARDS = 1;\nexport default function GroupIterator(groups, navSet, data, NAV_IDX, NAV_COUNT, meta) {\n    let _idx = 0;\n    let _grpIdx = null;\n    let _rowIdx = null;\n    let _direction = FORWARDS;\n    let _range = NULL_RANGE;\n    let _range_position_lo = [0, null, null];\n    let _range_positions = [];\n    let _range_position_hi = [null, null, null];\n\n    return {\n        get direction(){ return _direction },\n        get rangePositions(){ return _range_positions },\n        setRange,\n        currentRange,\n        getRangeIndexOfGroup,\n        getRangeIndexOfRow,\n        setNavSet,\n        refresh: currentRange,\n        clear\n    };\n\n\n    function getRangeIndexOfGroup(grpIdx){\n        const list = _range_positions;\n        for (let i=0; i< list.length; i += RANGE_POS_TUPLE_SIZE){\n            if (list[i+1] === grpIdx) {\n                if (list[i+2] === null){\n                    return i/RANGE_POS_TUPLE_SIZE;\n                } else {\n                    // first row encountere should be the group, if it\n                    // isn't it means it is crolled out of viewport\n                    return -1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function getRangeIndexOfRow(idx){\n        const list = _range_positions;\n        for (let i=0; i< list.length; i += RANGE_POS_TUPLE_SIZE){\n            if (list[i+3] === idx) {\n                return i/RANGE_POS_TUPLE_SIZE;\n            }\n        }\n        return -1\n    }\n\n    function clear(){\n        _idx = 0;\n        _grpIdx = null;\n        _rowIdx = null;\n        _direction = FORWARDS;\n        _range = NULL_RANGE;\n        _range_position_lo = [0, null, null];\n        _range_positions = [];\n        _range_position_hi = [null, null, null];\n    }\n\n    function setNavSet([newNavSet, navIdx, navCount]){\n        navSet = newNavSet;\n        NAV_IDX = navIdx;\n        NAV_COUNT = navCount;\n    }\n\n    function currentRange(){\n        const rows = [];\n        const {IDX} = meta;\n        ([_idx, _grpIdx, _rowIdx] = _range_position_lo);\n        if (_idx === 0 && _grpIdx === null && _rowIdx === null){\n            _idx = -1;\n        }\n        _range_positions.length = 0;\n\n        let startIdx = _idx;\n        let row;\n        let i = _range.lo;\n        do {\n            _direction = FORWARDS;\n            ([row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n            if (row){\n                rows.push(row);\n                _idx += 1;\n                const absRowIdx = _rowIdx === null ? null : row[IDX];\n                _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n                i += 1\n            }\n        } while (row && i < _range.hi)\n        if (row){\n            _direction = FORWARDS;\n            const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n            [row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n            _idx += 1;\n            _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n            ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n        } else {\n            _range_position_hi = [null,null,null];\n        }\n\n        return [rows, startIdx+1];\n\n    }\n\n    function setRange(range, useDelta=true){\n        const rangeDiff = compareRanges(_range, range);\n        const { lo: resultLo, hi: resultHi } = useDelta ? getDeltaRange(_range, range) : getFullRange(range);\n        const {IDX} = meta;\n\n        if (rangeDiff === RangeFlags.NULL){\n            _range_position_lo = [0,null,null];\n            _range_position_hi = [null,null,null];\n            _range_positions.length = 0;\n            return [[],null];\n        } else if (range.lo === _range.lo && useDelta === false){\n            // when we're asked for the same range again, rebuild the range\n            ([_idx, _grpIdx, _rowIdx] = _range_position_lo);\n            _range_positions.length = 0;\n        } else {\n\n            if (_direction === FORWARDS && (rangeDiff & RangeFlags.BWD)){\n                ([_idx, _grpIdx, _rowIdx] = _range_positions);\n            } else if (_direction === BACKWARDS && (rangeDiff & RangeFlags.FWD)){\n                ([_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE));\n                _idx += 1;\n            }\n\n            if (rangeDiff === RangeFlags.FWD){\n                skip(range.lo - _range.hi, next);\n                _range_positions.length = 0;\n            } else if (rangeDiff === RangeFlags.BWD){\n                skip(_range.lo - range.hi, previous);\n                _range_positions.length = 0;\n            }\n\n            const loDiff = range.lo - _range.lo;\n            const hiDiff = _range.hi - range.hi;\n            // allow for a range that overshoots data\n            const missingQuota = (_range.hi - _range.lo) - _range_positions.length/RANGE_POS_TUPLE_SIZE;\n\n            if (loDiff > 0){\n                const removed = _range_positions.splice(0,loDiff*RANGE_POS_TUPLE_SIZE);\n                if (removed.length){\n                    _range_position_lo = removed.slice(-RANGE_POS_TUPLE_SIZE);\n\n                    // experiment - is this A) always correct B) enough\n                    if (useDelta === false){\n                        [_idx, _grpIdx, _rowIdx] = _range_position_lo;\n                    }\n\n                }\n            }\n            if (hiDiff > 0){\n                //TODO allow for scenatio where both lo and HI have changed\n                if (hiDiff > missingQuota){\n                    const absDiff = hiDiff - missingQuota;\n                    const removed = _range_positions.splice(-absDiff*RANGE_POS_TUPLE_SIZE,absDiff*RANGE_POS_TUPLE_SIZE);\n                    if (removed.length){\n                        _range_position_hi = removed.slice(0,RANGE_POS_TUPLE_SIZE);\n                    }\n                }\n            }\n\n        }\n\n        const rows = [];\n        let row;\n        let startIdx = null;\n\n        if ((rangeDiff & RangeFlags.REDUCE) === 0){\n            if ((rangeDiff & RangeFlags.FWD) || (rangeDiff === RangeFlags.SAME)){\n                let i = resultLo;\n                startIdx = _idx;\n                do {\n                    _direction = FORWARDS;\n                    ([row, _grpIdx, _rowIdx] = next(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    if (row){\n                        rows.push(row);\n                        const absRowIdx = _rowIdx === null ? null : row[IDX];\n                        _range_positions.push(_idx, _grpIdx, _rowIdx, absRowIdx);\n                        i += 1\n                        _idx += 1;\n                    }\n                } while (row && i < resultHi)\n                if (row){\n                    _direction = FORWARDS;\n                    const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n                    ([row, _grpIdx, _rowIdx] = next(groups, data ,_grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    _range_position_hi = [row ? _idx : null, _grpIdx, _rowIdx];\n                    ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n                } else {\n                    _range_position_hi = [null,null,null];\n                }\n\n            } else {\n                let i = resultHi - 1;\n                do {\n                    _direction = BACKWARDS;\n                    ([row, _grpIdx, _rowIdx] = previous(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta));\n                    if (row){\n                        _idx -= 1;\n                        rows.unshift(row);\n                        const absRowIdx = _rowIdx === null ? null : row[IDX];\n                        _range_positions.unshift(_idx, _grpIdx, _rowIdx, absRowIdx);\n                        i -= 1\n                    }\n                } while (row && i >= resultLo)\n                startIdx = _idx;\n                if (row){\n                    const [grpIdx, rowIdx] = [_grpIdx, _rowIdx];\n                    _direction = BACKWARDS;\n                    [row, _grpIdx, _rowIdx] = previous(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n                    _range_position_lo = [row ? _idx-1 : 0, _grpIdx, _rowIdx];\n                    ([_grpIdx, _rowIdx] = [grpIdx, rowIdx]);\n                } else {\n                    _range_position_lo = [0,null,null];\n                }\n\n            }\n\n        } else {\n            // reduced range, adjust the current pos. DIrection can only be a guess, but if it's wrong\n            // the appropriate adjustment will be made nest time range is set\n            if (rangeDiff & RangeFlags.FWD){\n                console.log(`adjust thye idx`);\n                ([_idx, _grpIdx, _rowIdx] = _range_positions.slice(-RANGE_POS_TUPLE_SIZE));\n                _idx += 1;\n            } else {\n                ([_idx, _grpIdx, _rowIdx] = _range_positions);\n            }\n        }\n\n        _range = range;\n        return [rows, startIdx];\n    }\n\n    function skip(n, fn){\n\n        let i=0;\n        let row;\n\n        do {\n            [row, _grpIdx, _rowIdx] = fn(groups, data, _grpIdx, _rowIdx, navSet, NAV_IDX, NAV_COUNT, meta);\n            if (fn === next){\n                _idx += 1;\n            } else {\n                _idx -= 1;\n            }\n            i += 1;\n\n        } while (row && i < n)\n        if (fn === next){\n            _range_position_lo = [_idx-1, _grpIdx, _rowIdx];\n        } else {\n            _range_position_hi = [_idx, _grpIdx, _rowIdx];\n        }\n    }\n\n}\n\nfunction getAbsRowIdx(group, relRowIdx, navSet, NAV_IDX){\n    return navSet[group[NAV_IDX] + relRowIdx];\n}\n\nfunction next(groups, rows, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta){\n    if (grpIdx === null){\n        grpIdx = -1;\n        do {\n            grpIdx += 1;\n        } while (grpIdx < groups.length && (\n            (getCount(groups[grpIdx],NAV_COUNT) === 0)\n        ));\n\n        if (grpIdx >= groups.length){\n            return NO_RESULT;\n        } else {\n            return [groups[grpIdx], grpIdx, null];\n        }\n    } else if (grpIdx >= groups.length){\n        return NO_RESULT;\n    } else {\n        let groupRow = groups[grpIdx];\n        const depth = groupRow[meta.DEPTH];\n        const count = getCount(groupRow,NAV_COUNT);\n        // Note: we're unlikely to be passed the row if row count is zero\n        if (depth === 1 && count !== 0 && (rowIdx === null || rowIdx < count - 1)){\n            rowIdx = rowIdx === null ? 0 : rowIdx + 1;\n            const absRowIdx = getAbsRowIdx(groupRow, rowIdx, navSet, NAV_IDX)\n            // the equivalent of project row\n            const row = rows[absRowIdx].slice()\n            row[meta.IDX] = absRowIdx;\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n            return [row, grpIdx, rowIdx === null ? 0 : rowIdx];\n        } else if (depth > 0){\n\n            do {\n                grpIdx += 1;\n            } while (grpIdx < groups.length && (\n                (getCount(groups[grpIdx],NAV_COUNT) === 0)\n            ));\n            if (grpIdx >= groups.length){\n                return NO_RESULT;\n            } else {\n                return [groups[grpIdx], grpIdx, null];\n            }\n        } else {\n            const absDepth = Math.abs(depth);\n            do {\n                grpIdx += 1;\n            } while (grpIdx < groups.length && (\n                (Math.abs(groups[grpIdx][meta.DEPTH]) < absDepth) ||\n                (getCount(groups[grpIdx],NAV_COUNT) === 0)\n            ));\n            if (grpIdx >= groups.length){\n                return NO_RESULT;\n            } else {\n                return [groups[grpIdx], grpIdx, null];\n            }\n        }\n    }\n}\n\nfunction previous(groups, data, grpIdx, rowIdx, navSet, NAV_IDX, NAV_COUNT, meta){\n    if (grpIdx !== null && groups[grpIdx][meta.DEPTH] === 1 && typeof rowIdx === 'number'){\n        let lastGroup = groups[grpIdx];\n        if (rowIdx === 0){\n            return [lastGroup, grpIdx, null];\n        } else {\n            rowIdx -= 1;\n            const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX)\n            const row = data[absRowIdx].slice()\n            // row[meta.IDX] = idx;\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n            return [row, grpIdx, rowIdx];\n        }\n    } else {\n        if (grpIdx === null){\n            grpIdx = groups.length-1;\n        } else if (grpIdx === 0) {\n            return NO_RESULT;\n        } else {\n            grpIdx -= 1;\n        }\n        let lastGroup = groups[grpIdx];\n        if (lastGroup[meta.DEPTH] === 1){\n            rowIdx = getCount(lastGroup, NAV_COUNT) - 1;\n            const absRowIdx = getAbsRowIdx(lastGroup, rowIdx, navSet, NAV_IDX)\n            const row = data[absRowIdx].slice()\n            row[meta.DEPTH] = 0;\n            row[meta.COUNT] = 0;\n            row[meta.KEY] = row[0]; // assume keyfieldis 0 for now\n\n            return [row, grpIdx, rowIdx];\n        }\n        while (lastGroup[meta.PARENT_IDX] !== null && groups[lastGroup[meta.PARENT_IDX]][meta.DEPTH] < 0){\n            grpIdx = lastGroup[meta.PARENT_IDX];\n            lastGroup = groups[grpIdx];\n        }\n        return [lastGroup, grpIdx, null];\n    }\n}\n","import BaseRowSet from './rowSet';\nimport {\n    groupRows,\n    findSortedCol, findDoomedColumnDepths, getGroupStateChanges,\n    incrementDepth, decrementDepth,\n    expandRow,\n    splitGroupsAroundDoomedGroup, lowestIdxPointer,\n    groupbyExtendsExistingGroupby, groupbyReducesExistingGroupby,\n    findGroupPositions, groupbySortReversed,\n    GroupIdxTracker, SimpleTracker, getCount,\n    aggregateGroup,\n    findAggregatedColumns,\n    adjustGroupIndices,\n    adjustLeafIdxPointers,\n    allGroupsExpanded\n} from '../groupUtils';\nimport { sortBy, sortPosition } from '../sort';\nimport { extendsFilter, functor as filterPredicate } from '../filter';\nimport { mapSortCriteria } from '../columnUtils';\nimport GroupIterator from '../groupIterator';\nimport { ASC } from '../types'\nimport { NULL_RANGE } from '../rangeUtils';\n\nconst EMPTY_ARRAY = [];\n\nexport class GroupRowSet extends BaseRowSet {\n\n    constructor(rowSet, columns, groupby, groupState, sortCriteria = null, filter=rowSet.currentFilter) {\n        super(rowSet.table, columns, rowSet.baseOffset);\n        this.groupby = groupby;\n        this.groupState = groupState;\n        this.aggregations = [];\n        this.currentLength = 0; // TODO\n        this.groupRows = [];\n        this.aggregatedColumn = {};\n\n        this.collapseChildGroups = this.collapseChildGroups.bind(this);\n        this.countChildGroups = this.countChildGroups.bind(this);\n\n        columns.forEach(column => {\n            if (column.aggregate) {\n                const key = rowSet.columnMap[column.name];\n                this.aggregations.push([key, column.aggregate]); // why ?\n                this.aggregatedColumn[key] = column.aggregate;\n            }\n        });\n        this.expandedByDefault = false;\n        this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length\n            ? sortCriteria\n            : null;\n\n        // can we lazily build the sortSet as we fetch data for the first time ?\n        this.sortSet = rowSet.data.map((d,i) => i);\n        // we will store an array of pointers to parent Groups.mirroring sequence of leaf rows\n        this.rowParents = Array(rowSet.data.length);\n\n        this.applyGroupby(groupby);\n\n\n        const [navSet, IDX, COUNT] = this.selectNavigationSet(false);\n        // TODO roll the IDX and COUNT overrides into meta\n        this.iter = GroupIterator(this.groupRows, navSet, this.data, IDX, COUNT, this.meta);\n\n        if (filter){\n            this.filter(filter);\n        }\n\n    }\n\n    get length() {\n        return this.currentLength;\n    }\n    get first() {\n        return this.data[0];\n    }\n    get last(){\n        return this.data[this.data.length - 1];\n    }\n\n    currentRange(){\n        return this.setRange(this.range, false);\n    }\n\n    setRange(range, useDelta=true){\n        const [rowsInRange, idx] = !useDelta && range.lo === this.range.lo && range.hi === this.range.hi\n            ? this.iter.currentRange()\n            : this.iter.setRange(range, useDelta);\n\n        const filterCount = this.filterSet && this.meta.FILTER_COUNT;\n        const rows = rowsInRange.map((row,i) => this.cloneRow(row, idx+i, filterCount));\n        this.range = range;\n        return {\n            rows,\n            range,\n            size: this.length,\n            offset: this.offset,\n            selectedIndices: this.selectedIndices\n        };\n    }\n\n    cloneRow(row, idx, FILTER_COUNT){\n        const {IDX, DEPTH, COUNT} = this.meta;\n        const dolly = row.slice();\n        dolly[IDX] = idx + this.offset;\n\n        if (FILTER_COUNT && dolly[DEPTH] !== 0 && typeof dolly[FILTER_COUNT] === 'number'){\n            dolly[COUNT] = dolly[FILTER_COUNT]\n        }\n        return dolly;\n    }\n\n    applyGroupby(groupby, rows=this.data){\n        const { columns } = this;\n        this.groupRows.length = 0;\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        this.groupRows = groupRows(rows, this.sortSet, columns, this.columnMap, groupCols, {\n            groups: this.groupRows, rowParents: this.rowParents\n        })\n        this.currentLength = this.countVisibleRows(this.groupRows);\n    }\n\n    groupBy(groupby) {\n\n        if (groupbySortReversed(groupby, this.groupby)) {\n            this.sortGroupby(groupby);\n        } else if (groupbyExtendsExistingGroupby(groupby, this.groupby)) {\n            this.extendGroupby(groupby)\n            this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n        } else if (groupbyReducesExistingGroupby(groupby, this.groupby)) {\n            this.reduceGroupby(groupby);\n            this.range = NULL_RANGE\n            this.iter.clear();\n            this.currentLength = this.countVisibleRows(this.groupRows, this.filterSet !== null);\n        } else {\n            this.applyGroupby(groupby);\n        }\n        this.groupby = groupby;\n\n    }\n\n    // User interaction will never produce more than one change, but programatic change might !\n    //TODO if we have sortCriteria, apply to leaf rows as we expand\n    setGroupState(groupState) {\n        // onsole.log(`[groupRowSet.setGroupState] ${JSON.stringify(groupState,null,2)}`)\n        const changes = getGroupStateChanges(groupState, this.groupState);\n        changes.forEach(([key, ,isExpanded]) => {\n            const {groupRows} = this;\n            if (key === '*') {\n                this.toggleAll(isExpanded);\n                this.currentLength = this.countVisibleRows(groupRows, false);\n            } else {\n                const groupIdx= this.findGroupIdx(key);\n                if (groupIdx !== -1){\n                    if (isExpanded){\n                        this.currentLength += this.expandGroup(groupIdx, groupRows);\n                    } else {\n                        this.currentLength -= this.collapseGroup(groupIdx, groupRows);\n                    }\n                } else {\n                    console.warn(`setGroupState could not find row to toggle`)\n                }\n            }\n        })\n        this.groupState = groupState;\n    }\n\n    expandGroup(idx, groups){\n        return this.toggleGroup(idx, groups, this.countChildGroups);\n    }\n\n    collapseGroup(idx, groups){\n        return this.toggleGroup(idx, groups, this.collapseChildGroups);\n    }\n\n    toggleGroup(groupIdx, groupRows, processChildGroups){\n        const {DEPTH, COUNT, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        const groupRow = groupRows[groupIdx];\n        const depth = groupRow[DEPTH];\n        const useFilter = this.filterSet !== null;\n        groupRow[DEPTH] = -depth;\n        if (Math.abs(depth) === 1){\n            const COUNT_IDX = useFilter ? FILTER_COUNT : COUNT;\n            adjustment = groupRow[COUNT_IDX];\n        } else {\n            adjustment = processChildGroups(Math.abs(depth)-1, groupIdx+1, groupRows, useFilter)\n        }\n        return adjustment;\n    }\n\n    countChildGroups(childDepth, startIdx, groupRows, useFilter){\n        const {DEPTH, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        for (let i=startIdx; i<groupRows.length; i++){\n            const nextDepth = groupRows[i][DEPTH];\n            if (Math.abs(nextDepth) === childDepth){\n                if (!useFilter || groupRows[i][FILTER_COUNT] > 0){\n                    adjustment += 1;\n                }\n            } else if (Math.abs(nextDepth) > childDepth){\n                break;\n            }\n        }\n        return adjustment;\n    }\n\n    collapseChildGroups(childDepth, startIdx, groupRows, useFilter){\n        const {DEPTH, FILTER_COUNT} = this.meta;\n        let adjustment = 0;\n        for (let i=startIdx; i<groupRows.length; i++){\n            const nextDepth = groupRows[i][DEPTH];\n            if (Math.abs(nextDepth) === childDepth){\n                if (!useFilter || groupRows[i][FILTER_COUNT] > 0){\n                    adjustment += 1;\n                    if (nextDepth > 0){\n                        adjustment += this.collapseGroup(i, groupRows);\n                    }\n                }\n            } else if (Math.abs(nextDepth) > childDepth){\n                break;\n            }\n        }\n        return adjustment;\n    }\n\n    sort(sortCriteria) {\n        const {groupRows: groups} = this;\n        const { IDX, DEPTH, COUNT, IDX_POINTER } = this.meta;\n        this.sortCriteria = Array.isArray(sortCriteria) && sortCriteria.length\n            ? sortCriteria\n            : null;\n\n        const sortCols = mapSortCriteria(sortCriteria, this.columnMap);\n        //TODO only need to handle visible rows\n        for (let i=0;i<groups.length;i++){\n            const groupRow = groups[i];\n            const depth = groupRow[DEPTH]\n            const count = groupRow[COUNT];\n            const absDepth = Math.abs(depth);\n            const sortIdx = groupRow[IDX_POINTER];\n            if (absDepth === 1){\n                this.sortDataSubset(sortIdx, count, sortCols, IDX);\n\n            }\n        }\n    }\n\n    sortDataSubset(startIdx, length, sortCriteria, IDX){\n        const rows = [];\n        for (let i=startIdx;i<startIdx+length;i++){\n            const rowIdx = this.sortSet[i];\n            rows.push(this.data[rowIdx])\n        }\n        rows.sort(sortBy(sortCriteria));\n        for (let i=0;i<rows.length;i++){\n            this.sortSet[i+startIdx] = rows[i][IDX];\n        }\n    }\n\n    clearFilter(/*cloneChanges*/) {\n        this.currentFilter = null;\n        this.filterSet = null;\n        // rebuild agregations for groups where filter count is less than count, remove filter count\n        const { data: rows, groupRows: groups, sortSet, columns } = this;\n        const { COUNT, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        const aggregations = findAggregatedColumns(columns, this.columnMap, this.groupby);\n\n        for (let i=0;i<groups.length; i++){\n            let groupRow = groups[i];\n            if (typeof groupRow[FILTER_COUNT] === 'number' && groupRow[COUNT] > groupRow[FILTER_COUNT]){\n                aggregateGroup(groups, i, sortSet, rows, columns, aggregations);\n                groupRow[FILTER_COUNT] = null;\n                groupRow[NEXT_FILTER_IDX] = null;\n            }\n        }\n\n        this.iter.setNavSet(this.selectNavigationSet(false));\n        this.currentLength = this.countVisibleRows(groups, false);\n    }\n\n    filter(filter){\n        const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n        const fn = filter && filterPredicate(this.columnMap, filter);\n        const { COUNT, DEPTH, PARENT_IDX, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        const { data: rows, groupRows: groups } = this;\n        let [navSet, NAV_IDX, NAV_COUNT] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet)\n        const newFilterSet= [];\n\n        for (let i=0;i<groups.length; i++){\n            let groupRow = groups[i];\n            const depth = groupRow[DEPTH];\n            const count = getCount(groupRow,NAV_COUNT, COUNT);\n            const absDepth = Math.abs(depth);\n\n            if (absDepth === 1){\n                const sortIdx = groupRow[NAV_IDX];\n                let rowCount = 0;\n\n                for (let ii=sortIdx; ii<sortIdx+count; ii++){\n                    const rowIdx = navSet[ii];\n                    const row = rows[rowIdx];\n                    const includerow = fn(row);\n                    if (includerow) {\n                        rowCount += 1;\n                        if (rowCount === 1){\n                            groupRow[NEXT_FILTER_IDX] = newFilterSet.length;\n                        }\n                        newFilterSet.push(rowIdx)\n                    }\n                }\n\n                groupRow[FILTER_COUNT] = rowCount;\n                let aggregations = EMPTY_ARRAY;\n                // we cannot be sure what filter changes have taken effect, so we must recalculate aggregations\n                if (this.aggregations.length){\n                    aggregations = this.aggregations.map(([i, a]) => [i,a,0])\n                    const len = newFilterSet.length;\n                    for (let ii=len-rowCount;ii<len;ii++){\n                        const rowIdx = newFilterSet[ii];\n                        const row = rows[rowIdx];\n                        for (let j = 0; j < aggregations.length; j++) {\n                            let [colIdx] = aggregations[j];\n                            aggregations[j][2] += row[colIdx];\n                        }\n                    }\n                    \n                    // 2) store aggregates at lowest level of the group hierarchy\n                    aggregations.forEach(aggregation => {\n                        const [colIdx, type, sum] = aggregation;\n                        if (type === 'sum') {\n                            groupRow[colIdx] = sum;\n                        } else if (type === 'avg') {\n                            groupRow[colIdx] = sum / rowCount;\n                        }\n                    })\n                }\n\n                // update parent counts\n                if (rowCount > 0){\n                    while (groupRow[PARENT_IDX] !== null){\n                        groupRow = groups[groupRow[PARENT_IDX]];\n\n                        aggregations.forEach(aggregation => {\n                            const [colIdx, type, sum] = aggregation;\n                            if (type === 'sum') {\n                                groupRow[colIdx] += sum;\n                            } else if (type === 'avg') {\n                                const originalCount = groupRow[FILTER_COUNT];\n                                const originalSum = originalCount * groupRow[colIdx];\n                                groupRow[colIdx] = (originalSum + sum) / (originalCount + rowCount);\n                            }\n                        })\n                        groupRow[FILTER_COUNT] += rowCount;\n                    }\n                }\n\n            } else {\n                // Higher-level group aggregations are calculated from lower level groups\n                // initialize aggregated columns\n                groupRow[FILTER_COUNT] = 0;\n                this.aggregations.forEach(aggregation => {\n                    const [colIdx] = aggregation;\n                    groupRow[colIdx] = 0;\n                })\n            }\n        }\n        this.filterSet = newFilterSet;\n        this.currentFilter = filter;\n        this.currentLength = this.countVisibleRows(this.groupRows, true);\n\n        this.iter.setNavSet(this.selectNavigationSet(true))\n\n    }\n\n    update(rowIdx, updates){\n        const {groupRows: groups, offset, rowParents, range: {lo}} = this\n        const { COUNT, FILTER_COUNT, PARENT_IDX } = this.meta;\n\n        let groupUpdates;\n        const rowUpdates = [];\n\n        for (let i = 0; i < updates.length; i += 3) {\n            // the col mappings in updates refer to base column definitions\n            const colIdx = updates[i];\n            const originalValue = updates[i + 1];\n            const value = updates[i + 2];\n            rowUpdates.push(colIdx,originalValue,value);\n\n            let grpIdx = rowParents[rowIdx];\n            // this seems to return 0 an awful lot\n            let ii = 0;\n            \n            // If this column is being aggregated\n            if (this.aggregatedColumn[colIdx]){\n\n                groupUpdates = groupUpdates || [];\n                // collect adjusted aggregations for each group level\n                do {\n                    let groupRow = groups[grpIdx];\n\n                    let originalGroupValue = groupRow[colIdx];\n                    const diff = value - originalValue;\n                    const type = this.aggregatedColumn[colIdx];\n                    if (type === 'sum'){\n                        // ... wnd in the groupRow we have a further offset of 2 ...\n                        groupRow[colIdx] += diff;// again with the +2\n                    } else if (type === 'avg'){\n                        const count = getCount(groupRow, FILTER_COUNT, COUNT);\n                        groupRow[colIdx] = ((groupRow[colIdx] * count) + diff) / count;\n                    }\n\n                    (groupUpdates[ii] || (groupUpdates[ii]=[grpIdx])).push(colIdx, originalGroupValue, groupRow[colIdx])\n\n                    grpIdx = groupRow[PARENT_IDX];\n                    ii += 1;\n\n                } while (grpIdx !== null)\n\n            }\n        }\n\n        const outgoingUpdates = [];\n        // check rangeIdx for both row and group updates, if they are not in range, they have not been\n        // sent to client and do not need to be added to outgoing updates\n        if (groupUpdates){\n            // the groups are currently in reverse order, lets send them out outermost group first\n            for (let i=groupUpdates.length-1; i >=0; i--){\n                const [grpIdx, ...updates] = groupUpdates[i];\n                // won't work - need to chnage groupIterator\n                const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n                if (rangeIdx !== -1){\n                    outgoingUpdates.push([lo+rangeIdx+offset, ...updates]);\n                }\n            }\n        }\n        const rangeIdx = this.iter.getRangeIndexOfRow(rowIdx);\n        if (rangeIdx !== -1){\n            // onsole.log(`[GroupRowSet.update] updates for row idx ${idx} ${rangeIdx+offset} ${JSON.stringify(rowUpdates)}`)\n            outgoingUpdates.push([lo+rangeIdx+offset, ...rowUpdates]);\n        }\n        \n        return outgoingUpdates;\n    }\n\n    insert(newRowIdx, row){\n        // TODO look at append and idx manipulation for insertion at head. See insertDeprecated\n        const { groupRows: groups, groupby, data: rows, sortSet, columns, meta, iter: iterator } = this\n        let groupCols = mapSortCriteria(groupby, this.columnMap);\n        const groupPositions = findGroupPositions(groups, groupCols, row);\n        const {IDX, COUNT, KEY, IDX_POINTER} = meta;\n        const GROUP_KEY_SORT = [[KEY, 'asc']]\n        const allGroupsExist = groupPositions.length === groupby.length;\n        const noGroupsExist = groupPositions.length === 0;\n        const someGroupsExist = !noGroupsExist && !allGroupsExist;\n        let result;\n        let newGroupIdx = null;\n\n        if (allGroupsExist){\n            // all necessary groups are already in place, we will just insert a row and update counts/aggregates\n            let grpIdx = groupPositions[groupPositions.length-1];\n            const groupRow = groups[grpIdx];\n            this.rowParents[newRowIdx] = grpIdx;\n            let count = groupRow[COUNT];\n\n            const insertionPoint = groupRow[IDX_POINTER] + count;\n            // all existing pointers from the insertionPoint forward are going to be displaced by +1\n            adjustLeafIdxPointers(groups, insertionPoint, meta);\n            sortSet.splice(insertionPoint,0,row[IDX]);\n            if (allGroupsExpanded(groups, groupRow, meta)){\n                this.currentLength += 1;\n            }\n            \n        } else {\n\n            newGroupIdx = sortPosition(groups, sortBy(GROUP_KEY_SORT), expandRow(groupCols, row, meta), 'last-available');\n            sortSet.push(newRowIdx);\n            let nestedGroups, baseGroupby, rootIdx;\n\n            if (someGroupsExist){\n                baseGroupby = groupCols.slice(0,groupPositions.length)\n                rootIdx = groups[groupPositions[groupPositions.length-1]][IDX];\n                groupCols = groupCols.slice(groupPositions.length);\n            }\n\n            nestedGroups = groupRows(rows, sortSet, columns, this.columnMap, groupCols, {\n                startIdx: sortSet.length - 1, length: 1, groupIdx: newGroupIdx-1,\n                baseGroupby, rootIdx\n            });\n\n            adjustGroupIndices(groups, newGroupIdx, meta, nestedGroups.length);\n            groups.splice.apply(groups,[newGroupIdx,0].concat(nestedGroups));\n        }\n\n        this.incrementGroupCounts(groupPositions);\n\n        iterator.refresh(); // force iterator to rebuild rangePositions\n        let rangeIdx = allGroupsExist\n            ? iterator.getRangeIndexOfRow(newRowIdx)\n            : iterator.getRangeIndexOfGroup(newGroupIdx);\n        if (rangeIdx !== -1){\n            result = {replace: true}\n            if (newGroupIdx !== null){\n                this.currentLength += 1;\n            }\n        } else if (noGroupsExist === false){\n            result = {updates: this.collectGroupCountUpdates(groupPositions)}\n        }\n\n        return result;\n    }\n\n    incrementGroupCounts(groupPositions){\n        const {groupRows: groups, meta:{COUNT}} = this;\n        groupPositions.forEach(grpIdx => {\n            const group = groups[grpIdx];\n            group[COUNT] += 1;\n        })\n    }\n\n    collectGroupCountUpdates(groupPositions){\n        const {groupRows: groups, meta:{COUNT}, offset} = this;\n        const updates = [];\n        for (let i=0;i<groupPositions.length;i++){\n            const grpIdx = groupPositions[i];\n            const count = groups[grpIdx][COUNT];\n            const rangeIdx = this.iter.getRangeIndexOfGroup(grpIdx);\n            if (rangeIdx !== -1){\n                updates.push([rangeIdx+offset, COUNT, count]);\n            }\n        }\n        return updates;\n    }\n\n    // start with a simplesequential search\n    findGroupIdx(groupKey){\n        const {groupRows, meta} = this;\n        for (let i=0;i<groupRows.length;i++){\n            if (groupRows[i][meta.KEY] === groupKey){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //TODO simple implementation first\n    toggleAll(isExpanded) {\n        const sign = isExpanded ? 1 : -1;\n        // iterate groupedRows and make every group row depth positive,\n        // Then visible rows is not going to be different from grouped rows\n        const {DEPTH} = this.meta;\n        const { groupRows: groups } = this;\n        this.expandedByDefault = isExpanded;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            const depth = groups[i][DEPTH];\n            // if (depth !== 0) {\n            groups[i][DEPTH] = Math.abs(depth) * sign;\n            // }\n        }\n    }\n\n    sortGroupby(groupby){\n        const { IDX, KEY, DEPTH, IDX_POINTER, PARENT_IDX } = this.meta;\n        const {groupRows: groups} = this;\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        const [colIdx, depth] = findSortedCol(groupby, this.groupby);\n        let count = 0;\n        let i=0;\n        for (;i<groups.length;i++){\n            if (Math.abs(groups[i][DEPTH]) > depth){\n                if (count > 0){\n                    this.sortGroupRowsSubset(groupCols, colIdx, i-count, count)\n                    count = 0;\n                }\n            } else {\n                count += 1;\n            }\n        }\n\n        this.sortGroupRowsSubset(groupCols, colIdx, i-count, count)\n\n        const tracker = new SimpleTracker(groupby.length)\n        this.groupRows.forEach((groupRow,i) => {\n            const depth = groupRow[DEPTH];\n            const groupKey = groupRow[KEY]\n            const absDepth = Math.abs(depth);\n            tracker.set(absDepth, i, groupKey)\n            groupRow[IDX] = i;\n            if (absDepth > 1){\n                groupRow[IDX_POINTER] = i+1;\n            }\n            if (tracker.hasParentPos(absDepth)){\n                groupRow[PARENT_IDX] = tracker.parentPos(absDepth);\n            }\n        });\n    }\n\n    sortGroupRowsSubset(groupby, colIdx, startPos=0, length=this.groupRows.length){\n        const {groupRows: groups} = this;\n        let insertPos = startPos + length;\n        const [groupColIdx, direction] = groupby[colIdx];\n        const before = (k1, k2) => direction === ASC ? k2 > k1 : k1 > k2;\n        const after = (k1, k2) => direction === ASC ? k2 < k1 : k1 < k2;\n        let currentKey = null;\n        for (let i=startPos;i<startPos+length;i++){\n            const key = groups[i][groupColIdx];\n            if (currentKey === null){\n                currentKey = key;\n            } else if (before(key,currentKey)){\n                const splicedRows = groups.splice(startPos,i-startPos);\n                insertPos -= splicedRows.length;\n                groups.splice.apply(groups, [insertPos,0].concat(splicedRows));\n                currentKey = key;\n                i = startPos-1;\n            } else if (after(key,currentKey)){\n                break;\n            }\n        }\n    }\n\n    // there is a current assumption here that new col(s) are always added at the end of existing cols in the groupBy\n    // Need to think about a new col inserted at start or in between existing cols \n    //TODO we might want to do this on expanded nodes only and repat in a lazy fashion as more nodes are revealed\n    extendGroupby(groupby) {\n        const groupCols = mapSortCriteria(groupby, this.columnMap);\n        const baseGroupCols = groupCols.slice(0, this.groupby.length);\n        const newGroupbyClause = groupCols.slice(this.groupby.length);\n        const {groupRows: groups, groupby: baseGroupby, data: rows, columns, sortSet, filterSet, meta} = this;\n        const { IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = meta;\n        const baseLevels = baseGroupby.length;\n        const tracker = new GroupIdxTracker(baseLevels-1);\n        const filterFn = this.currentFilter\n            ? filterPredicate(this.columnMap, this.currentFilter)\n            : null;\n\n        // we are going to insert new rows into groupRows and update the PARENT_IDX pointers in data rows\n        for (let i=0;i<groups.length;i++){\n            const groupRow = groups[i];\n            if (tracker.idxAdjustment){\n                groupRow[meta.IDX] += tracker.idxAdjustment;\n            }\n\n            const rootIdx = groupRow[meta.IDX];\n            const depth = groupRow[meta.DEPTH];\n            const length = groupRow[meta.COUNT];\n            const groupKey = groupRow[meta.KEY];\n\n            const absDepth = Math.abs(depth);\n            groupRow[meta.DEPTH] = incrementDepth(depth);\n            const filterLength = groupRow[meta.FILTER_COUNT];\n            const filterIdx = groupRow[NEXT_FILTER_IDX];\n            groupRow[meta.NEXT_FILTER_IDX] = undefined;\n\n            if (tracker.hasPrevious(absDepth+1)){\n                groupRow[PARENT_IDX] += tracker.previous(absDepth+1);\n            }\n\n            if (absDepth === 1){\n                const startIdx = groupRow[IDX_POINTER]\n                const nestedGroupRows = groupRows(rows, sortSet, columns, this.columnMap, newGroupbyClause, {\n                    startIdx,\n                    length,\n                    rootIdx,\n                    baseGroupby: baseGroupCols,\n                    groupIdx: rootIdx,\n                    filterIdx,\n                    filterLength,\n                    filterSet,\n                    filterFn,\n                    rowParents: this.rowParents\n                });\n                const nestedGroupCount = nestedGroupRows.length;\n                // this might be a performance problem for large arrays, might need to concat\n                groups.splice(i+1,0, ...nestedGroupRows)\n                i += nestedGroupCount;\n                tracker.increment(nestedGroupCount)\n            } else {\n                tracker.set(absDepth, groupKey);\n            }\n            // This has to be a pointer into sortSet NOT rows\n            groupRow[IDX_POINTER] = rootIdx+1;\n        }\n    }\n\n    reduceGroupby(groupby) {\n        const { groupRows: groups, filterSet } = this;\n        const [doomed] = findDoomedColumnDepths(groupby, this.groupby);\n        const groupCols = mapSortCriteria(this.groupby, this.columnMap);\n        const [lastGroupIsDoomed, baseGroupby, addGroupby] = splitGroupsAroundDoomedGroup(groupCols, doomed);\n        const { IDX, DEPTH, KEY, IDX_POINTER, PARENT_IDX, NEXT_FILTER_IDX } = this.meta;\n        const tracker = new GroupIdxTracker(groupby.length);\n        const useFilter = filterSet !== null;\n        let currentGroupIdx = null;\n        let i = 0\n        for (let len=groups.length;i<len;i++){\n            const groupRow = groups[i];\n            const depth = groupRow[DEPTH];\n            const groupKey = groupRow[KEY];\n            const absDepth = Math.abs(depth);\n\n            if (absDepth === doomed){\n                this.reParentLeafRows(i, currentGroupIdx);\n                groups.splice(i,1);\n                i -= 1;\n                len -= 1;\n                tracker.increment(1);\n            } else {\n                if (absDepth > doomed){\n                    tracker.set(absDepth,groupKey);\n                    if (absDepth === doomed + 1){\n                        if (lastGroupIsDoomed){\n                            // our pointer will no longer be to a child group but (via the sortSet) to the data.\n                            // This can be taken from the first child group (which will be removed)\n                            groupRow[IDX_POINTER] = lowestIdxPointer(groups, IDX_POINTER, DEPTH, i+1, absDepth-1);\n                            groupRow[NEXT_FILTER_IDX] = useFilter ? lowestIdxPointer(groups, NEXT_FILTER_IDX, DEPTH, i+1, absDepth-1) : undefined;\n                        } else if (currentGroupIdx !== null){\n                            const diff = this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby);\n                            i -= diff;\n                            len -= diff;\n                            tracker.increment(diff);\n                        }\n                    }\n                    currentGroupIdx = i;\n                    if (tracker.hasPrevious(absDepth+1)){\n                        groupRow[PARENT_IDX] -= tracker.previous(absDepth+1);\n                    }\n                    groupRow[DEPTH] = decrementDepth(depth);\n                }\n                if (tracker.idxAdjustment > 0){\n                    groupRow[IDX] -= tracker.idxAdjustment;\n                    if (Math.abs(groupRow[DEPTH]) > 1){\n                        groupRow[IDX_POINTER] -= tracker.idxAdjustment;\n                    }\n                }\n            }\n        }\n        if (!lastGroupIsDoomed){\n            // don't forget the final group ...\n            this.regroupChildGroups(currentGroupIdx, i, baseGroupby, addGroupby)\n        }\n    }\n\n    reParentLeafRows(groupIdx, newParentGroupIdx){\n        // TODO what about filterSet ?\n        const {groupRows: groups, rowParents, sortSet, meta: {IDX_POINTER, COUNT}} = this;\n        const group = groups[groupIdx];\n        const idx = group[IDX_POINTER];\n        const count = group[COUNT];\n\n        for (let i=idx; i< idx+count; i++){\n            const rowIdx = sortSet[i];\n            rowParents[rowIdx] = newParentGroupIdx; \n        }\n\n    }\n\n    regroupChildGroups(currentGroupIdx, nextGroupIdx, baseGroupby, addGroupby){\n        const { groupRows: groups, data: rows, columns, meta } = this;\n        const { COUNT, IDX_POINTER } = meta;\n        const group = groups[currentGroupIdx]\n        const length = group[COUNT]\n        const startIdx = groups[currentGroupIdx+1][IDX_POINTER]\n        // We don't really need to go back to rows to regroup, we have partially grouped data already\n        // we could perform the whole operation within groupRows\n        const nestedGroupRows = groupRows(rows, this.sortSet, columns, this.columnMap, addGroupby, {\n            startIdx,\n            length,\n            rootIdx: currentGroupIdx,\n            baseGroupby,\n            groupIdx: currentGroupIdx,\n            rowParents: this.rowParents\n        });\n        const existingChildNodeCount = nextGroupIdx - currentGroupIdx - 1;\n        groups.splice(currentGroupIdx+1,existingChildNodeCount,...nestedGroupRows)\n        group[IDX_POINTER] = currentGroupIdx+1;\n        return existingChildNodeCount - nestedGroupRows.length;\n\n    }\n\n    // Note: this assumes no leaf rows visible. Is that always valid ?\n    // NOt after removing a groupBy ! Not after a filter\n    countVisibleRows(groupRows, usingFilter=false){\n        const {DEPTH, COUNT, FILTER_COUNT} = this.meta;\n        let count = 0;\n        for (let i=0, len=groupRows.length;i<len;i++){\n            const zeroCount = usingFilter && groupRows[i][FILTER_COUNT] === 0;\n            if (!zeroCount){\n                count += 1;\n            }\n            const depth = groupRows[i][DEPTH];\n            if (depth < 0 || zeroCount){\n                while (i<len-1 && Math.abs(groupRows[i+1][DEPTH]) < -depth){\n                    i += 1;\n                }\n            } else if (depth === 1){\n                count += (usingFilter ? groupRows[i][FILTER_COUNT] : groupRows[i][COUNT])\n            }\n        }\n        return count;\n    }\n\n}\n","/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nexport default class UpdateQueue {\n\n    constructor(){\n        this._queue = [];\n    }\n\n      get length() { return this._queue.length; }\n\n      update(update) {\n          //TODO we could also coalesce updates into an insert or rowset, if present\n          const batch = this.getCurrentBatch('update');\n\n          const [rowIdx] = update;\n          const {updates} = batch;\n\n          for (let i = 0, len = updates.length; i < len; i++) {\n              if (updates[i][0] === rowIdx) {\n                  // we already have an update for this item, update the update...\n                  let d = updates[i];\n                  for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n                      const pos = d.indexOf(update[colIdx]);\n                      if (pos === -1) {// should check that it is really a colIdx,not a value\n                          d.push(update[colIdx], update[colIdx + 1]);\n                      } else {\n                          d[pos + 1] = update[colIdx + 1];\n                      }\n                  }\n\n                  return;\n              }\n          }\n          updates.push(update);\n      }\n\n      resize(size) {\n          const batch = this.getCurrentBatch('size');\n          batch.size = size;\n      }\n\n      append(row, offset) {\n          const batch = this.getCurrentBatch('insert');\n          //onsole.log(`UpdateQueue append ${row[0]}`);\n          batch.rows.push(row);\n          batch.offset = offset;\n      }\n\n      replace(rows, size, offset) {\n          const batch = this.getCurrentBatch('rowset');\n          batch.rows = rows;\n          batch.size = size;\n          batch.offset = offset;\n      }\n\n      popAll() {\n          const results = this._queue;\n          this._queue = [];\n          return results;\n      }\n\n      getCurrentBatch(type) {\n\n          const q = this._queue;\n          const len = q.length;\n\n          let batch = len === 0 || type === 'rowset'\n              ? (q[0] = createBatch(type))\n              : q[len - 1];\n\n          if (batch.type !== type) {\n              // roll size recored into subsequent insert \n              if (type === 'insert' && batch.type === 'size') {\n                  batch.type = 'insert';\n                  batch.rows = [];\n              } else if (type === 'size' && batch.type === 'insert') {\n                  // that's ok - go ahead and update size on the insert batch\n              } else {\n                  batch = (q[len] = createBatch(type));\n              }\n          }\n\n          return batch;\n\n      }\n  }\n\nfunction createBatch(type) {\n    switch (type) {\n    case 'rowset': return { type, rows: [] };\n    case 'update': return { type, updates: [] };\n    case 'insert': return { type, rows: [] };\n    case 'size': return { type };\n    default: throw Error('Unknown batch type');\n    }\n}\n","import { NULL_RANGE, resetRange, withinRange } from './rangeUtils';\nimport { RowSet, GroupRowSet } from './rowset/index';\nimport { buildColumnMap, toColumn, getFilterType } from './columnUtils';\nimport UpdateQueue from './updateQueue';\nimport { DataTypes } from './types';\nimport { addFilter } from './filter';\n\nconst DEFAULT_INDEX_OFFSET = 100;\n\nexport default class DataView {\n\n    constructor(table, { columns = [], sortCriteria = null, groupBy = null, filter = null }, updateQueue = new UpdateQueue()) {\n        this._table = table;\n        this._index_offset = DEFAULT_INDEX_OFFSET;\n        this._filter = filter;\n        this._groupState = null;\n        this._sortCriteria = sortCriteria;\n\n        this._columns = null;\n        this._columnMap = null;\n        // column defs come from client, this is where we assign column keys\n        this.columns = columns;\n\n        this._groupby = groupBy;\n        this._update_queue = updateQueue;\n        // TODO we should pass columns into the rowset as it will be needed for computed columns\n        this.rowSet = new RowSet(table, this._columns, this._index_offset);\n        this.filterRowSet = null;\n\n        // What if data is BOTH grouped and sorted ...\n        if (groupBy !== null) {\n            // more efficient to compute this directly from the table projection\n            this.rowSet = new GroupRowSet(this.rowSet, this._columns, this._groupby, this._groupState);\n        } else if (this._sortCriteria !== null) {\n            this.rowSet.sort(this._sortCriteria);\n        }\n\n        this.rowUpdated = this.rowUpdated.bind(this);\n        this.rowInserted = this.rowInserted.bind(this);\n\n        table.on('rowUpdated', this.rowUpdated);\n        table.on('rowInserted', this.rowInserted);\n\n    }\n\n    // Set the columns from client\n    set columns(columns) {\n        this._columns = columns.map(toColumn);\n        this._columnMap = buildColumnMap(this._columns);\n    }\n\n    destroy() {\n        this._table.removeListener('rowUpdated', this.rowUpdated);\n        this._table.removeListener('rowUpdated', this.rowInserted);\n        this._table = null;\n        this.rowSet = null;\n        this.filterRowSet = null;\n        this._update_queue = null;\n    }\n\n    get status() {\n        return this._table.status;\n    }\n\n    rowInserted(event, idx, row) {\n        const { _update_queue, rowSet } = this;\n        const { size = null, replace, updates } = rowSet.insert(idx, row);\n        if (size !== null) {\n            _update_queue.resize(size);\n        }\n        if (replace) {\n            const { rows, size, offset } = rowSet.currentRange()\n            _update_queue.replace(rows, size, offset);\n        } else if (updates) {\n            updates.forEach(update => {\n                _update_queue.update(update);\n            });\n\n        }\n        // what about offset change only ?\n    }\n\n    rowUpdated(event, idx, updates) {\n        const { rowSet, _update_queue } = this;\n        // const {range, rowSet} = _row_data;\n        const result = rowSet.update(idx, updates);\n        if (result) {\n            if (rowSet instanceof RowSet) {\n                // we wouldn't have got the update back if it wasn't in range\n                if (withinRange(rowSet.range, result[0], rowSet.offset)) {\n                    _update_queue.update(result);\n                }\n            } else {\n                result.forEach(rowUpdate => {\n                    //TODO pretty sure we've already checked the range within the rowset itself\n                    if (withinRange(rowSet.range, rowUpdate[0], rowSet.offset)) {\n                        _update_queue.update(rowUpdate);\n                    }\n                });\n            }\n        }\n    }\n\n    getData(dataType) {\n        return dataType === DataTypes.ROW_DATA\n            ? this.rowSet\n            : dataType === DataTypes.FILTER_DATA\n                ? this.filterRowSet\n                : null;\n    }\n\n    //TODO we seem to get a setRange when we reverse sort order, is that correct ?\n    setRange(range, useDelta = true, dataType = DataTypes.ROW_DATA) {\n        return this.getData(dataType).setRange(range, useDelta);\n    }\n\n    select(idx, rangeSelect, keepExistingSelection){\n        console.log(`InMemoryView.select ${idx} rangeSelect:${rangeSelect}, keepExistingSelection: ${keepExistingSelection}`)\n        return this.rowSet.select(idx, rangeSelect, keepExistingSelection);\n        //TODO eliminate rows not in range\n    \n    }\n\n    sort(sortCriteria) {\n        this._sortCriteria = sortCriteria;\n        this.rowSet.sort(sortCriteria);\n        // assuming the only time we would not useDelta is when we want to reset ?\n        return this.setRange(resetRange(this.rowSet.range), false);\n    }\n\n    filter(filter, dataType=DataTypes.ROW_DATA, incremental=false) {\n        if (dataType === DataTypes.FILTER_DATA){\n\n            return [undefined,this.filterFilterData(filter)];\n        \n        } else {\n            if (incremental){\n                filter = addFilter(this._filter, filter);\n            }\n            const { rowSet, _filter, filterRowSet } = this;\n            const { range } = rowSet;\n            this._filter = filter;\n            let filterResultset;\n            let filterCount = rowSet.totalCount;\n    \n            if (filter === null && _filter) {\n                rowSet.clearFilter();\n            } else if (filter){\n                filterCount = this.rowSet.filter(filter);\n            } else {\n                throw Error(`InMemoryView.filter setting null filter when we had no filter anyway`);\n            }\n    \n            if (filterRowSet) {\n                if (filter){\n                    filterResultset = filterRowSet.setSelected(filter, filterCount);\n                } else {\n                    // TODO examine this. Must be a more efficient way to reset counts in filterSet\n                    const {columnName, range} = filterRowSet;\n                    this.filterRowSet = rowSet.getDistinctValuesForColumn({name:columnName});\n                    filterResultset = this.filterRowSet.setRange(range, false)\n                }\n            }\n    \n            const resultSet = {\n                ...(this.rowSet.setRange(resetRange(range), false)),\n                filter\n            }\n    \n            return filterResultset\n                ? [resultSet, filterResultset]\n                : [resultSet];\n        }\n\n    }\n\n    groupBy(groupby) {\n        const { rowSet, _columns, _groupState, _sortCriteria, _groupby } = this;\n        const { range: _range } = rowSet;\n        this._groupby = groupby;\n\n        if (groupby === null) {\n            this.rowSet = RowSet.fromGroupRowSet(this.rowSet);\n        } else {\n            if (_groupby === null) {\n                this.rowSet = new GroupRowSet(rowSet, _columns, groupby, _groupState, _sortCriteria);\n            } else {\n                rowSet.groupBy(groupby);\n            }\n        }\n        return this.rowSet.setRange(_range, false);\n    }\n\n    setGroupState(groupState) {\n        this._groupState = groupState;\n        const { rowSet } = this;\n        rowSet.setGroupState(groupState);\n        // TODO should we have setRange return the following directly, so IMV doesn't have to decide how to call setRange ?\n        // should we reset the range ?\n        return rowSet.setRange(rowSet.range, false);\n    }\n\n    get updates() {\n        const { _update_queue, rowSet: { range } } = this;\n        let results = {\n            updates: _update_queue.popAll(),\n            range: {\n                lo: range.lo,\n                hi: range.hi\n            }\n        };\n        return results;\n    }\n\n    getFilterData(column, searchText = null, range) {\n        console.log(`getFilterData searchText='${searchText}'`)\n        const { rowSet, filterRowSet, _filter: filter, _columnMap } = this;\n        // If our own dataset has been filtered by the column we want values for, we cannot use it, we have\n        // to go back to the source, using a filter which excludes the one in place on the target column. \n        const columnName = column.name;\n        const colDef = this._columns.find(col => col.name === columnName);\n        // No this should be decided beforehand (on client) \n        const type = getFilterType(colDef);\n\n        if (type === 'number') {\n            // // we need a notification from server to tell us when this is closed.\n            // we should assign to filterRowset\n            this.filterRowSet = rowSet.getBinnedValuesForColumn(column);\n\n        } else if (!filterRowSet || filterRowSet.columnName !== column.name) {\n\n            this.filterRowSet = rowSet.getDistinctValuesForColumn(column);\n\n        } else if (searchText) {\n            filterRowSet.searchText = searchText;\n\n        } else if (filterRowSet && filterRowSet.searchText) {\n            // reset the filter\n            filterRowSet.clearFilter();\n\n        } else if (filter && filter.colName === column.name) {\n            // if we already have the data for this filter, nothing further to do except reset the filterdata range\n            // so next request will return full dataset.\n            filterRowSet.setRange({ lo: 0, hi: 0 });\n        }\n\n        if (filter) {\n            this.filterRowSet.setSelected(filter, this.rowSet.filterCount);\n        }\n\n        // do we need to returtn searchText ? If so, it should\n        // be returned by the rowSet\n        return this.filterRowSet.setRange(range, false);\n\n    }\n\n    filterFilterData(filter){\n        const {filterRowSet} = this;\n        if (filterRowSet){\n\n            if (filter === null) {\n                filterRowSet.clearFilter();\n            } else if (filter){\n                filterRowSet.filter(filter);\n            }\n            return filterRowSet.setRange(resetRange(filterRowSet.range), false);\n    \n        } else {\n            console.error(`[InMemoryView] filterfilterRowSet no filterRowSet`)\n        }\n\n    }\n\n}\n","/*\n  See UpdateQueue\n*/\n//TODO does this belong in view ?\nimport {EventEmitter} from '@heswell/utils';\nimport {DataTypes} from './types';\n\nexport default class UpdateQueue extends EventEmitter {\n\n    update(update) {\n        this.emit('update', [update]);\n    }\n\n    resize(size) {\n        console.log(`localUpdateQueue resize ${JSON.stringify(size)}`)\n    }\n\n    append(row, offset) {\n        console.log(`localUpdateQueue append ${JSON.stringify(row)} offset ${offset}`)\n    }\n\n    replace({rows, size, offset}) {\n        console.log(`localUpdateQueue replace ${JSON.stringify(rows)} size ${size} offset ${offset}`)\n        this.emit(DataTypes.ROW_DATA, rows, size, offset)\n    }\n\n    popAll() {\n        console.log(`localUpdateQueue popAll`)\n    }\n}\n","import {createLogger, logColor} from '@heswell/utils'\nimport DataView from '../store/DataView';\nimport { metaData } from '../store/columnUtils';\nimport { DataTypes } from '../store/types';\nimport Table from '../store/table';\nimport LocalUpdateQueue from '../store/localUpdateQueue';\n\nconst buildDataView = async url =>\n  import(/* webpackIgnore: true */ url)\n    .catch(err => console.log(`failed to load data at ${url} ${err}`))\n\nconst logger = createLogger('LocalDataView', logColor.blue);\n\nexport default class LocalDataView {\n  constructor({\n    url,\n    tableName\n  }) {\n    // note: don't wait\n    logger.log(`lets try and load ${url}`)\n    this.eventualView = buildDataView(url);\n    this.columns = null;\n    this.meta = null;\n\n    this.tableName = tableName;\n    this.subscription = null;\n    this.viewport = null;\n    this.filterDataCallback = null;\n    this.filterDataMessage = null;\n\n    this.updateQueue = new LocalUpdateQueue();\n    this.dataView = null;\n    this.clientCallback = null;\n    this.range = null;\n  }\n\n  async subscribe({\n    tableName = this.tableName,\n    columns,\n    // range = defaultRange,\n    // ...options\n  }, callback) {\n\n    if (!columns) throw Error(\"LocalDataView subscribe called without columns\");\n    \n    // TODO options can include sort, groupBy etc\n    \n    this.tableName = tableName;\n    this.columns = columns;\n    this.meta = metaData(columns);\n\n    const { default: data } = await this.eventualView\n    const table = new Table({ data, columns });\n    this.dataView = new DataView(table, {columns}, this.updateQueue);\n    this.clientCallback = callback;\n\n    if (this.range){\n      this.setRange(this.range.lo, this.range.hi)\n    }\n  }\n\n  unsubscribe() {\n\n  }\n\n  setRange(lo, hi) {\n    if (this.dataView === null){\n      this.range = {lo,hi}\n    } else {\n      this.clientCallback(this.dataView.setRange({lo, hi}, true, DataTypes.ROW_DATA));\n    }\n  }\n\n  select(idx, _row, rangeSelect, keepExistingSelection) {\n    this.clientCallback(this.dataView.select(idx, rangeSelect, keepExistingSelection))\n  }\n\n  group(columns) {\n    this.clientCallback(this.dataView.groupBy(columns))\n  }\n\n  setGroupState(groupState) {\n    this.clientCallback(this.dataView.setGroupState(groupState))\n  }\n\n  sort(columns) {\n    this.clientCallback(this.dataView.sort(columns));\n  }\n\n  filter(filter, dataType = DataTypes.ROW_DATA, incremental = false) {\n    // TODO filter call returns an array\n    const [rowData, filterData] = this.dataView.filter(filter, dataType, incremental);\n    this.clientCallback(rowData);\n    if (filterData){\n      if (this.clientFilterCallback){\n        this.clientFilterCallback({filterData});\n      } else {\n        this.filterDataMessage = filterData;\n      }\n      }\n  }\n\n  getFilterData(column, searchText) {\n      const filterData =  this.dataView.getFilterData(column, searchText)\n      if (this.clientFilterCallback){\n        this.clientFilterCallback({filterData});\n      } else {\n        this.filterDataMessage = {filterData};\n      }\n    }\n\n  subscribeToFilterData(column, range, callback) {\n    logger.log(`<subscribeToFilterData>`)\n    this.clientFilterCallback = callback;\n    this.setFilterRange(range.lo, range.hi);\n    if (this.filterDataMessage) {\n      callback(this.filterDataMessage);\n      // do we need to nullify now ?\n    }\n  }\n\n  unsubscribeFromFilterData() {\n    logger.log(`<unsubscribeFromFilterData>`)\n    this.clientFilterCallback = null;\n  }\n\n  // To support multiple open filters, we need a column here\n  setFilterRange(lo, hi) {\n    const message = {\n      filterData: this.dataView.setRange({lo, hi}, true, DataTypes.FILTER_DATA)\n    };\n\n    if (this.clientFilterCallback){\n      this.clientFilterCallback(message);\n    } else {\n      this.filterDataMessage = message;\n    }\n  }\n\n}","//TODO neither this file nor filter-data-view belong here - thye are not specific to remote views\n\nimport { createLogger, logColor} from '@heswell/utils';\n\nconst logger = createLogger('BinnedDataView', logColor.brown);\n\nexport default class BinnedDataView {\n\n  constructor(dataView, column) {\n    this.dataView = dataView;\n    this.column = column;\n    this.dataCountCallback = null;\n  }\n\n  subscribe({range}, callback) {\n    logger.log(`<subscribe>`)\n\n    this.dataView.subscribeToFilterData(this.column, range, message => {\n\n      logger.log(`callback ${JSON.stringify(message.null, 2)}`)\n      const {filterData} = message;\n      const {rows, size, range} = filterData;\n\n      logger.log(`receive rows ${rows.length} of ${size} range ${JSON.stringify(range)}`, message)\n\n      // const mergedRows = this.processData(rows, size, 0)\n\n      callback(rows);\n\n      // if (this.dataCountCallback){\n      //     this.dataCountCallback(dataCounts);\n      // }\n\n\n    })\n\n  }\n\n  destroy(){\n    logger.log(`<destroy>`)\n    this.dataView.unsubscribeFromFilterData(this.column);\n}\n\n}","import { createLogger, logColor } from '@heswell/utils';\nimport { metaData } from '../store/columnUtils';\nimport { DataTypes } from '../store/types';\nimport { NOT_IN, IN } from '../store/filter';\n\nconst logger = createLogger('FilterDataView', logColor.brown);\n\nexport default class FilterDataView {\n\n  constructor(dataView, column){\n        this.dataView = dataView;\n        this.column = column;\n        this.dataCountCallback = null;\n    }\n\n    subscribe({columns, range}, callback){\n\n        this.columns = columns;\n        this.meta = metaData(columns);\n        //TODO make range s setter\n        this.range = range;\n        this.keyCount = range.hi - range.lo;\n\n        this.dataView.subscribeToFilterData(this.column, this.range, message => {\n            const {filterData: {dataCounts, ...data}} = message;\n            callback(data);\n            if (this.dataCountCallback){\n                this.dataCountCallback(dataCounts);\n            }    \n        })\n    }\n\n    subscribeToDataCounts(callback){\n        this.dataCountCallback = callback;\n    }\n    unsubscribeFromDataCounts(){\n        this.dataCountCallback = null;\n    }\n\n    unsubscribe(){\n        this.dataView.unsubscribeFromFilterData();\n    }\n\n    destroy(){\n        logger.log(`<destroy>`)\n        this.dataView.unsubscribeFromFilterData(this.column);\n    }\n\n    // onFilterData = (_, rows, rowCount, totalCount, dataCounts) => {\n    //     this.emit(DataTypes.ROW_DATA, rows, rowCount, totalCount, dataCounts);\n    // }\n\n    select(idx, row){\n        const {KEY, SELECTED} = this.meta;\n        const key = row[KEY];\n    \n        const filter = {\n            type: row[SELECTED] === 1 ? NOT_IN : IN,\n            colName: this.column.name,\n            values: [key]\n        }\n        // This is enough to filter rows and populate filter display - but how can we add filter markers to UI ?\n        this.dataView.filter(filter, DataTypes.ROW_DATA, true);\n    \n    }\n\n    filter(filter, dataType = DataTypes.FILTER_DATA, incremental=false){\n        this.dataView.filter(filter, dataType, incremental);\n    }\n\n    getFilterData(column, searchText){\n        console.log(`FilterDataView.getFilterData ${JSON.stringify(column)} ${searchText}`)\n        this.dataView.getFilterData(column, searchText);\n    }\n\n    // TODO we need a filter method to filter results to omit zero value filterCount - call getFilterData on view, passing filter\n\n    setRange(lo, hi){\n      this.range = { lo, hi };\n      this.dataView.setFilterRange(lo,hi);\n    }\n\n    sort(){\n        \n    }\n  \n}\n\n","\nimport {\n  getFilterType,\n  toColumn,\n  toKeyedColumn,\n  buildColumnMap,\n  metaData,\n  setFilterColumnMeta } from './src/store/columnUtils';\n\nimport { sortByToMap } from './src/store/sort'\nimport {\n  AND,\n  OR,\n  IN,\n  NOT_IN,\n  STARTS_WITH,\n  NOT_STARTS_WITH,\n  addFilter,\n  extractFilterForColumn,\n  getFilterColumn,\n  includesColumn,\n  partition,\n  removeFilterForColumn,\n  SET_FILTER_DATA_COLUMNS,\n  BIN_FILTER_DATA_COLUMNS,\n  shouldShowFilter } from './src/store/filter';\n\n  import {\n  getFullRange,\n  resetRange,\n  NULL_RANGE as NULL } from './src/store/rangeUtils';\n\nimport {\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby } from './src/store/groupUtils'\n\nimport {\n  isEmptyRow,\n  mergeAndPurge,\n  purgeAndFill,\n  update } from './src/store/rowUtils'\n\nimport * as types from './src/store/types';\n\nexport const groupHelpers = {\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby\n}\n\nexport {default as Table} from './src/store/table';\nexport {default as DataView} from './src/store/DataView';\nexport {default as LocalDataView} from './src/view/local-data-view';\nexport {default as BinnedDataView} from './src/view/binned-data-view';\nexport {default as FilterDataView} from './src/view/filter-data-view';\n\nexport const sortUtils = {\n  sortByToMap\n}\n\nexport const columnUtils = {\n  buildColumnMap,\n  getFilterType,\n  toColumn,\n  toKeyedColumn,\n  metaData,\n  setFilterColumnMeta\n}\n\nexport const rowUtils = {\n  isEmptyRow, mergeAndPurge, purgeAndFill, update\n}\n\nexport const filter = {\n  AND,\n  OR,\n  IN,\n  NOT_IN,\n  STARTS_WITH,\n  NOT_STARTS_WITH,\n  shouldShowFilter,\n  addFilter,\n  extractFilterForColumn,\n  removeFilterForColumn,\n  getFilterColumn,\n  includesColumn,\n  SET_FILTER_DATA_COLUMNS,\n  BIN_FILTER_DATA_COLUMNS\n}\n\nexport const rangeUtils = {\n  getFullRange,\n  resetRange\n}\n\nexport const arrayUtils = {\n  partition\n}\n\nexport const DataTypes = types.DataTypes;\n\nexport const ASC = types.ASC;\nexport const DSC = types.DSC;\nexport const NULL_RANGE = NULL;\n"],"names":["EventEmitter","byKey","EMPTY","d3.histogram","filterPredicate","UpdateQueue","createLogger","logColor","LocalUpdateQueue","logger","DataTypes","types.DataTypes","ASC","types.ASC","DSC","types.DSC","NULL_RANGE","NULL"],"mappings":"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"}