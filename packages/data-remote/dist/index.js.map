{"version":3,"file":"index.js","sources":["../src/constants.js","../src/connection-manager.js","../src/remote-data-view.js"],"sourcesContent":["let _connectionId = 0;\n\nexport const connectionId = {\n  get nextValue(){\n    return _connectionId++;\n  }\n}\n\nexport const msgType = {\n  connect : 'connect',\n  connectionStatus : 'connection-status',\n  rowData : 'rowData',\n  rowSet: 'rowset',\n  select : 'select',\n  selected: 'selected',\n  snapshot : 'snapshot',\n  update: 'update',\n\n  addSubscription: 'AddSubscription',\n  collapseGroup : 'CollapseGroup',\n  columnList : 'ColumnList',\n  data : 'data',\n  expandGroup : 'ExpandGroup',\n  filter : 'filter',\n  filterData : 'filterData',\n  getFilterData : 'GetFilterData',\n  getSearchData : 'GetSearchData',\n  groupBy : 'groupBy',\n  modifySubscription : 'ModifySubscription',\n  searchData : 'searchData',\n  setColumns: 'setColumns',\n  setGroupState : 'setGroupState',\n  setViewRange : 'setViewRange',\n  size : 'size',\n  sort : 'sort',\n  subscribed : 'Subscribed',\n  tableList : 'TableList',\n  unsubscribe : 'TerminateSubscription',\n  viewRangeChanged : 'ViewRangeChanged',\n}\n\nexport const logColor = {\n  plain : 'color: black; font-weight: normal',\n  blue : 'color: blue; font-weight: bold',\n  brown : 'color: brown; font-weight: bold',\n  green : 'color: green; font-weight: bold',\n}\n\nconst {plain} = logColor;\nexport const createLogger = (source, labelColor=plain, msgColor=plain) => ({\n  log: (msg, args='') => console.log(`[${Date.now()}]%c[${source}] %c${msg}`,labelColor, msgColor, args),\n  warn: (msg) => console.warn(`[${source}] ${msg}`)\n})\n","import RemoteSubscription from './remote-subscription';\nimport { connectionId as _connectionId } from './constants';\nimport { ConnectionStatus } from './messages';\n\n// const serverProxy = new ServerProxy(messageFromTheServer);\n\nconst serverProxies = new WeakMap();\nconst servers = new WeakMap();\n\nconst getServerProxy = async serverName => {\n  return serverProxies[serverName] || (serverProxies[serverName] =\n    import(/* webpackIgnore: true */`./server-proxy/${serverName}.js`));\n}\nconst getServer = async (serverName, url, messageFromTheServer) => {\n  if (servers[url]){\n    return servers[url];\n  } \n\n  const {ServerProxy} = await getServerProxy(serverName);\n  return servers[url] = Promise.resolve(new ServerProxy(messageFromTheServer));\n\n}\n\nfunction messageFromTheServer({ type: msgType, ...message }) {\n  switch (msgType) {\n    case Msg.connectionStatus:\n      logger.log(`<==   ${msgType}`)\n      onConnected(message);\n      break;\n    case Msg.snapshot:\n    case Msg.rowSet: \n    case Msg.selected:\n    case Msg.filterData:\n    case Msg.update:\n      subscriptions[message.viewport].postMessageToClient(message);\n      break;\n    default:\n      logger.warn(`does not yet handle ${msgType}`);\n  }\n}\n\n\n\nfunction onConnected(message) {\n  if (message.status === 'ready') {\n    const { connectionId } = message;\n    if (pendingPromises[connectionId]) {\n      // TODO handle reject here as well\n      const { resolve, connectionString, timeoutHandle, isDefaultConnection } = pendingPromises[connectionId];\n      clearTimeout(timeoutHandle);\n      delete pendingPromises[connectionId];\n      const connection = connections[connectionString] = RemoteConnectionAPI(connectionId, postMessageToServer);\n      resolve(connection);\n      if (isDefaultConnection && defaultConnection.status !== 'connected') {\n        defaultConnection.status = 'connected';\n        defaultConnection.resolve(connection);\n      }\n    }\n  }\n}\n\n\n/*--------------------------------------------------------\n\n  Subscribing to services\n\n  --------------------------------------------------------*/\n  export function subscribe(options, clientCallback) {\n    logger.log(`<subscribe> vp ${options.viewport} table ${options.tablename}`)\n    const viewport = options.viewport;\n    // This remoteview is specific to this viewport, no need for mapping\n    const subscription = subscriptions[viewport] = new RemoteSubscription(viewport, postMessageToServer, clientCallback)\n  \n    // subscription blocks here until connection is resolved (to an instance of RemoteConnectionAPI)\n    getDefaultConnection().then(remoteConnection => {\n      logger.log(`>>>>> now we have a remoteConnection, we can subscribe`)\n      remoteConnection.subscribe(options, viewport);\n    });\n  \n    return subscription;\n  }\n  \n  const RemoteConnectionAPI = (connectionId, postMessage) => ({\n  \n    disconnect() {\n      console.log(`disconnect ${connectionId}`)\n    },\n  \n    subscribe(message, viewport) {\n      // From here, the serverProxy will maintain the association between connection\n      // and viewport, we only have to supply viewport\n      logger.log(`[RemoteConnection]<subscribe>  ===>  SW   vp: ${viewport}`)\n      serverProxy.subscribe({\n        connectionId,\n        viewport,\n        type: Msg.addSubscription,\n        ...message\n      });\n    },\n  \n    query: (type, params = null) => new Promise((resolve, reject) => {\n      const requestId = uuid.v1();\n      postMessage({ requestId, type, params });\n      const timeoutHandle = setTimeout(() => {\n        delete pendingPromises[requestId];\n        reject(Error('query timed out waiting for server response'));\n      }, 5000);\n      pendingPromises[requestId] = { resolve, reject, timeoutHandle };\n    })\n  \n  });\n  \n  \nexport default {\n  async connect({serverName, url}){\n    console.log(`ConnectionManager.connect ${serverName} ${url}`);\n\n    const server = await getServer(serverName, url);\n    console.log(`connection-manager got proxy`,server);\n\n    const connectionId = `connection-${_connectionId.nextValue}`;\n    server.connect({ connectionId, connectionString: url, callback: message => {\n      console.log(`message = `, message)\n    }});\n\n\n\n    return server;\n\n  }\n}\n\n/*--------------------------------------------------------\n\n  Connecting to the server\n\n  --------------------------------------------------------*/\n//TODO support for additional connections\nexport const connect = (\n  connectionString,\n  server = AvailableProxies.Viewserver,\n  isDefaultConnection = true && defaultConnection.status === 'pending'\n) => {\n  if (isDefaultConnection) {\n    // is it possible that defaultConnection.status could be pending, yet we have already \n    // resolved this connection ?\n\n    // if we're already connected on the default connection ...\n    // \n    // else ...\n\n    defaultConnection.status = 'connecting';\n  }\n  logger.log(`connect ${connectionString} isDefaultConnection: ${isDefaultConnection}`)\n  // connections[connectionString] set to a promise. However will be replaced with\n  // the actual connection once connected, That can't be right\n  return connections[connectionString] || (\n    connections[connectionString] = new Promise(async (resolve, reject) => {\n      const connectionId = `connection-${_connectionId.nextValue}`;\n      const timeoutHandle = setTimeout(() => {\n        delete pendingPromises[connectionId];\n        reject(new Error('timed out waiting for server response'));\n      }, 5000);\n      pendingPromises[connectionId] = {\n        resolve,\n        reject,\n        connectionString,\n        timeoutHandle,\n        // do we want this to be true ONLY if this was the first request ?\n        isDefaultConnection\n      };\n      logger.log(JSON.stringify({ type: Msg.connect, clientId, connectionId, connectionString }))\n\n      //TODO we need this with support bfor multiple server proxies\n      // import(/* webpackIgnore: true */ `./server-proxy/${server}.js`)\n      // .then(module => {\n      //   const {ServerProxy} = module;\n      //   serverProxy = new ServerProxy(messageFromTheServer);\n        serverProxy.connect({ connectionId, connectionString });\n    //   })\n    //   .catch(err => console.log(`failed to load Server Proxy ${err}`));\n    })\n  )\n}\n","import { DataTypes, columnUtils } from '@heswell/data';\nimport {uuid} from '@heswell/utils';\nimport {\n  msgType as Msg, createLogger, logColor,\n  connectionId as _connectionId,\n} from './constants';\n\n// TODO make this dynamic\nimport { ServerProxy } from './vuu-proxy';\n// import { ServerProxy } from './viewserver-proxy';\nimport ConnectionManager from './connection-manager';\n\nconst { metaData } = columnUtils;\nconst logger = createLogger('RemoteDataView', logColor.blue);\n\nexport const AvailableProxies = {\n  Viewserver: 'viewserver', \n  Vuu: 'vuu'\n}\n\n/*----------------------------------------------------------------\n  Set up the Server Proxy\n  ----------------------------------------------------------------*/\n  // TODO isn't it more natural to pass messageFromTheServer to subscribe ?\n// const serverProxy = new ServerProxy(messageFromTheServer);\n//let serverProxy;\n\nconst postMessageToServer = async (message) => {\n//  serverProxy.handleMessageFromClient(message);\n}\n\nfunction messageFromTheServer({ type: msgType, ...message }) {\n  switch (msgType) {\n    case Msg.connectionStatus:\n      logger.log(`<==   ${msgType}`)\n      onConnected(message);\n      break;\n    case Msg.snapshot:\n    case Msg.rowSet: \n    case Msg.selected:\n    case Msg.filterData:\n    case Msg.update:\n      subscriptions[message.viewport].postMessageToClient(message);\n      break;\n    default:\n      logger.warn(`does not yet handle ${msgType}`);\n  }\n}\n\nconst defaultRange = { lo: 0, hi: 0 };\n\n/*----------------------------------------------------------------\n  connection/subscription management\n  ----------------------------------------------------------------*/\nconst clientId = uuid(); // what purpose does this serve ?\nconst connections = {};\nconst subscriptions = {};\nconst pendingPromises = {};\nlet defaultConnection = { status: 'pending' };\nlet pendingConnection = new Promise((resolve, reject) => {\n  defaultConnection.resolve = resolve;\n  defaultConnection.reject = reject;\n});\n\nconst getDefaultConnection = () => pendingConnection;\n\n\n/*-----------------------------------------------------------------\n A RemoteDataView manages a single subscription via the ServerProxy\n  ----------------------------------------------------------------*/\nexport default class RemoteDataView  {\n\n  constructor({tableName, serverName = AvailableProxies.Viewserver, url}) {\n\n    this.url = url;\n    this.serverName = serverName;\n    this.tableName = tableName;\n\n    this.server = null;  \n    this.columns = null;\n    this.meta = null;\n    this.subscription = null;\n    this.viewport = null;\n    this.filterDataCallback = null;\n    this.filterDataMessage = null;\n\n  }\n\n  async subscribe({\n    viewport = uuid(),\n    tableName = this.tableName,\n    columns,\n    range = defaultRange,\n    ...options\n  }, callback) {\n\n    if (!tableName) throw Error(\"RemoteDataView subscribe called without table name\");\n    if (!columns) throw Error(\"RemoteDataView subscribe called without columns\");\n\n    this.viewport = viewport;\n    this.tableName = tableName;\n    this.columns = columns;\n    this.meta = metaData(columns);\n    logger.log(`range = ${JSON.stringify(range)}`)\n\n    this.server = await ConnectionManager.connect(this);\n    console.log(`>>>>>>>>> server created`, this.server)\n\n    // could we pass all this into the call above ?\n    // this.subscription = subscribe({\n    //   ...options,\n    //   viewport,\n    //   tablename: tableName,\n    //   columns,\n    //   range\n    // }, /* postMessageToClient */(message) => {\n\n    //   const { filterData, data, updates } = message;\n    //   if ((data && data.rows) || updates) {\n    //     callback(data || message);\n    //   } else if (filterData && this.filterDataCallback) {\n    //     this.filterDataCallback(message)\n    //   } else if (filterData) {\n    //     // experiment - need to store the column as well\n    //     this.filterDataMessage = message;\n    //   } else if (data && data.selected){\n    //     // TODO think about this\n    //     const {selected, deselected} = data;\n    //     callback({range, selected, deselected});\n    //   }\n\n    // });\n\n  }\n\n  unsubscribe() {\n\n  }\n\n  setRange(lo, hi) {\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.setViewRange,\n      range: { lo, hi },\n      dataType: DataTypes.ROW_DATA\n    });\n  }\n\n  select(idx, _row, rangeSelect, keepExistingSelection){\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.select,\n      idx,\n      rangeSelect,\n      keepExistingSelection\n    })\n  }\n\n  group(columns) {\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.groupBy,\n      groupBy: columns\n    });\n  }\n\n  setGroupState(groupState) {\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.setGroupState,\n      groupState\n    });\n  }\n\n  sort(columns) {\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.sort,\n      sortCriteria: columns\n    });\n  }\n\n  filter(filter, dataType = DataTypes.ROW_DATA, incremental=false) {\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.filter,\n      dataType,\n      filter,\n      incremental\n    })\n  }\n\n  getFilterData(column, searchText) {\n    if (this.subscription) {\n      this.subscription.getFilterData(column, searchText);\n    }\n  }\n\n  subscribeToFilterData(column, range, callback) {\n    logger.log(`<subscribeToFilterData>`)\n    this.filterDataCallback = callback;\n    this.setFilterRange(range.lo, range.hi);\n    if (this.filterDataMessage) {\n      callback(this.filterDataMessage);\n      // do we need to nullify now ?\n    }\n\n  }\n\n  unsubscribeFromFilterData() {\n    logger.log(`<unsubscribeFromFilterData>`)\n    this.filterDataCallback = null;\n  }\n\n  // To support multiple open filters, we need a column here\n  setFilterRange(lo, hi) {\n    console.log(`setFilerRange ${lo}:${hi}`)\n    postMessageToServer({\n      viewport: this.viewport,\n      type: Msg.setViewRange,\n      dataType: DataTypes.FILTER_DATA,\n      range: { lo, hi }\n    })\n\n  }\n\n}\n\n"],"names":["connectionId","_connectionId","Msg"],"mappings":"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"}