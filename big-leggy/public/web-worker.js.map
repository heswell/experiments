{"version":3,"file":"web-worker.js","sources":["../src/@heswell/server-api/transports/eventEmitter.mjs","../src/@heswell/server-api/connection.mjs","../src/@heswell/server-api/utils/arrayUtils.mjs","../src/@heswell/data/store/columnUtils.js","../src/@heswell/data/store/types.js","../node_modules/d3-array/src/ascending.js","../node_modules/d3-array/src/bisector.js","../node_modules/d3-array/src/bisect.js","../src/@heswell/data/store/filterUtils.js","../src/@heswell/data/store/rangeUtils.js","../src/@heswell/data/store/table.js","../src/@heswell/data/store/rowset/index.js","../src/@heswell/data/store/updateQueue.js","../src/@heswell/data/index.js","../src/@heswell/server-api/subscription.mjs","../src/@heswell/server-api/messages.js","../src/@heswell/server-api/serverProxy.mjs","../src/@heswell/server-api/web-worker.js"],"sourcesContent":["const MAX_LISTENERS = 10;\n\nexport class EventEmitter {\n\n    constructor() {\n        this._events = {};\n        this._maxListeners = MAX_LISTENERS;\n    }\n\n    addListener(type, listener) {\n        let m;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (this._events.newListener) {\n            this.emit('newListener', type, listener);\n        }\n\n        if (!this._events[type]) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        } else if (Array.isArray(this._events[type])) {\n            // If we've already got an array, just append.\n            this._events[type].push(listener);\n        } else {\n            // Adding the second element, need to change to array.\n            this._events[type] = [this._events[type], listener];\n        }\n\n        // Check for listener leak\n        if (Array.isArray(this._events[type]) && !this._events[type].warned) {\n            if (!isUndefined(this._maxListeners)) {\n                m = this._maxListeners;\n            } else {\n                m = MAX_LISTENERS;\n            }\n\n            if (m && m > 0 && this._events[type].length > m) {\n                this._events[type].warned = true;\n                console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                this._events[type].length);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeListener(type, listener) {\n        let list, position, length, i;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events || !this._events[type]) {\n            return this;\n        }\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n\n        } else if (Array.isArray(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0) {\n                return this;\n            }\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeAllListeners(type) {\n\n        if (!this._events) {\n            return this;\n        }\n\n        const listeners = this._events[type];\n\n        if (isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else if (listeners) {\n            // LIFO order\n            while (listeners.length) {\n                this.removeListener(type, listeners[listeners.length - 1]);\n            }\n        }\n        delete this._events[type];\n\n        return this;\n\n    }\n\n    emit(type, ...args) {\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // If there is no 'error' event listener then throw.\n        if (type === 'error') {\n            if (!this._events.error ||\n                (isObject(this._events.error) && !this._events.error.length)) {\n                const err = arguments[1];\n                if (err instanceof Error) {\n                    throw err; // Unhandled 'error' event\n                } else {\n                    // At least give some kind of context to the user\n                    throw new Error('Uncaught, unspecified \"error\" event. (' + err + ')');\n                }\n            }\n        }\n\n        const handler = this._events[type];\n\n        if (isUndefined(handler)) {\n            return false;\n        }\n\n        if (isFunction(handler)) {\n            switch (args.length) {\n            // fast cases\n            case 0:\n                handler.call(this);\n                break;\n            case 1:\n                handler.call(this, type, args[0]);\n                break;\n            case 2:\n                handler.call(this, type, args[0], args[1]);\n                break;\n            // slower\n            default:\n                handler.call(this, type, ...args);\n            }\n        } else if (Array.isArray(handler)) {\n            handler.slice().forEach(listener => listener.call(this, type, ...args));\n        }\n\n        return true;\n\n    }\n\n    once(type, listener) {\n\n        const handler = (evtName, message) => {\n            this.removeListener(evtName, handler);\n            listener(evtName, message);\n        };\n\n        this.on(type, handler);\n\n    }\n\n    on(type, listener) {\n        return this.addListener(type, listener);\n    }\n\n}\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\n","import {EventEmitter} from './transports/eventEmitter.mjs';\n\nconst transportModule = process.env.TRANSPORT;\n\nlet connection;\nlet _requestSeq = 0;\n\nexport default class Connection extends EventEmitter {\n\n    static connect(connectionString, userid=null, password=null) {\n\n        return connection || (connection = new Promise(\n            function (resolve, reject) {\n                import(/* webpackIgnore: true */ transportModule)\n                    .then(module => module.connect(connectionString))\n                    .then(transport => new Connection(transport))\n                    .then(resolve);\n            }\n        ));\n    }\n\n    constructor(transport) {\n\n        super();\n\n        this.transport = transport;\n\n        transport.on('message', (evtName, message) => {\n            if (Array.isArray(message)) {\n                message.forEach(message => this.publishMessage(message));\n            } else {\n                this.publishMessage(message);\n            }\n\n        });\n    }\n\n    publishMessage(message){\n        this.emit('message', message);\n    }\n\n    // send message to server\n    send(message){\n        this.transport.send(message);\n    }\n\n    // we could also allow server to provide it\n    nextRequestId() {\n        _requestSeq += 1;\n        return 'REQ' + _requestSeq;\n    }\n\n}\n","export function findKey(arr, test){\n    for (let i=0;i<arr.length;i++){\n        if (test(arr[i])){\n            return arr[i].key;\n        }\n    }\n}\n\nexport function indexOf(arr, test){\n    for (let i=0;i<arr.length;i++){\n        if (test(arr[i])){\n            return i;\n        }\n    }\n    return -1;\n}\n\nexport function replace(arr,idx, value){\n    const result = arr.slice();\n    result[idx] = value;\n    return result;\n}\n\n","\nconst SORT_ASC = 'asc';\n\nexport function mapSortCriteria(sortCriteria, columnMap) {\n    return sortCriteria.map(s => {\n        if (typeof s === 'string') {\n            return [columnMap[s], 'asc'];\n        } else if (Array.isArray(s)) {\n            const [columnName, sortDir] = s;\n            return [columnMap[columnName], sortDir || SORT_ASC];\n        } else {\n            throw Error('columnUtils.mapSortCriteria invalid input');\n        }\n\n    });\n}\n\nexport function buildColumnMap(columns){\n    if (columns){\n        return columns.reduce((map, column, i) => {\n            if (typeof column === 'string'){\n                map[column] = i;\n            } else if (typeof column.key === 'number') {\n                map[column.name] = column.key;\n            } else {\n                map[column.name] = i;\n            }\n            return map;\n        },{})\n    } else {\n        return null;\n    }\n}\n\nexport function projectColumns(map, columns){\n    const length = columns.length;\n    return startIdx => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        out.push(startIdx+i, 0, 0, row[0]);\n        return out;\n    }\n}\n\nexport const toColumn = column =>\n    typeof column === 'string'\n        ? { name: column }\n        : column;\n\nexport function getFilterType(column){\n    return column.filter || getDataType(column);\n}\n\nexport function getDataType({type=null}){\n    return type === null\n        ? 'set'\n        : typeof type === 'string'\n            ? type\n            : typeof type === 'object'\n                ? type.name\n                : 'set';\n\n}\n\n//TODO cache result by length\nexport function metaData(columns){\n    const len = columns.length;\n    let metaStart = 0;\n    const next = () => len + metaStart++;\n    return {\n        IDX: next(),\n        DEPTH: next(),\n        COUNT: next(),\n        KEY: next(),\n        PARENT_IDX: next(),\n        IDX_POINTER: next(),\n        FILTER_COUNT: next(),\n        NEXT_FILTER_IDX: next(),\n        count: columns.length + metaStart\n    }\n}\n","export const DataTypes = {\n    ROW_DATA: 'rowData',\n    FILTER_DATA: 'filterData',\n    FILTER_BINS: 'filterBins'\n};\n\nexport const ASC = 'asc';\nexport const DSC = 'dsc';\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","import * as d3 from 'd3-array';\n// import { stringCollector } from './dataCollector';\nimport {SET, EXCLUDE, STARTS_WITH} from './filter';\nimport {metaData} from './columnUtils';\n\nexport const FILTER_DATA_COLUMNS = [\n    {name: 'value'}, \n    {name: 'count'}, \n    {name: 'totalCount'}\n];\n\nexport const filterColumnMeta = metaData(FILTER_DATA_COLUMNS)\n\nexport function getFilterColumn(column) {\n    return column.isGroup ? column.columns[0] : column;\n}\n\nexport function shouldShowFilter(filterColumnName, column) {\n    const filterColumn = getFilterColumn(column);\n    if (filterColumn.isGroup) {\n        return filterColumn.columns.some(col => col.name === filterColumnName);\n    } else {\n        return filterColumnName === filterColumn.name;\n    }\n}\n\nexport function includesNoValues(filter) {\n    // TODO make sure we catch all cases...\n    if (!filter){\n        return false;\n    } else if (filter.type === SET && filter.mode !== EXCLUDE && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === 'AND' && filter.filters.some(f => includesNoValues(f))){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// does f2 only narrow the resultset from f1\nexport function extendsFilter(f1=null, f2=null) {\n    // ignore filters which are identical\n    // include or exclude filters which add values\n    if (f2 === null){\n        return false\n    } else if (f1 === null) {\n        return true;\n    }\n    if (f1.colName && f1.colName === f2.colName) {\n        if (f1.type === f2.type) {\n            switch (f1.type) {\n            case SET:\n                return f1.mode === EXCLUDE\n                    ? f2.values.length > f1.values.length && containsAll(f2.values, f1.values)\n                    : f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n            case STARTS_WITH: return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n                // more cases here such as GT,LT\n            default:\n            }\n        }\n\n    } else if (f1.colname && f2.colName) {\n        // different columns,always false\n        return false;\n    } else if (f2.type === 'AND' && extendsFilters(f1, f2)) {\n        return true;\n    }\n\n    // safe option is to assume false, causing filter to be re-applied to base data\n    return false;\n}\n\nconst byColName = (a, b) => a.colName === b.colName ? 0 : a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1, f2) {\n    if (f1.colName) {\n        const matchingFilter = f2.filters.find(f => f.colName === f1.colName);\n        return filterEquals(matchingFilter, f1, true);\n    } else if (f1.filters.length === f2.filters.length) {\n        // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n        // then we are still extending the filter (i.e. narrowing the resultset)\n        const a = f1.filters.sort(byColName);\n        const b = f2.filters.slice().sort(byColName);\n\n        for (let i = 0; i < a.length; i++) {\n            if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (f2.filters.length > f1.filters.length){\n        return f1.filters.every(filter1 => {\n            const filter2 = f2.filters.find(f => f.colName === filter1.colName);\n            return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n        });\n    }\n}\n\nexport function includesColumn(filter, column) {\n    if (!filter) {\n        return false;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case 'AND': return filters.some(f => includesColumn(f, column));\n    default: return colName === column.name;\n    }\n}\n\nexport function addFilter(existingFilter, filter) {\n    if (!existingFilter) {\n        return filter;\n    } else if (!filter) {\n        return existingFilter;\n    } else if (existingFilter.type === 'AND' && filter.type === 'AND') {\n        return { type: 'AND', filters: combine(existingFilter.filters, filter.filters) };\n    } else if (existingFilter.type === 'AND') {\n        return { type: 'AND', filters: replaceOrInsert(existingFilter.filters, filter) };\n    } else if (filter.type === 'AND') {\n        return { type: 'AND', filters: filter.filters.concat(existingFilter) };\n    } else if (filterEquals(existingFilter, filter)) {\n        return filter;\n    } else {\n        return { type: 'AND', filters: [existingFilter, filter] };\n    }\n}\n\nfunction replaceOrInsert(filters, filter) {\n    if (filter.type === SET) {\n        const idx = filters.findIndex(f => f.type === filter.type && f.colName === filter.colName);\n        if (idx !== -1) {\n            return filters.map((f, i) => i === idx ? filter : f);\n        }\n    }\n\n    return filters.concat(filter);\n}\n\n// TODO merge sets\nfunction combine(existingFilters, replacementFilters) {\n\n    // TODO need a safer REGEX here\n    function equivalentType({ type: t1 }, { type: t2 }) {\n        return (t1 === t2) || (t1[0] === t2[0]);\n    }\n\n    const replaces = (existingFilter, replacementFilter) => {\n        return existingFilter.colName === replacementFilter.colName &&\n            equivalentType(existingFilter, replacementFilter);\n    };\n\n    const stillApplicable = existingFilter => replacementFilters.some(\n        replacementFilter => replaces(existingFilter, replacementFilter)) === false;\n\n    return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nexport function removeFilter(sourceFilter, filterToRemove) {\n    if (filterEquals(sourceFilter, filterToRemove, true)) {\n        return null;\n    } else if (sourceFilter.type !== 'AND') {\n        throw Error(`removeFilter cannot remove ${JSON.stringify(filterToRemove)} from ${JSON.stringify(sourceFilter)}`);\n    } else {\n        const filters = sourceFilter.filters.filter(f => !filterEquals(f, filterToRemove));\n        return filters.length > 0 ? { type: 'AND', filters } : null;\n    }\n}\n\nexport function splitFilterOnColumn(filter, columnName) {\n    if (!filter){\n        return [null,null];\n    } else if (filter.colName === columnName) {\n        return [filter,null];\n    } else if (filter.type !== 'AND') {\n        return [null, filter];\n    } else {\n        const [[columnFilter=null], filters] = partition(filter.filters, f => f.colName === columnName);\n        return filters.length === 1\n            ? [columnFilter,filters[0]]\n            : [columnFilter, { type: 'AND', filters }];\n    }\n}\n\nexport function extractFilterForColumn(filter, columnName) {\n    if (!filter) {\n        return null;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case 'AND': return filters.find(f => extractFilterForColumn(f, columnName)) || null;\n    default: return colName === columnName ? filter : null;\n    }\n}\n\nexport function removeFilterForColumn(sourceFilter, column) {\n    const colName = column.name;\n    if (!sourceFilter){\n        return null;\n    } else if (sourceFilter.colName === colName) {\n        return null;\n    } else if (sourceFilter.type !== 'AND') {\n        throw Error(`removeFilter cannot remove ${column.name} from ${JSON.stringify(sourceFilter)}`);\n    } else {\n        const filters = sourceFilter.filters.filter(f => f.colName !== colName);\n        return filters.length === 1\n            ? filters[0]\n            : { type: 'AND', filters };\n    }\n}\n\nexport function filterEquals(f1, f2, strict = false) {\n    if (f1 && f1){\n        const sameColumn = f1.colName === f2.colName;\n        if (!strict) {\n            return sameColumn;\n        } else {\n            return sameColumn &&\n                f1.type === f2.type &&\n                f1.value === f2.value &&\n                sameValues(f1.values, f2.values);\n        }\n    } else {\n        return false;\n    }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1, f2) {\n    if (f1.type === SET && f1.mode !== EXCLUDE && f2.type === SET && f2.mode !== EXCLUDE) {\n        return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n    } else if (f1.type === SET && f1.mode === EXCLUDE && f2.type === SET && f2.mode === EXCLUDE) {\n        return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n    } else {\n        return false;\n    }\n}\n\n//TODO roll this into next function\nexport function projectFilterData(filterRows) {\n    return filterRows.map((row, idx) => [idx, 0, 0, null, row.name, row.count]);\n}\n\n// export function getDistinctValues(rows, key, ignoreDepth=false) {\n//     const collector = stringCollector(false);\n//     // const start = performance.now();\n//     for (let i = 0, len = rows.length; i < len; i++) {\n//         if (ignoreDepth || rows[i][System.DEPTH_FIELD] === 0){\n//             collector.add(rows[i][key]);\n//         }\n//     }\n//     const values = collector.values();\n//     // const end = performance.now();\n//     // console.log(`%ctook ${end - start} ms to build list of set values`, 'font-weight:bold;color:red;');\n\n//     return values;\n\n// }\n\nexport function getBinnedValues(rows, key, numberOfBins = 20) {\n    const numbers = rows.map(row => row[key]);\n    // const start = performance.now();\n    const values = d3.histogram().thresholds(numberOfBins)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n    // const end = performance.now();\n    // console.log(`%ctook ${end - start} ms to build histogram`, 'font-weight:bold;color:red;');\n    // console.log(values);\n    return values;\n\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll(superList, subList) {\n    for (let i = 0, len = subList.length; i < len; i++) {\n        if (superList.indexOf(subList[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues(arr1, arr2) {\n    if (arr1 === arr2) {\n        return true;\n    } else if (arr1.length === arr2.length) {\n        const a = arr1.slice().sort();\n        const b = arr2.slice().sort();\n        return a.join('|') === b.join('|');\n    }\n    return false;\n}\n\nfunction partition(list, test1, test2=null) {\n    const results1 = [];\n    const misses = [];\n    const results2 = test2===null ? null : [];\n\n    for (let i = 0; i < list.length; i++) {\n        if (test1(list[i])) {\n            results1.push(list[i]);\n        } else if (test2 !== null && test2(list[i])) {\n            results2.push(list[i]);\n        } else {\n            misses.push(list[i]);\n        }\n    }\n\n    return test2 === null\n        ? [results1, misses]\n        : [results1, results2, misses];\n}\n","export const NULL_RANGE = {lo: 0,hi: 0};\n\n// If the requested range overlaps the last sent range, we only need send the\n// newly exposed section of the range. The client will manage dropping off\n// the expired section.\n//\n// |----------------------------------| _range\n//  ++++++|----------------------------------| prevRange\n//  \n//\n//\n//  |------------------------------------| _range\n//  |----------------------------------|+  prevRange\n//TODO do we still need these calls to getFullRange ?\nexport function getDeltaRange(oldRange, newRange){\n    const {lo: oldLo, hi: oldHi} = oldRange /*getFullRange(oldRange)*/;\n    const {lo: newLo, hi: newHi} = newRange /*getFullRange(newRange)*/;\n\n    if (newLo >= oldLo && newHi <= oldHi){\n        // reduced range, no delta\n        return {lo: newHi, hi: newHi};\n\n    } else if (newLo >= oldHi || newHi < oldLo){\n        return {lo: newLo, hi: newHi};\n    } else if (newLo === oldLo && newHi === oldHi){\n        return {lo: oldHi,hi: oldHi};\n    } else {\n        return {\n            lo: newLo < oldLo ? newLo: oldHi,\n            hi: newHi > oldHi ? newHi: oldLo\n        };\n    }\n}\n\nexport function resetRange({lo,hi,bufferSize=0}){\n    return {\n        lo: 0,\n        hi: hi-lo,\n        bufferSize\n    };\n}\n\nexport function getFullRange({lo,hi,bufferSize=0}){\n    return {\n        lo: Math.max(0, lo - bufferSize),\n        hi: hi + bufferSize\n    };\n}\n\nexport function withinRange(range, index, offset=0) {\n    return index-offset >= range.lo && index-offset < range.hi;\n}\n\nconst SAME = 0;\nconst FWD = 2;\nconst BWD = 4;\nconst CONTIGUOUS = 8;\nconst OVERLAP = 16;\nconst REDUCE = 32;\nconst EXPAND = 64;\nconst NULL = 128;\n\nexport const RangeFlags = {\n    SAME,\n    FWD,\n    BWD,\n    CONTIGUOUS,\n    OVERLAP,\n    REDUCE,\n    EXPAND,\n    NULL\n}\n\nRangeFlags.GAP = ~(CONTIGUOUS | OVERLAP | REDUCE)\n\nexport function compareRanges(range1, range2){\n    if (range2.lo === 0 && range2.hi === 0){\n        return NULL;\n    } else if (range1.lo === range2.lo && range1.hi === range2.hi){\n        return SAME;\n    } else if (range2.hi > range1.hi){\n        if (range2.lo > range1.hi){\n            return FWD;\n        } else if (range2.lo === range1.hi){\n            return FWD + CONTIGUOUS;\n        } else if (range2.lo >= range1.lo){\n            return FWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo < range1.lo){\n        if (range2.hi < range1.lo){\n            return BWD;\n        } else if (range2.hi === range1.lo){\n            return BWD + CONTIGUOUS;\n        } else if (range2.hi > range1.lo){\n            return BWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo > range1.lo) {\n        return REDUCE + FWD;\n    } else {\n        return REDUCE + BWD\n    }\n}\n","/*global fetch */\nimport {EventEmitter} from '@heswell/utils';\nimport {buildColumnMap} from './columnUtils'\n\nconst defaultUpdateConfig = {\n    applyUpdates: false,\n    applyInserts: false,\n    interval: 500\n}\n\nexport default class Table extends EventEmitter {\n\n    constructor(config){\n        super();\n\n        const {name, columns=null, primaryKey, dataPath, data, updates = {}} = config;\n\n        this.name = name;\n        this.primaryKey = primaryKey;\n        this.columns = columns;\n        this.keys = {};\n        this.index = {};\n        this.rows = [];\n        this.updateConfig = {\n            ...defaultUpdateConfig,\n            ...updates\n        }\n        this.columnMap = buildColumnMap(columns);\n        this.columnCount = 0;\n        this.status = null;\n\n        if (data){\n            this.parseData(data);\n        } else if (dataPath){\n            this.loadData(dataPath);\n        }\n\n        this.installDataGenerators(config);\n    }\n\n    // ...updates = one or more pairs of (colIdx, colValue)\n    update(rowIdx, ...updates){\n        //onsole.log(`Table.update ${this.name} idx: ${rowIdx}  ${JSON.stringify(updates)}` );\n        const results = [];\n        let row = this.rows[rowIdx];\n        for (let i=0;i<updates.length;i+=2){\n            const colIdx = updates[i];\n            const value = updates[i+1];\n            results.push(colIdx, row[colIdx], value);\n            row[colIdx] = value;\n        }\n        this.emit('rowUpdated', rowIdx, results);\n    }\n\n    insert(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const idx = this.rows.length;\n        let row = this.rowFromData(idx, data, columnnameList);\n        this.rows.push(row);\n        this.emit('rowInserted', idx, row);\n    }\n\n    remove(key){\n        if (this.keys[key]){\n            const index = this.indices[key];\n            delete this.keys[key];\n            delete this.indices[key];\n            this.rows.splice(index,1);\n\n            for (let k in this.indices){\n                if (this.indices[k] > index){\n                    this.indices[k] -= 1;\n                }\n            }\n\n            this.emit('rowRemoved', this.name, key);\n\n        }\n    }\n\n    clear(){\n\n    }\n\n    toString(){\n        const out = ['\\n' + this.name];\n        out.splice.apply(out, [1,0].concat(this.rows.map(function(row){return row.toString();})));\n        return out.join('\\n');\n    }\n\n    async loadData(url){\n        fetch(url,{\n\n        })\n            .then(data => data.json())\n            .then(json => {\n                console.log(`Table.loadData: got ${json.length} rows`);\n                this.parseData(json);\n            })\n            .catch(err => {\n                console.error(err);\n            });\n\n    }\n\n    parseData(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const rows = [];\n        for (let i=0;i<data.length;i++){\n            let row = this.rowFromData(i, data[i], columnnameList);\n            rows.push(row);\n        }\n        this.rows = rows;\n\n        if (this.columns === null){\n            this.columns = columnsFromColumnMap(this.inputColumnMap);\n            this.columnMap = buildColumnMap(this.columns);\n        }\n        this.status = 'ready';\n        this.emit('ready');\n        if (this.updateConfig && this.updateConfig.applyUpdates !== false){\n            setTimeout(() => {\n                this.applyUpdates();\n            },1000);\n        }\n        // move this\n        if (this.updateConfig && this.updateConfig.applyInserts !== false){\n            setTimeout(() => {\n                this.applyInserts();\n            },10000);\n        }\n    }\n\n    rowFromData(idx, data, columnnameList){\n        // 2 metadata items for each row, the idx and unique key\n        const {index, primaryKey=null, columnMap: map} = this;\n\n        if (Array.isArray(data)){\n            const key = data[map[this.primaryKey]];\n            index[key] = idx;\n            return [...data, idx, key];\n        } else {\n            // This allows us to load data from objects as rows, without predefined columns, where\n            // not every row may have every column. How would we handle primary key ?\n            const columnMap = map || (this.columnMap = {});\n            const colnames = columnnameList || Object.getOwnPropertyNames(data);\n            const row = [idx];\n            let colIdx;\n            let key;\n\n            for (let i=0; i<colnames.length; i++){\n                const name = colnames[i];\n                const value = data[name];\n                if ((colIdx = columnMap[name]) === undefined){\n                    colIdx = columnMap[name] = this.columnCount++;\n                }\n                row[colIdx] = value;\n                // If we don't know the primary key, assume it is the first column for now\n                if ((name === primaryKey) || (primaryKey === null && i === 0)){\n                    key = value;\n                    index[value] = idx;\n                }\n            }\n            // doesn't this risk pushing the metadata into the wrong slots if not every row has every \n            // field\n            row.push(idx, key)\n            return row;\n        }\n    }\n\n    //TODO move all these methods into an external helper\n    applyInserts(){\n\n        const idx = this.rows.length;\n        const newRow = this.createRow(idx);\n        if (newRow){\n            this.insert(newRow);\n        } else {\n            console.log(`createRow did not return a new row`);\n        }\n\n        setTimeout(() => this.applyInserts(),5000);\n\n    }\n\n    applyUpdates(){\n        const {rows} = this;\n        // const count = Math.round(rows.length / 50);\n        const count = 100;\n\n        for (let i=0; i<count; i++){\n            const rowIdx = getRandomInt(rows.length - 1);\n            const update = this.updateRow(rowIdx, this.rows[rowIdx], this.columnMap);\n            if (update){\n                this.update(rowIdx, ...update);\n            }\n        }\n\n        setTimeout(() => this.applyUpdates(),this.updateConfig.interval);\n\n    }\n\n    createRow(idx){\n        console.warn(`createRow ${idx} must be implemented as a plugin`);\n    }\n\n    updateRow(/*idx, row, columnMap*/){\n        return null;\n    }\n\n    async installDataGenerators(/*config*/){\n        //console.warn(`installDataGenerators must be implemented by a more specific subclass`);\n    }\n\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction columnsFromColumnMap(columnMap){\n\n    const columnNames = Object.getOwnPropertyNames(columnMap);\n\n    return columnNames\n        .map(name => ({name, key: columnMap[name]}))\n        .sort(byKey)\n        .map(({name}) => ({name}));\n\n}\n\nfunction byKey(col1, col2){\n    return col1.key - col2.key;\n}\n","// Note, these must be exported in this order and must be consumed from this file.\n// to avoid circular dependency issues.\nexport {FilterRowSet} from './filter-rowset';\nexport {RowSet} from './rowSet';\nexport {GroupRowSet} from './group-rowset';","/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nexport default class UpdateQueue {\n\n    constructor(){\n        this._queue = [];\n    }\n\n      get length() { return this._queue.length; }\n\n      update(update) {\n          //TODO we could also coalesce updates into an insert or rowset, if present\n          const batch = this.getCurrentBatch('update');\n\n          const [rowIdx] = update;\n          const {updates} = batch;\n\n          for (let i = 0, len = updates.length; i < len; i++) {\n              if (updates[i][0] === rowIdx) {\n                  // we already have an update for this item, update the update...\n                  let d = updates[i];\n                  for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n                      const pos = d.indexOf(update[colIdx]);\n                      if (pos === -1) {// should check that it is really a colIdx,not a value\n                          d.push(update[colIdx], update[colIdx + 1]);\n                      } else {\n                          d[pos + 1] = update[colIdx + 1];\n                      }\n                  }\n\n                  return;\n              }\n          }\n          updates.push(update);\n      }\n\n      resize(size) {\n          const batch = this.getCurrentBatch('size');\n          batch.size = size;\n      }\n\n      append(row, offset) {\n          const batch = this.getCurrentBatch('insert');\n          //onsole.log(`UpdateQueue append ${row[0]}`);\n          batch.rows.push(row);\n          batch.offset = offset;\n      }\n\n      replace(rows, size, offset) {\n          const batch = this.getCurrentBatch('rowset');\n          batch.rows = rows;\n          batch.size = size;\n          batch.offset = offset;\n      }\n\n      popAll() {\n          const results = this._queue;\n          this._queue = [];\n          return results;\n      }\n\n      getCurrentBatch(type) {\n\n          const q = this._queue;\n          const len = q.length;\n\n          let batch = len === 0 || type === 'rowset'\n              ? (q[0] = createBatch(type))\n              : q[len - 1];\n\n          if (batch.type !== type) {\n              // roll size recored into subsequent insert \n              if (type === 'insert' && batch.type === 'size') {\n                  batch.type = 'insert';\n                  batch.rows = [];\n              } else if (type === 'size' && batch.type === 'insert') {\n                  // that's ok - go ahead and update size on the insert batch\n              } else {\n                  batch = (q[len] = createBatch(type));\n              }\n          }\n\n          return batch;\n\n      }\n  }\n\nfunction createBatch(type) {\n    switch (type) {\n    case 'rowset': return { type, rows: [] };\n    case 'update': return { type, updates: [] };\n    case 'insert': return { type, rows: [] };\n    case 'size': return { type };\n    default: throw Error('Unknown batch type');\n    }\n}\n","\nimport {SET, INCLUDE, EXCLUDE, INCLUDE_SEARCH, EXCLUDE_SEARCH, STARTS_WITH} from './store/filter'\nimport { getFilterType, toColumn, buildColumnMap, metaData } from './store/columnUtils'\nimport { sortByToMap } from './store/sort'\nimport { \n  addFilter,\n  removeFilterForColumn,\n  extractFilterForColumn,\n  getFilterColumn,\n  includesColumn,\n  shouldShowFilter } from './store/filterUtils';\nimport {\n  getFullRange,\n  resetRange,\n  NULL_RANGE as NULL } from './store/rangeUtils';\n\nimport {\n  toggleGroupState,\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby } from './store/groupUtils'\n\nimport {\n  isEmptyRow,\n  mergeAndPurge,\n  purgeAndFill,\n  update } from './store/rowUtils'\n\nimport * as types from './store/types';\n\nexport const groupHelpers = {\n  toggleGroupState,\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby\n}\n\nexport {default as Table} from './store/table';\nexport {default as InMemoryView} from './store/InMemoryView';\n\nexport const sortUtils = {\n  sortByToMap\n}\n\nexport const columnUtils = {\n  buildColumnMap,\n  getFilterType,\n  toColumn,\n  metaData\n}\n\nexport const rowUtils = {\n  isEmptyRow, mergeAndPurge, purgeAndFill, update\n}\n\nexport const filter = {\n  SET,\n  INCLUDE,\n  EXCLUDE,\n  STARTS_WITH,\n  INCLUDE_SEARCH,\n  EXCLUDE_SEARCH\n}\n\nexport const filterUtils = {\n  shouldShowFilter,\n  addFilter,\n  extractFilterForColumn,\n  removeFilterForColumn,\n  getFilterColumn,\n  includesColumn\n}\n\nexport const rangeUtils = {\n  getFullRange,\n  resetRange\n}\n\nexport const DataTypes = types.DataTypes;\n\nexport const ASC = types.ASC;\nexport const DSC = types.DSC;\nexport const NULL_RANGE = NULL;\n","import { replace, indexOf } from './utils/arrayUtils.mjs';\nimport {rangeUtils, DataTypes} from '../data/index';\nimport { metaData } from '../data/store/columnUtils';\n\nconst {NULL_RANGE} = rangeUtils;\n\n//TODO can this be merged with DataRange\nexport class DataRange {\n    constructor(range = NULL_RANGE, size = 0, offset = 0, data = []) {\n        this.range = range;\n        this._size = size;\n        this.offset = offset;\n        this.data = data;\n        this.selected = null;\n        this.pendingRange = null;\n    }\n    get size(){\n        return this._size;\n    }\n    set size(val) {\n        if (typeof val !== 'number') {\n            console.error(`DataRange.size invalid value ${val}`);\n        } else {\n            if (this.data.length > val) {\n                this.data.length = val;\n            }\n            this._size = val;\n        }\n    }\n    clear() {\n        this._size = 0;\n        this.data.length = 0;\n        this.range = rangeUtils.resetRange(this.range);\n    }\n}\n\nexport default class Subscription {\n\n    // TODO need to allow for large bufferSize, so we can load entire dataset\n    constructor({ columns, range, size = 0, offset = 0 }) {\n        this.columns = columns;\n        this.meta = metaData(columns);\n        this.bufferSize = 100;\n        this._data = new DataRange(range, size, offset);\n        this._filterData = new DataRange();\n    }\n\n    get offset() { return this._data.offset; }\n    get size() { return this._data.size; }\n    set size(val) { this._data.size = val; }\n\n    reset(dataType, range = NULL_RANGE) {\n        console.log(`reset ${dataType} ${JSON.stringify(range)}`);\n        const targetData = this.getData(dataType);\n        targetData.data = [];\n        targetData.size = 0;\n        targetData.range = range;\n    }\n\n    putSnapshot({ size, offset, rows, range: rangeFromServer }) {\n        const { range } = this._data;\n        this._data = new DataRange(range, size, offset, rows);\n        const results = this._data.data.slice(range.lo, range.hi);\n        console.log(`[Subscription.putSnapshot] range: ${range.lo} - ${range.hi} in: ${rows.length} rows, out: ${results.length} rows`);\n        return results;\n    }\n\n    clear() {\n        this._data.clear();\n    }\n    // realign the (buffered) data set to the new range.\n    // return any rows that we already have in the buffer and that now come into range.\n    putRange({ lo, hi }, dataType = DataTypes.ROW_DATA) {\n        console.log(`[Subscription.putRange] range=${lo} - ${hi}`);\n        const targetData = this.getData(dataType);\n        const [out, rowsInRange] = this._putRange(targetData, lo, hi);\n        targetData.range = { lo, hi };\n        targetData.data = out;\n        return rowsInRange;\n    }\n\n    // this never changes the range, rows within data are already aligned to (buffered) range\n    // we need to be passed in the INDEX_OFFSET so we can detect change\n    putRows(rows, offset = 0) {\n\n        const targetData = this._data;\n        const results = this._putRows(targetData, rows, offset);\n\n        if (offset !== targetData.offset) {\n            targetData.offset = offset;\n        }\n\n        console.log(`[Subscription.putRows] in: ${rows.length} rows, out: ${results.rowset.length} rows`);\n        return results;\n    }\n\n    putData(dataType, { rows: data, size, selectedIndices = null }) {\n        //onsole.groupCollapsed(`Subscription.putData<${dataType}> [${data.length ? data[0][0]: null} - ${data.length ? data[data.length-1][0]: null}]`);\n\n        const targetData = this.getData(dataType);\n        // console.log(JSON.stringify(targetData.data));\n\n        targetData.size = size;\n        if (selectedIndices !== null) {\n            targetData.selected = selectedIndices;\n        }\n\n        const results = this._putRows(targetData, data);\n        // if (results.rowset.length){\n        //     console.log(`results\n        //         ${results.rowset[0][0]} (${results.rowset[0][0]}) - ${results.rowset[results.rowset.length-1][4]} (${results.rowset[results.rowset.length-1][0]})`);\n        // } else {\n        //     console.log(`no results output from putData`);\n        // }\n        //onsole.groupEnd();\n        return results;\n    }\n\n    get rowData() { return this._data; }\n    get filterData() { return this._filterData; }\n    get filterSize() { return this._filterData.size; }\n    set filterSize(val) { this._filterData.size = val; }\n    get filterSelected() { return this._filterData.selected; }\n\n    getData(dataType) {\n        return dataType === DataTypes.ROW_DATA ? this._data :\n            dataType === DataTypes.FILTER_DATA ? this._filterData :\n                null;\n    }\n\n    _putRange(targetData, lo, hi) {\n        const { data, range, offset } = targetData;\n        const {IDX} = this.meta;\n\n        const low = lo + offset;\n        const high = hi + offset;\n        const bufferLow = Math.max(offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const prevLow = range.lo + offset;\n        const prevHigh = range.hi + offset;\n        const len = data.length;\n        const out = [];\n        const rowsInRange = [];\n        let requiredLow;\n        let requiredHigh;\n        let row;\n        let firstRowIdx = -1;\n        let i = 0;\n\n        if (low >= prevHigh || high <= prevLow) {\n            requiredLow = low;\n            requiredHigh = high;\n        } else if (high > prevHigh) {\n            requiredLow = prevHigh;\n            requiredHigh = high;\n        } else {\n            requiredLow = low;\n            requiredHigh = prevLow;\n        }\n\n        while (row === undefined && firstRowIdx < len) {\n            firstRowIdx += 1;\n            row = data[firstRowIdx];\n        }\n\n        for (i = firstRowIdx; i < len; i++) {\n            row = data[i];\n            // Don't discard any rows if we haven't sent the range to the server.\n            // if row is undefined, we have a gap in our data. THis happens when scrolling backwards\n            // we have discarded some data when we were going forwards, but the server doesn't know\n            // that, so hasn't sent us enough data \n            if (row) {\n                let idx = row[IDX];\n\n                if (idx >= bufferHigh) {\n                    break;\n                } else if (idx >= bufferLow && idx < bufferHigh) { // ok as long as we're scrolling forwards\n                    out[idx - bufferLow] = row;\n\n                    if (idx >= requiredLow && idx < requiredHigh) {\n                        rowsInRange.push(row);\n                    }\n                }\n            }\n        }\n\n        return [out, rowsInRange];\n\n    }\n\n    _putRows(targetData, rows, newOffset = 0) {\n        const { data, range, offset } = targetData;\n        const {IDX} = this.meta;\n        const { lo, hi } = range;\n        const low = lo + offset;\n        const high = hi + offset;\n        const bufferLow = Math.max(offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const rowset = [];\n        const updates = [];\n\n        for (let i = 0; i < rows.length; i++) {\n            let row = rows[i];\n            let idx = row[IDX];\n\n            if (lo === 0 && idx < offset) {\n                //onsole.log(`Subscription.putRows we are at the top and this.is an insert at the top`);\n                data.unshift(row); // unsafe  - temp hack only\n                rowset.push(row);\n                if (newOffset === offset) {\n                    console.warn(`Subscription.putRows would expect a lowered offset in this scenario`);\n                }\n            } else if (idx >= bufferLow && idx < bufferHigh) {\n                let rowIdx = idx - bufferLow;\n                data[rowIdx] = row;\n                if (idx >= low && idx < high) {\n                    rowset.push(row);\n                }\n            }\n        }\n\n        return { rowset, updates };\n\n    }\n\n    putUpdates(updates) {\n\n        const { lo, hi } = this._data.range;\n        const low = lo + this.offset;\n        const high = hi + this.offset;\n        const bufferLow = Math.max(this.offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const updatesInRange = [];\n\n        //onsole.log(`%cSubscription.putUpdates ${updates.length} updates range = lo:${lo} hi: ${hi}`,'color:green;font-eright:bold');\n\n        for (let i = 0; i < updates.length; i++) {\n            let update = updates[i];\n            let idx = update[0];\n\n            if (idx >= bufferLow && idx < bufferHigh) {\n                let row = this._data.data[idx - bufferLow];\n\n                if (row === undefined) {\n                    console.log(`%cSubscription.putUpdates update submitted for row that is absent from buffer idx:${idx}\n                        range [${lo} - ${hi}] ==> [${low} - ${high}]\n                        buffer [${bufferLow} ${bufferHigh}]\n                        `, `color:red;font-weight:bold`);\n                } else {\n                    // keep the rows immutable, these row instances end up going to the client\n                    row = row.slice();\n                    // apply updates\n                    //onsole.log(`client.Subscription receive updates ${JSON.stringify(update)}`);\n                    for (let ii = 1; ii < update.length; ii += 2) {\n                        // should we double check that the value has actually changed ?\n                        row[update[ii]] = update[ii + 1];\n                    }\n\n                    if (idx >= low && idx < high) {\n                        updatesInRange.push(update);\n                    }\n                    this._data.data[idx - bufferLow] = row;\n                }\n\n            }\n        }\n\n        //onsole.log(`%c    ... ${updates.length} updates ${updatesInRange.length} in range `,'color:green;font-eright:bold');\n        return { updates: updatesInRange };\n\n    }\n\n    // Replace the group row with toggled group state and return it immediately to the client.\n    // We have the opportunity for more caching opportunities here - caching the \n    // child contents of grouped data.\n    toggleGroupNode(groupKey) {\n        const { KEY, DEPTH } = this.meta;\n        const idx = indexOf(this._data.data, row => row[KEY] === groupKey);\n        const groupRow = this._data.data[idx];\n        return this._data.data[idx] = replace(groupRow, DEPTH, -groupRow[DEPTH]);\n    }\n}\n","export const CONNECT = 'connect';\nexport const SUBSCRIBE = 'AddSubscription';\nexport const COLUMN_LIST = 'ColumnList';\nexport const DATA = 'data';\nexport const FILTER_DATA = 'filterData';\nexport const GROUP_BY = 'groupBy';\nexport const TABLE_LIST = 'TableList';\nexport const UNSUBSCRIBE = 'TerminateSubscription';\nexport const MODIFY_SUBSCRIPTION = 'ModifySubscription';\nexport const SUBSCRIBED = 'Subscribed';\nexport const SET_VIEWPORT_RANGE = 'setViewRange';\nexport const SORT = 'sort';\nexport const FILTER = 'filter';\nexport const SELECT = 'select';\nexport const SET_GROUP_STATE = 'setGroupState';\nexport const VIEWPORT_RANGE_CHANGED = 'ViewRangeChanged';\nexport const EXPAND_GROUP = 'ExpandGroup';\nexport const COLLAPSE_GROUP = 'CollapseGroup';\nexport const GET_FILTER_DATA = 'GetFilterData';\nexport const GET_SEARCH_DATA = 'GetSearchData';\nexport const SEARCH_DATA = 'searchData';\nexport const SNAPSHOT = 'snapshot';\n\nexport const RowData = 'rowData';\nexport const Size = 'size';\nexport const FilterData = 'filterData';\nexport const TableList = 'table-list';\nexport const ConnectionStatus = 'connection-status';\n","import Connection from './connection.mjs';\nimport Subscription from './subscription.mjs';\nimport * as Message from './messages.js';\nimport {DataTypes} from '../data/store/types.js';\nimport {NULL_RANGE} from '../data/store/rangeUtils.js';\n\nconst serverModule = process.env.SERVER_MODULE || '/server-api/dist/viewserver.js';\nconsole.log(`[ServerProxy] serverModule = ${serverModule}`)\nconst PLAIN = 'color: black; font-weight: normal';\nconst BLUE = 'color: blue; font-weight: bold';\nconst MSG_FROM_CLIENT = '<== C';\nconst MSG_TO_CLIENT = '==> C';\nconst MSG_TO_SERVER = '==> S';\nconst MSG_FROM_SERVER = '<== S';\n\nlet asyncServerModule;\n\nconst BUFFER_SIZE = 100;\n\nlet _windowId = 1;\n\nfunction windowId() {\n    return _windowId++;\n}\n\nconst BUFFER_ROWS = 100;\n\nfunction partition(array, test, pass = [], fail = []) {\n\n    for (let i = 0, len = array.length; i < len; i++) {\n        (test(array[i], i) ? pass : fail).push(array[i]);\n    }\n\n    return [pass, fail];\n}\n\nexport class ServerProxy {\n\n    constructor(postMessage) {\n        this.server = null;\n        this.connection = null;\n        this.connectionStatus = 'not-connected';\n\n        this.queuedRequests = [];\n        this.subscriptions = {};\n        this.pendingSubscriptionRequests = {};\n\n        Promise.resolve().then(() => {\n            console.log(`[ServerProxy.constructor]   ==> identity`);\n            postMessage({ data: { type: 'identify', clientId: windowId() } });\n        });\n\n        // tidy this up\n        this.postMessage = message => {\n            print(message.data, MSG_TO_CLIENT);\n            postMessage(message);\n        }\n\n    }\n\n    toString(){\n        return `ServerProxy: ${this.connectionStatus}`\n    }\n\n    handleMessageFromClient(message) {\n\n        const { type, viewport } = message;\n        const isReady = this.connectionStatus === 'ready';\n        let subscription;\n        console.log(JSON.stringify(message))\n        print(message, MSG_FROM_CLIENT);\n\n        switch (type) {\n\n            case Message.CONNECT:\n                this.connect(message);\n                break;\n\n            case Message.SUBSCRIBE:\n                this.subscribe(message)\n                break;\n\n            case Message.SET_VIEWPORT_RANGE:\n                //TODO drop buffering if we are scrolling faster than buffer can keep up\n                if (subscription = this.subscriptions[viewport]) {\n                    console.log(`%c setViewRange, we have a subscription`,'background-color: brown;color: cyan')\n                    const { bufferSize } = subscription;\n                    const { range, dataType } = message;\n                    const { size, offset } = subscription[dataType];\n                    this.sendMessageToServer({\n                        type: Message.SET_VIEWPORT_RANGE,\n                        ...message,\n                        dataType,\n                        range: { ...range, bufferSize }\n                    });\n                    const rows = subscription.putRange(message.range, dataType);\n                    if (rows.length) {\n                        console.log(`%cserverProxy emit<${dataType}> rows from cache ${rows.length ? rows[0][0]: null} - ${rows.length ? rows[rows.length-1][0]: null}`,'color:red');\n                        // never send back selectedIndices from cache, they will often be stale\n                        this.postMessage({ data: { type: dataType, viewport, [dataType]: { data: rows, size, offset, range } } });\n                    }\n                } else {\n                    console.log(`%c setViewRange, no subscription`,'background-color: brown;color: cyan')\n                    this.queuedRequests.push(message);\n                }\n\n                break;\n\n            case Message.EXPAND_GROUP:\n            case Message.COLLAPSE_GROUP:\n\n                this.sendIfReady(message, this.connectionStatus === 'ready');\n\n                if (subscription = this.subscriptions[viewport]) {\n                    const groupRow = subscription.toggleGroupNode(message.groupKey);\n                    const {IDX, DEPTH} = subscription.meta;\n                    const updates = [[groupRow[IDX], DEPTH, groupRow[DEPTH]]];\n                    this.postMessage({ data: { type: 'update', viewport, updates } });\n                }\n\n                break;\n\n            case Message.UNSUBSCRIBE:\n\n                this.sendIfReady(message, isReady);\n                delete this.subscriptions[viewport];\n\n                break;\n\n            case Message.GROUP_BY:\n                if (subscription = this.subscriptions[viewport]) {\n                    subscription.clear();\n                }\n            case Message.SET_GROUP_STATE:\n            case Message.TABLE_LIST:\n            case Message.COLUMN_LIST:\n            case Message.SORT:\n            case Message.FILTER:\n            case Message.SELECT:\n                this.sendIfReady(message, isReady);\n\n                break;\n\n            case Message.GET_FILTER_DATA:\n                //TODO expand range, so we prepopulate subscription cache\n                // console.log(`%c>>>${new Date().toISOString().slice(11,23)} handleMesageFromClient '${Message.GET_FILTER_DATA}' `, 'color:green;font-weight:bold');\n                this.sendIfReady(message, isReady);\n                if (subscription = this.subscriptions[viewport]) {\n                    subscription.reset(DataTypes.FILTER_DATA, message.range);\n                }\n                break;\n\n            case Message.MODIFY_SUBSCRIPTION:\n\n                if (subscription = this.subscriptions[viewport]) {\n\n                    this.sendIfReady(message, isReady);\n\n                    if (message.sortCriteria) {\n                        subscription.reset(DataTypes.ROW_DATA, message.range);\n                    } else if (message.range) {\n                        subscription.putRange(message.range);\n                    }\n\n                    // We should store all chnaged attributes on the subscription here. There will be times\n                    // when we need to know the attributes of the subscription in order to correctly\n                    // interpret the data received.\n                    if (message.groupBy) {\n                        subscription.groupBy = message.groupBy;\n                    }\n                }\n\n                break;\n\n            default:\n                console.warn(`%cServerProxy.handleMesageFromClient NOT HANDLED ${JSON.stringify(message)}`, 'background-color:green;color:white');\n\n        }\n\n    }\n\n    sendIfReady(message, isReady) {\n        if (isReady) {\n            this.sendMessageToServer(message);\n        } else {\n            this.queuedRequests.push(message);\n        }\n\n        return isReady;\n\n    }\n\n    // if we're going to support multiple connections, we need to save them against connectionIs\n    connect({connectionString, connectionId=0}) {\n\n        console.log(`[ServerProxy.connect] connectionString: ${connectionString} connectionId: ${connectionId}`)\n        this.connectionStatus = 'connecting';\n\n        const module = asyncServerModule ||\n            (asyncServerModule = import(/* webpackIgnore: true */ serverModule)\n                .catch(err => console.log(`failed to load server ${err}`)))\n\n        module.then(serverModule => {\n            const Server = serverModule.default;\n            const server = this.server = new Server();\n\n            Connection.connect(connectionString).then(connection => {\n                // shouldn't we read connection status from the connection object itself\n                this.connection = connection;\n\n                // call the server to group messages by viewport, then invoke each batch with the subscription for that viewport\n                connection.on('message', (evtName, msg) => {\n                    return this.receiveMessageFromServer(msg);\n                });\n\n                if (server.connectionPipeline) {\n                    const [first, ...rest] = server.connectionPipeline;\n                    rest.reduce((result, next) => result\n                        .then(next), first(connection))\n                        .then(() => this.onReady(connectionId));\n                } else {\n                    this.onReady(connectionId);\n                }\n\n            });\n\n        });\n    }\n\n    subscribe(/* client message */ message ){\n        const isReady = this.connectionStatus === 'ready';\n        const { viewport } = message;\n\n        if (message) {\n            const byTypeAndViewport = msg => msg.viewport === viewport && msg.type === Message.SET_VIEWPORT_RANGE;\n            const [rangeMessages] = partition(this.queuedRequests, byTypeAndViewport);\n\n            const { range = NULL_RANGE } = message;\n            this.pendingSubscriptionRequests[viewport] = message;\n            console.log(`%c SUBSCRIBE to ${viewport} \n                with range ${range.lo} = ${range.hi} stored\n                        range ${range.lo} = ${range.hi === 0 ? 10 : range.hi} sent to server\n                        we have ${rangeMessages.length} range messages\n\n                ${JSON.stringify(this.queuedRequests,null,2)}`,'background-color: brown;color: cyan')\n                console.log(message)\n\n            this.sendIfReady({\n                ...message,\n                range: {\n                    lo: 0,\n                    hi: range.hi || 10, // where should this come from. This will cause key errors if bigger than viewport\n                    bufferSize: BUFFER_SIZE\n                }\n            }, isReady);\n        }\n\n    }\n\n    subscribed(/* server message */ message){\n        const {viewport} = message;\n        if (this.pendingSubscriptionRequests[viewport]) {\n\n            const { size, offset } = message;\n            const request = this.pendingSubscriptionRequests[viewport];\n            // const {table, columns, sort, filter, groupBy} = request;\n            let { range, columns } = request;\n            console.log(`%c[ServerProxy.handleMessageFromServer] SUBSCRIBED create subscription range ${range.lo} - ${range.hi}`,'background-color: yellow')\n            const subscription = this.subscriptions[viewport] = new Subscription({\n                columns,\n                range,\n                size,\n                offset,\n            });\n\n            this.pendingSubscriptionRequests[viewport] = undefined;\n\n            const byViewport = vp => item => item.viewport === vp;\n            const byMessageType = msg => msg.type === Message.SET_VIEWPORT_RANGE;\n            const [messagesForThisViewport, messagesForOtherViewports] = partition(this.queuedRequests, byViewport(viewport));\n            const [rangeMessages, otherMessages] = partition(messagesForThisViewport, byMessageType);\n\n            this.queuedRequests = messagesForOtherViewports;\n            rangeMessages.forEach(msg => {\n\n                range = msg.range;\n\n                const rows = subscription.putRange(range);\n\n                if (rows.length) {\n                    // is it ever likely that we will have data immediately following subscription ?\n                    //onsole.log(`ServerProxy.subscribed ${rows.length} rows in range, following queued message handling`);\n                    this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { data: rows, size } } });\n                }\n\n            });\n\n            if (otherMessages.length) {\n                console.log(`we have ${otherMessages.length} messages still to process`);\n            }\n\n            // send a widened range request to populate buffer\n            this.sendMessageToServer({\n                type: Message.SET_VIEWPORT_RANGE,\n                dataType: DataTypes.ROW_DATA,\n                viewport,\n                range: {\n                    lo: Math.max(0, range.lo - BUFFER_ROWS),\n                    hi: range.hi + BUFFER_ROWS\n                }\n            });\n\n        }\n\n    }\n\n    onReady(connectionId){\n        this.connectionStatus = 'ready';\n        // messages which have no dependency on previous subscription\n        console.log(`%c onReady ${JSON.stringify(this.queuedRequests)}`,'background-color: brown;color: cyan')\n\n        const byReadyToSendStatus = msg => msg.viewport === undefined || msg.type === Message.SUBSCRIBE;\n        const [readyToSend, remainingMessages] = partition(this.queuedRequests, byReadyToSendStatus);\n        // TODO roll setViewRange messages into subscribe messages\n        readyToSend.forEach(msg => this.sendMessageToServer(msg));\n        this.queuedRequests = remainingMessages;\n        this.postMessage({ data: { type: 'connection-status', status: 'ready', connectionId } });\n    }\n\n    sendMessageToServer(message) {\n        const { clientId } = this.connection;\n        const { requestId = this.connection.nextRequestId() } = message;\n        const serverMessage = this.server.serialize(message, clientId, requestId);\n        if (serverMessage === null) {\n            console.warn(`[ServerProxy sendMessageToServer] ${JSON.stringify(message)} not supported by server`);\n        } else {\n            print(message, MSG_TO_SERVER);\n            this.connection.send(serverMessage);\n        }\n    }\n\n    receiveMessageFromServer(message) {\n\n        // onsole.groupCollapsed(`receiveMessageFromServer`);\n        // onsole.log(message);\n        // onsole.groupEnd();\n        print(message, MSG_FROM_SERVER);\n        const { messageHandlers = {}, customMessageTypes = {} } = this.server;\n\n        // feels wrong to pass all subscriptions to server here - should really pass just the subscription\n        // for the message. But as a payload can include messages for more than one subscription, we would\n        // first have to ask server to group the messages by viewport. Some messages are not associated\n        // with any viewport\n        const messageFromServer = this.server.deserialize(message, this.subscriptions);\n        if (messageFromServer) {\n\n            const { type } = messageFromServer;\n\n            // messages that can be handled entirely by the server - e.g. Heartbeat\n            if (messageHandlers[type]) {\n                messageHandlers[type](this.connection, message);\n            } else if (customMessageTypes[type]) {\n                // can be used to chain message requests/responses e.g. a server initiating a LOGIN \n                // request can reister a listener for the LOGIN_RESPONSE\n                this.connection.emit(type, message);\n            } else {\n                this.handleMessageFromServer(messageFromServer);\n            }\n        } else {\n            console.log(`unable to deserialize message ${JSON.stringify(message)}`);\n        }\n\n    }\n\n    handleMessageFromServer(message) {\n\n        let subscription;\n        const { type, viewport } = message;\n\n        switch (type) {\n\n            case Message.DATA:\n\n                this.processData(message.data);\n\n                break;\n\n            case Message.SNAPSHOT:\n                if (subscription = this.subscriptions[viewport]) {\n                    const { data } = message;\n                    const rows = subscription.putSnapshot(data);\n                    if (rows.length) {\n                        this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { ...data, data: rows } } });\n                    }\n                }\n                break;\n\n            case Message.SUBSCRIBED:\n                this.subscribed(message);\n                break;\n\n            case Message.FILTER_DATA:\n            case Message.SEARCH_DATA:\n\n                if (subscription = this.subscriptions[viewport]) {\n                    const { filterData } = message;\n                    // console.log(`selectedIndices from server ${JSON.stringify(filterData.selectedIndices)} \n                    //     subscription filterSelected: ${JSON.stringify(subscription.filterSelected)}\n                    //     subscription searchSelected: ${JSON.stringify(subscription.searchSelected)}\n                    //     `);\n\n                    const { rowset: data } = subscription.putData(type, filterData);\n                    const selectedIndices = filterData.selectedIndices || subscription.getData(type).selected;\n                    if (data.length || filterData.size === 0) {\n                        this.postMessage({\n                            data: {\n                                type,\n                                viewport,\n                                [type]: {\n                                    ...filterData,\n                                    selectedIndices,\n                                    data\n                                }\n                            }\n                        });\n                    }\n                }\n\n                break;\n\n            default:\n                this.postMessage({ data: message });\n\n        }\n\n    }\n\n    // data is an array of batches where each batch contains the set of \n    // data updates for one viewport\n    processData(data) {\n        data.forEach(batch => {\n\n            const { viewport, size, offset, rows, updates: rowUpdates } = batch;\n            const subscription = this.subscriptions[viewport];\n\n            if (subscription === undefined) {\n                console.warn(`ServerProxy.processData no subscription for viewport ${viewport}`);\n            } else {\n                const lastSize = subscription.size;\n\n                if (typeof size === 'number') {\n                    subscription.size = size;\n                }\n                //TODO rows should be bundled into a data structure with range, offset, selected, like filter and search results\n                let { rowset, updates } = rows\n                    ? subscription.putRows(rows, offset)\n                    : subscription.putUpdates(rowUpdates);\n\n                if (rowset && rowset.length) {\n                    const { range } = subscription.rowData;\n                    this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { data: rowset, size, range, offset } } });\n\n                } else if (updates && updates.length) {\n                    this.postMessage({ data: { type: 'update', viewport, updates, size } });\n                } else if (size !== undefined && size !== lastSize) {\n                    // size undefined if we have received an update where no updated rows are in the viewport\n                    // post a size update - only the scrollbar will reflect the change\n                    this.postMessage({ data: { type: 'size', viewport, size } });\n                }\n\n            }\n\n        });\n\n    }\n\n}\n\nfunction print(message, direction, method=null, color=BLUE){\n    console.log(`%c[ServerProxy${method === null ? '' : '.' + method}] %c${direction}  ${message.type} %c${messageToString(message)}`, PLAIN, color, PLAIN);\n}\n\nfunction messageToString(message){\n    const {requestId='', viewport=''} = message;\n    switch (message.type){\n        case Message.SET_VIEWPORT_RANGE:\n            return `${requestId} viewport ${viewport} range: ${message.range.lo} - ${message.range.hi}`;\n        case Message.SUBSCRIBE:\n        case Message.SUBSCRIBED:\n            return `${requestId} vp:${message.viewport}`;\n        case 'rowset':\n        case Message.SNAPSHOT:\n            return `${message.data.rows.length} of ${message.data.size} rows`;\n        case Message.RowData:\n            return `${message.rowData.data.length} of ${message.rowData.size} rows`;\n        default:\n            return '';\n    }\n}\n","\nimport {ServerProxy} from './serverProxy.mjs';\n\nexport default class WebWorker {\n\n    //TODO allow connectionString to be passed in constructor\n    constructor() {\n        console.log(`WebWorker.constructor`)\n        this._server = new ServerProxy(message => this._onmessage(message));\n    }\n\n    postMessage(message){\n        this._server.handleMessageFromClient(message);\n    }\n\n    _onmessage(message){\n        console.log(`message received from worker, no client is listening ${JSON.stringify(message)}`);\n    }\n\n    set onmessage(handler) {\n        this._onmessage = handler;\n    }\n\n    terminate(){\n        console.log(`terminate worker`);\n    }\n\n}\n\nconsole.log(`>>>> The webworker script has loded`);\n "],"names":["DataTypes","types.DataTypes","NULL_RANGE","partition","Message.CONNECT","Message.SUBSCRIBE","Message.SET_VIEWPORT_RANGE","Message.EXPAND_GROUP","Message.COLLAPSE_GROUP","Message.UNSUBSCRIBE","Message.GROUP_BY","Message.SET_GROUP_STATE","Message.TABLE_LIST","Message.COLUMN_LIST","Message.SORT","Message.FILTER","Message.SELECT","Message.GET_FILTER_DATA","Message.MODIFY_SUBSCRIPTION","Message.DATA","Message.SNAPSHOT","Message.SUBSCRIBED","Message.FILTER_DATA","Message.SEARCH_DATA","Message.RowData"],"mappings":"AAAA,MAAM,aAAa,GAAG,EAAE,CAAC;;AAEzB,AAAO,MAAM,YAAY,CAAC;;IAEtB,WAAW,GAAG;QACV,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QAClB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;KACtC;;IAED,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE;QACxB,IAAI,CAAC,CAAC;;QAEN,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YACvB,MAAM,SAAS,CAAC,6BAA6B,CAAC,CAAC;SAClD;;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;SACrB;;;;QAID,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;YAC1B,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SAC5C;;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;;YAErB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;SACjC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE;;YAE1C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACrC,MAAM;;YAEH,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC;SACvD;;;QAGD,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE;YACjE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;gBAClC,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC;aAC1B,MAAM;gBACH,CAAC,GAAG,aAAa,CAAC;aACrB;;YAED,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC7C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;gBACjC,OAAO,CAAC,KAAK,CAAC,+CAA+C;oBACzD,qCAAqC;oBACrC,kDAAkD;gBACtD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;aAC9B;SACJ;;QAED,OAAO,IAAI,CAAC;;KAEf;;IAED,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;QAC3B,IAAI,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;;QAE9B,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YACvB,MAAM,SAAS,CAAC,6BAA6B,CAAC,CAAC;SAClD;;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACtC,OAAO,IAAI,CAAC;SACf;;QAED,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC1B,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACrB,QAAQ,GAAG,CAAC,CAAC,CAAC;;QAEd,IAAI,IAAI,KAAK,QAAQ;aAChB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,EAAE;YAC3D,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;gBAC7B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;aAC/C;;SAEJ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YAC5B,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,GAAG,CAAC,GAAG;gBACvB,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ;qBACnB,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,EAAE;oBACrD,QAAQ,GAAG,CAAC,CAAC;oBACb,MAAM;iBACT;aACJ;;YAED,IAAI,QAAQ,GAAG,CAAC,EAAE;gBACd,OAAO,IAAI,CAAC;aACf;;YAED,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACnB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBAChB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aAC7B,MAAM;gBACH,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;aAC5B;;YAED,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;gBAC7B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;aAC/C;SACJ;;QAED,OAAO,IAAI,CAAC;;KAEf;;IAED,kBAAkB,CAAC,IAAI,EAAE;;QAErB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,OAAO,IAAI,CAAC;SACf;;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;QAErC,IAAI,UAAU,CAAC,SAAS,CAAC,EAAE;YACvB,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SACxC,MAAM,IAAI,SAAS,EAAE;;YAElB,OAAO,SAAS,CAAC,MAAM,EAAE;gBACrB,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;aAC9D;SACJ;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;QAE1B,OAAO,IAAI,CAAC;;KAEf;;IAED,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE;;QAEhB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;SACrB;;;QAGD,IAAI,IAAI,KAAK,OAAO,EAAE;YAClB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK;iBAClB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;gBAC9D,MAAM,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAI,GAAG,YAAY,KAAK,EAAE;oBACtB,MAAM,GAAG,CAAC;iBACb,MAAM;;oBAEH,MAAM,IAAI,KAAK,CAAC,wCAAwC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;iBACzE;aACJ;SACJ;;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;QAEnC,IAAI,WAAW,CAAC,OAAO,CAAC,EAAE;YACtB,OAAO,KAAK,CAAC;SAChB;;QAED,IAAI,UAAU,CAAC,OAAO,CAAC,EAAE;YACrB,QAAQ,IAAI,CAAC,MAAM;;YAEnB,KAAK,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnB,MAAM;YACV,KAAK,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClC,MAAM;YACV,KAAK,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,MAAM;;YAEV;gBACI,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;aACrC;SACJ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC/B,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;SAC3E;;QAED,OAAO,IAAI,CAAC;;KAEf;;IAED,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE;;QAEjB,MAAM,OAAO,GAAG,CAAC,OAAO,EAAE,OAAO,KAAK;YAClC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YACtC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;SAC9B,CAAC;;QAEF,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;;KAE1B;;IAED,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE;QACf,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;KAC3C;;CAEJ;;AAED,SAAS,UAAU,CAAC,GAAG,EAAE;IACrB,OAAO,OAAO,GAAG,KAAK,UAAU,CAAC;CACpC;;AAED,SAAS,QAAQ,CAAC,GAAG,EAAE;IACnB,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,CAAC;CAClD;;AAED,SAAS,WAAW,CAAC,GAAG,EAAE;IACtB,OAAO,GAAG,KAAK,KAAK,CAAC,CAAC;CACzB;;AC9MD,MAAM,eAAe,GAAG,eAAqB,CAAC;;AAE9C,IAAI,UAAU,CAAC;AACf,IAAI,WAAW,GAAG,CAAC,CAAC;;AAEpB,AAAe,MAAM,UAAU,SAAS,YAAY,CAAC;;IAEjD,OAAO,OAAO,CAAC,gBAAgB,EAAE,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAE;;QAEzD,OAAO,UAAU,KAAK,UAAU,GAAG,IAAI,OAAO;YAC1C,UAAU,OAAO,EAAE,MAAM,EAAE;gBACvB,MAAM,2BAA2B,eAAe,CAAC;qBAC5C,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;qBAChD,IAAI,CAAC,SAAS,IAAI,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;qBAC5C,IAAI,CAAC,OAAO,CAAC,CAAC;aACtB;SACJ,CAAC,CAAC;KACN;;IAED,WAAW,CAAC,SAAS,EAAE;;QAEnB,KAAK,EAAE,CAAC;;QAER,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;QAE3B,SAAS,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAO,EAAE,OAAO,KAAK;YAC1C,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBACxB,OAAO,CAAC,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;aAC5D,MAAM;gBACH,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;aAChC;;SAEJ,CAAC,CAAC;KACN;;IAED,cAAc,CAAC,OAAO,CAAC;QACnB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;KACjC;;;IAGD,IAAI,CAAC,OAAO,CAAC;QACT,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAChC;;;IAGD,aAAa,GAAG;QACZ,WAAW,IAAI,CAAC,CAAC;QACjB,OAAO,KAAK,GAAG,WAAW,CAAC;KAC9B;;CAEJ;;AC5CM,SAAS,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC;IAC9B,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;QAC1B,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,OAAO,CAAC,CAAC;SACZ;KACJ;IACD,OAAO,CAAC,CAAC,CAAC;CACb;;AAED,AAAO,SAAS,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC;IACnC,MAAM,MAAM,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;IAC3B,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;IACpB,OAAO,MAAM,CAAC;CACjB;;AC+CD;AACA,AAAO,SAAS,QAAQ,CAAC,OAAO,CAAC;IAC7B,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;IAC3B,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG,SAAS,EAAE,CAAC;IACrC,OAAO;QACH,GAAG,EAAE,IAAI,EAAE;QACX,KAAK,EAAE,IAAI,EAAE;QACb,KAAK,EAAE,IAAI,EAAE;QACb,GAAG,EAAE,IAAI,EAAE;QACX,UAAU,EAAE,IAAI,EAAE;QAClB,WAAW,EAAE,IAAI,EAAE;QACnB,YAAY,EAAE,IAAI,EAAE;QACpB,eAAe,EAAE,IAAI,EAAE;QACvB,KAAK,EAAE,OAAO,CAAC,MAAM,GAAG,SAAS;KACpC;CACJ;;ACpFM,MAAM,SAAS,GAAG;IACrB,QAAQ,EAAE,SAAS;IACnB,WAAW,EAAE,YAAY;IACzB,WAAW,EAAE,YAAY;CAC5B,CAAC;;ACJa,kBAAQ,CAAC,CAAC,EAAE,CAAC,EAAE;EAC5B,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;CAClD;;ACAc,iBAAQ,CAAC,OAAO,EAAE;EAC/B,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;EACjE,OAAO;IACL,IAAI,EAAE,SAAS,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE;MAC3B,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC;MACvB,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC;MAC9B,OAAO,EAAE,GAAG,EAAE,EAAE;QACd,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACxB,IAAI,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;aACpC,EAAE,GAAG,GAAG,CAAC;OACf;MACD,OAAO,EAAE,CAAC;KACX;IACD,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE;MAC5B,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC;MACvB,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC;MAC9B,OAAO,EAAE,GAAG,EAAE,EAAE;QACd,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACxB,IAAI,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,CAAC;aAChC,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;OACnB;MACD,OAAO,EAAE,CAAC;KACX;GACF,CAAC;CACH;;AAED,SAAS,mBAAmB,CAAC,CAAC,EAAE;EAC9B,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE;IACpB,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;GAC3B,CAAC;CACH;;AC7BD,IAAI,eAAe,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;;ACEnC,MAAM,mBAAmB,GAAG;IAC/B,CAAC,IAAI,EAAE,OAAO,CAAC;IACf,CAAC,IAAI,EAAE,OAAO,CAAC;IACf,CAAC,IAAI,EAAE,YAAY,CAAC;CACvB,CAAC;;AAEF,AAAO,MAAM,gBAAgB,GAAG,QAAQ,CAAC,mBAAmB,CAAC;;ACXtD,MAAM,UAAU,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AACxC,AAgCA;AACA,AAAO,SAAS,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5C,OAAO;QACH,EAAE,EAAE,CAAC;QACL,EAAE,EAAE,EAAE,CAAC,EAAE;QACT,UAAU;KACb,CAAC;CACL;;AAED,AAAO,SAAS,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9C,OAAO;QACH,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,UAAU,CAAC;QAChC,EAAE,EAAE,EAAE,GAAG,UAAU;KACtB,CAAC;CACL;;AC/CD,iBAAiB;;ACAjB,kFAAkF;;ACAlF;;;;;;;;;;EAUE;;AC+DK,MAAM,UAAU,GAAG;EACxB,YAAY;EACZ,UAAU;EACX;;AAED,AAAO,MAAMA,WAAS,GAAGC,SAAe,CAAC;;AC1EzC,MAAM,aAACC,YAAU,CAAC,GAAG,UAAU,CAAC;;;AAGhC,AAAO,MAAM,SAAS,CAAC;IACnB,WAAW,CAAC,KAAK,GAAGA,YAAU,EAAE,IAAI,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,IAAI,GAAG,EAAE,EAAE;QAC7D,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;KAC5B;IACD,IAAI,IAAI,EAAE;QACN,OAAO,IAAI,CAAC,KAAK,CAAC;KACrB;IACD,IAAI,IAAI,CAAC,GAAG,EAAE;QACV,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YACzB,OAAO,CAAC,KAAK,CAAC,CAAC,6BAA6B,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;SACxD,MAAM;YACH,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,EAAE;gBACxB,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;aAC1B;YACD,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;SACpB;KACJ;IACD,KAAK,GAAG;QACJ,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAClD;CACJ;;AAED,AAAe,MAAM,YAAY,CAAC;;;IAG9B,WAAW,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,EAAE;QAClD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC9B,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QAChD,IAAI,CAAC,WAAW,GAAG,IAAI,SAAS,EAAE,CAAC;KACtC;;IAED,IAAI,MAAM,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;IAC1C,IAAI,IAAI,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;IACtC,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE;;IAExC,KAAK,CAAC,QAAQ,EAAE,KAAK,GAAGA,YAAU,EAAE;QAChC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC1C,UAAU,CAAC,IAAI,GAAG,EAAE,CAAC;QACrB,UAAU,CAAC,IAAI,GAAG,CAAC,CAAC;QACpB,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC;KAC5B;;IAED,WAAW,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,eAAe,EAAE,EAAE;QACxD,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QACtD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC;QAC1D,OAAO,CAAC,GAAG,CAAC,CAAC,kCAAkC,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAChI,OAAO,OAAO,CAAC;KAClB;;IAED,KAAK,GAAG;QACJ,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;KACtB;;;IAGD,QAAQ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,QAAQ,GAAGF,WAAS,CAAC,QAAQ,EAAE;QAChD,OAAO,CAAC,GAAG,CAAC,CAAC,8BAA8B,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC3D,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC1C,MAAM,CAAC,GAAG,EAAE,WAAW,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QAC9D,UAAU,CAAC,KAAK,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAC9B,UAAU,CAAC,IAAI,GAAG,GAAG,CAAC;QACtB,OAAO,WAAW,CAAC;KACtB;;;;IAID,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,CAAC,EAAE;;QAEtB,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC;QAC9B,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;;QAExD,IAAI,MAAM,KAAK,UAAU,CAAC,MAAM,EAAE;YAC9B,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC;SAC9B;;QAED,OAAO,CAAC,GAAG,CAAC,CAAC,2BAA2B,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAClG,OAAO,OAAO,CAAC;KAClB;;IAED,OAAO,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,eAAe,GAAG,IAAI,EAAE,EAAE;;;QAG5D,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;;;QAG1C,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC;QACvB,IAAI,eAAe,KAAK,IAAI,EAAE;YAC1B,UAAU,CAAC,QAAQ,GAAG,eAAe,CAAC;SACzC;;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;;;;;;;;QAQhD,OAAO,OAAO,CAAC;KAClB;;IAED,IAAI,OAAO,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;IACpC,IAAI,UAAU,GAAG,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,EAAE;IAC7C,IAAI,UAAU,GAAG,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;IAClD,IAAI,UAAU,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE;IACpD,IAAI,cAAc,GAAG,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;;IAE1D,OAAO,CAAC,QAAQ,EAAE;QACd,OAAO,QAAQ,KAAKA,WAAS,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK;YAC/C,QAAQ,KAAKA,WAAS,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;gBACjD,IAAI,CAAC;KAChB;;IAED,SAAS,CAAC,UAAU,EAAE,EAAE,EAAE,EAAE,EAAE;QAC1B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC;QAC3C,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;;QAExB,MAAM,GAAG,GAAG,EAAE,GAAG,MAAM,CAAC;QACxB,MAAM,IAAI,GAAG,EAAE,GAAG,MAAM,CAAC;QACzB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC;QAC1D,MAAM,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;QAC1C,MAAM,OAAO,GAAG,KAAK,CAAC,EAAE,GAAG,MAAM,CAAC;QAClC,MAAM,QAAQ,GAAG,KAAK,CAAC,EAAE,GAAG,MAAM,CAAC;QACnC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,GAAG,GAAG,EAAE,CAAC;QACf,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,IAAI,WAAW,CAAC;QAChB,IAAI,YAAY,CAAC;QACjB,IAAI,GAAG,CAAC;QACR,IAAI,WAAW,GAAG,CAAC,CAAC,CAAC;QACrB,IAAI,CAAC,GAAG,CAAC,CAAC;;QAEV,IAAI,GAAG,IAAI,QAAQ,IAAI,IAAI,IAAI,OAAO,EAAE;YACpC,WAAW,GAAG,GAAG,CAAC;YAClB,YAAY,GAAG,IAAI,CAAC;SACvB,MAAM,IAAI,IAAI,GAAG,QAAQ,EAAE;YACxB,WAAW,GAAG,QAAQ,CAAC;YACvB,YAAY,GAAG,IAAI,CAAC;SACvB,MAAM;YACH,WAAW,GAAG,GAAG,CAAC;YAClB,YAAY,GAAG,OAAO,CAAC;SAC1B;;QAED,OAAO,GAAG,KAAK,SAAS,IAAI,WAAW,GAAG,GAAG,EAAE;YAC3C,WAAW,IAAI,CAAC,CAAC;YACjB,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;SAC3B;;QAED,KAAK,CAAC,GAAG,WAAW,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAChC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;;;;;YAKd,IAAI,GAAG,EAAE;gBACL,IAAI,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEnB,IAAI,GAAG,IAAI,UAAU,EAAE;oBACnB,MAAM;iBACT,MAAM,IAAI,GAAG,IAAI,SAAS,IAAI,GAAG,GAAG,UAAU,EAAE;oBAC7C,GAAG,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC;;oBAE3B,IAAI,GAAG,IAAI,WAAW,IAAI,GAAG,GAAG,YAAY,EAAE;wBAC1C,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;qBACzB;iBACJ;aACJ;SACJ;;QAED,OAAO,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;;KAE7B;;IAED,QAAQ,CAAC,UAAU,EAAE,IAAI,EAAE,SAAS,GAAG,CAAC,EAAE;QACtC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC;QAC3C,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QACxB,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,CAAC;QACzB,MAAM,GAAG,GAAG,EAAE,GAAG,MAAM,CAAC;QACxB,MAAM,IAAI,GAAG,EAAE,GAAG,MAAM,CAAC;QACzB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC;QAC1D,MAAM,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;QAC1C,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,MAAM,OAAO,GAAG,EAAE,CAAC;;QAEnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,IAAI,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,IAAI,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;;YAEnB,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,GAAG,MAAM,EAAE;;gBAE1B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAClB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACjB,IAAI,SAAS,KAAK,MAAM,EAAE;oBACtB,OAAO,CAAC,IAAI,CAAC,CAAC,mEAAmE,CAAC,CAAC,CAAC;iBACvF;aACJ,MAAM,IAAI,GAAG,IAAI,SAAS,IAAI,GAAG,GAAG,UAAU,EAAE;gBAC7C,IAAI,MAAM,GAAG,GAAG,GAAG,SAAS,CAAC;gBAC7B,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;gBACnB,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE;oBAC1B,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACpB;aACJ;SACJ;;QAED,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC;;KAE9B;;IAED,UAAU,CAAC,OAAO,EAAE;;QAEhB,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;QACpC,MAAM,GAAG,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,MAAM,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QAC9B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC;QAC/D,MAAM,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;QAC1C,MAAM,cAAc,GAAG,EAAE,CAAC;;;;QAI1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAI,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;;YAEpB,IAAI,GAAG,IAAI,SAAS,IAAI,GAAG,GAAG,UAAU,EAAE;gBACtC,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC,CAAC;;gBAE3C,IAAI,GAAG,KAAK,SAAS,EAAE;oBACnB,OAAO,CAAC,GAAG,CAAC,CAAC,kFAAkF,EAAE,GAAG,CAAC;+BAC1F,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC;gCACnC,EAAE,SAAS,CAAC,CAAC,EAAE,UAAU,CAAC;wBAClC,CAAC,EAAE,CAAC,0BAA0B,CAAC,CAAC,CAAC;iBACxC,MAAM;;oBAEH,GAAG,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;;;oBAGlB,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,EAAE;;wBAE1C,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;qBACpC;;oBAED,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE;wBAC1B,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;qBAC/B;oBACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC;iBAC1C;;aAEJ;SACJ;;;QAGD,OAAO,EAAE,OAAO,EAAE,cAAc,EAAE,CAAC;;KAEtC;;;;;IAKD,eAAe,CAAC,QAAQ,EAAE;QACtB,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC;QACjC,MAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC;QACnE,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACtC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;KAC5E;CACJ;;ACzRM,MAAM,OAAO,GAAG,SAAS,CAAC;AACjC,AAAO,MAAM,SAAS,GAAG,iBAAiB,CAAC;AAC3C,AAAO,MAAM,WAAW,GAAG,YAAY,CAAC;AACxC,AAAO,MAAM,IAAI,GAAG,MAAM,CAAC;AAC3B,AAAO,MAAM,WAAW,GAAG,YAAY,CAAC;AACxC,AAAO,MAAM,QAAQ,GAAG,SAAS,CAAC;AAClC,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC;AACtC,AAAO,MAAM,WAAW,GAAG,uBAAuB,CAAC;AACnD,AAAO,MAAM,mBAAmB,GAAG,oBAAoB,CAAC;AACxD,AAAO,MAAM,UAAU,GAAG,YAAY,CAAC;AACvC,AAAO,MAAM,kBAAkB,GAAG,cAAc,CAAC;AACjD,AAAO,MAAM,IAAI,GAAG,MAAM,CAAC;AAC3B,AAAO,MAAM,MAAM,GAAG,QAAQ,CAAC;AAC/B,AAAO,MAAM,MAAM,GAAG,QAAQ,CAAC;AAC/B,AAAO,MAAM,eAAe,GAAG,eAAe,CAAC;AAC/C,AACO,MAAM,YAAY,GAAG,aAAa,CAAC;AAC1C,AAAO,MAAM,cAAc,GAAG,eAAe,CAAC;AAC9C,AAAO,MAAM,eAAe,GAAG,eAAe,CAAC;AAC/C,AACO,MAAM,WAAW,GAAG,YAAY,CAAC;AACxC,AAAO,MAAM,QAAQ,GAAG,UAAU,CAAC;;AAEnC,AAAO,MAAM,OAAO,GAAG,SAAS,CAAC;;ACjBjC,MAAM,YAAY,GAAG,gBAAyB,AAAoC,CAAC;AACnF,OAAO,CAAC,GAAG,CAAC,CAAC,6BAA6B,EAAE,YAAY,CAAC,CAAC,EAAC;AAC3D,MAAM,KAAK,GAAG,mCAAmC,CAAC;AAClD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,eAAe,GAAG,OAAO,CAAC;AAChC,MAAM,aAAa,GAAG,OAAO,CAAC;AAC9B,MAAM,aAAa,GAAG,OAAO,CAAC;AAC9B,MAAM,eAAe,GAAG,OAAO,CAAC;;AAEhC,IAAI,iBAAiB,CAAC;;AAEtB,MAAM,WAAW,GAAG,GAAG,CAAC;;AAExB,IAAI,SAAS,GAAG,CAAC,CAAC;;AAElB,SAAS,QAAQ,GAAG;IAChB,OAAO,SAAS,EAAE,CAAC;CACtB;;AAED,MAAM,WAAW,GAAG,GAAG,CAAC;;AAExB,SAASG,WAAS,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;;IAElD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;QAC9C,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;KACpD;;IAED,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;CACvB;;AAED,AAAO,MAAM,WAAW,CAAC;;IAErB,WAAW,CAAC,WAAW,EAAE;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;;QAExC,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,2BAA2B,GAAG,EAAE,CAAC;;QAEtC,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM;YACzB,OAAO,CAAC,GAAG,CAAC,CAAC,wCAAwC,CAAC,CAAC,CAAC;YACxD,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;SACrE,CAAC,CAAC;;;QAGH,IAAI,CAAC,WAAW,GAAG,OAAO,IAAI;YAC1B,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;YACnC,WAAW,CAAC,OAAO,CAAC,CAAC;UACxB;;KAEJ;;IAED,QAAQ,EAAE;QACN,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;KACjD;;IAED,uBAAuB,CAAC,OAAO,EAAE;;QAE7B,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;QACnC,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,KAAK,OAAO,CAAC;QAClD,IAAI,YAAY,CAAC;QACjB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAC;QACpC,KAAK,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;;QAEhC,QAAQ,IAAI;;YAER,KAAKC,OAAe;gBAChB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBACtB,MAAM;;YAEV,KAAKC,SAAiB;gBAClB,IAAI,CAAC,SAAS,CAAC,OAAO,EAAC;gBACvB,MAAM;;YAEV,KAAKC,kBAA0B;;gBAE3B,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,OAAO,CAAC,GAAG,CAAC,CAAC,uCAAuC,CAAC,CAAC,qCAAqC,EAAC;oBAC5F,MAAM,EAAE,UAAU,EAAE,GAAG,YAAY,CAAC;oBACpC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;oBACpC,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;oBAChD,IAAI,CAAC,mBAAmB,CAAC;wBACrB,IAAI,EAAEA,kBAA0B;wBAChC,GAAG,OAAO;wBACV,QAAQ;wBACR,KAAK,EAAE,EAAE,GAAG,KAAK,EAAE,UAAU,EAAE;qBAClC,CAAC,CAAC;oBACH,MAAM,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;oBAC5D,IAAI,IAAI,CAAC,MAAM,EAAE;wBACb,OAAO,CAAC,GAAG,CAAC,CAAC,mBAAmB,EAAE,QAAQ,CAAC,kBAAkB,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;;wBAE7J,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,QAAQ,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC;qBAC7G;iBACJ,MAAM;oBACH,OAAO,CAAC,GAAG,CAAC,CAAC,gCAAgC,CAAC,CAAC,qCAAqC,EAAC;oBACrF,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACrC;;gBAED,MAAM;;YAEV,KAAKC,YAAoB,CAAC;YAC1B,KAAKC,cAAsB;;gBAEvB,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,gBAAgB,KAAK,OAAO,CAAC,CAAC;;gBAE7D,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,MAAM,QAAQ,GAAG,YAAY,CAAC,eAAe,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;oBAChE,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC;oBACvC,MAAM,OAAO,GAAG,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC1D,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;iBACrE;;gBAED,MAAM;;YAEV,KAAKC,WAAmB;;gBAEpB,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACnC,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;gBAEpC,MAAM;;YAEV,KAAKC,QAAgB;gBACjB,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,YAAY,CAAC,KAAK,EAAE,CAAC;iBACxB;YACL,KAAKC,eAAuB,CAAC;YAC7B,KAAKC,UAAkB,CAAC;YACxB,KAAKC,WAAmB,CAAC;YACzB,KAAKC,IAAY,CAAC;YAClB,KAAKC,MAAc,CAAC;YACpB,KAAKC,MAAc;gBACf,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;;gBAEnC,MAAM;;YAEV,KAAKC,eAAuB;;;gBAGxB,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACnC,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;iBAC5D;gBACD,MAAM;;YAEV,KAAKC,mBAA2B;;gBAE5B,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;;oBAE7C,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;;oBAEnC,IAAI,OAAO,CAAC,YAAY,EAAE;wBACtB,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;qBACzD,MAAM,IAAI,OAAO,CAAC,KAAK,EAAE;wBACtB,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;qBACxC;;;;;oBAKD,IAAI,OAAO,CAAC,OAAO,EAAE;wBACjB,YAAY,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;qBAC1C;iBACJ;;gBAED,MAAM;;YAEV;gBACI,OAAO,CAAC,IAAI,CAAC,CAAC,iDAAiD,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,oCAAoC,CAAC,CAAC;;SAEzI;;KAEJ;;IAED,WAAW,CAAC,OAAO,EAAE,OAAO,EAAE;QAC1B,IAAI,OAAO,EAAE;YACT,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;SACrC,MAAM;YACH,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACrC;;QAED,OAAO,OAAO,CAAC;;KAElB;;;IAGD,OAAO,CAAC,CAAC,gBAAgB,EAAE,YAAY,CAAC,CAAC,CAAC,EAAE;;QAExC,OAAO,CAAC,GAAG,CAAC,CAAC,wCAAwC,EAAE,gBAAgB,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC,EAAC;QACxG,IAAI,CAAC,gBAAgB,GAAG,YAAY,CAAC;;QAErC,MAAM,MAAM,GAAG,iBAAiB;aAC3B,iBAAiB,GAAG,MAAM,2BAA2B,YAAY,CAAC;iBAC9D,KAAK,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,sBAAsB,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,EAAC;;QAEnE,MAAM,CAAC,IAAI,CAAC,YAAY,IAAI;YACxB,MAAM,MAAM,GAAG,YAAY,CAAC,OAAO,CAAC;YACpC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,EAAE,CAAC;;YAE1C,UAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI;;gBAEpD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;;;gBAG7B,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAO,EAAE,GAAG,KAAK;oBACvC,OAAO,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAC;iBAC7C,CAAC,CAAC;;gBAEH,IAAI,MAAM,CAAC,kBAAkB,EAAE;oBAC3B,MAAM,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,GAAG,MAAM,CAAC,kBAAkB,CAAC;oBACnD,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,IAAI,KAAK,MAAM;yBAC/B,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;yBAC9B,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;iBAC/C,MAAM;oBACH,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;iBAC9B;;aAEJ,CAAC,CAAC;;SAEN,CAAC,CAAC;KACN;;IAED,SAAS,sBAAsB,OAAO,EAAE;QACpC,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,KAAK,OAAO,CAAC;QAClD,MAAM,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;;QAE7B,IAAI,OAAO,EAAE;YACT,MAAM,iBAAiB,GAAG,GAAG,IAAI,GAAG,CAAC,QAAQ,KAAK,QAAQ,IAAI,GAAG,CAAC,IAAI,KAAKZ,kBAA0B,CAAC;YACtG,MAAM,CAAC,aAAa,CAAC,GAAGH,WAAS,CAAC,IAAI,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;;YAE1E,MAAM,EAAE,KAAK,GAAG,UAAU,EAAE,GAAG,OAAO,CAAC;YACvC,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC;YACrD,OAAO,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,QAAQ,CAAC;2BACzB,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAC;8BACtB,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC;gCAC7C,EAAE,aAAa,CAAC,MAAM,CAAC;;gBAEvC,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,qCAAqC,EAAC;gBACrF,OAAO,CAAC,GAAG,CAAC,OAAO,EAAC;;YAExB,IAAI,CAAC,WAAW,CAAC;gBACb,GAAG,OAAO;gBACV,KAAK,EAAE;oBACH,EAAE,EAAE,CAAC;oBACL,EAAE,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE;oBAClB,UAAU,EAAE,WAAW;iBAC1B;aACJ,EAAE,OAAO,CAAC,CAAC;SACf;;KAEJ;;IAED,UAAU,sBAAsB,OAAO,CAAC;QACpC,MAAM,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC;QAC3B,IAAI,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,EAAE;;YAE5C,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;YACjC,MAAM,OAAO,GAAG,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,CAAC;;YAE3D,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;YACjC,OAAO,CAAC,GAAG,CAAC,CAAC,6EAA6E,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,0BAA0B,EAAC;YAChJ,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,IAAI,YAAY,CAAC;gBACjE,OAAO;gBACP,KAAK;gBACL,IAAI;gBACJ,MAAM;aACT,CAAC,CAAC;;YAEH,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;;YAEvD,MAAM,UAAU,GAAG,EAAE,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,EAAE,CAAC;YACtD,MAAM,aAAa,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,KAAKG,kBAA0B,CAAC;YACrE,MAAM,CAAC,uBAAuB,EAAE,yBAAyB,CAAC,GAAGH,WAAS,CAAC,IAAI,CAAC,cAAc,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClH,MAAM,CAAC,aAAa,EAAE,aAAa,CAAC,GAAGA,WAAS,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;;YAEzF,IAAI,CAAC,cAAc,GAAG,yBAAyB,CAAC;YAChD,aAAa,CAAC,OAAO,CAAC,GAAG,IAAI;;gBAEzB,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;;gBAElB,MAAM,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;;gBAE1C,IAAI,IAAI,CAAC,MAAM,EAAE;;;oBAGb,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC;iBACrG;;aAEJ,CAAC,CAAC;;YAEH,IAAI,aAAa,CAAC,MAAM,EAAE;gBACtB,OAAO,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,0BAA0B,CAAC,CAAC,CAAC;aAC5E;;;YAGD,IAAI,CAAC,mBAAmB,CAAC;gBACrB,IAAI,EAAEG,kBAA0B;gBAChC,QAAQ,EAAE,SAAS,CAAC,QAAQ;gBAC5B,QAAQ;gBACR,KAAK,EAAE;oBACH,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,GAAG,WAAW,CAAC;oBACvC,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,WAAW;iBAC7B;aACJ,CAAC,CAAC;;SAEN;;KAEJ;;IAED,OAAO,CAAC,YAAY,CAAC;QACjB,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;;QAEhC,OAAO,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,qCAAqC,EAAC;;QAEtG,MAAM,mBAAmB,GAAG,GAAG,IAAI,GAAG,CAAC,QAAQ,KAAK,SAAS,IAAI,GAAG,CAAC,IAAI,KAAKD,SAAiB,CAAC;QAChG,MAAM,CAAC,WAAW,EAAE,iBAAiB,CAAC,GAAGF,WAAS,CAAC,IAAI,CAAC,cAAc,EAAE,mBAAmB,CAAC,CAAC;;QAE7F,WAAW,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC;QAC1D,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAC;QACxC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,mBAAmB,EAAE,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,EAAE,CAAC,CAAC;KAC5F;;IAED,mBAAmB,CAAC,OAAO,EAAE;QACzB,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;QACrC,MAAM,EAAE,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,EAAE,GAAG,OAAO,CAAC;QAChE,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;QAC1E,IAAI,aAAa,KAAK,IAAI,EAAE;YACxB,OAAO,CAAC,IAAI,CAAC,CAAC,kCAAkC,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;SACxG,MAAM;YACH,KAAK,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YAC9B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SACvC;KACJ;;IAED,wBAAwB,CAAC,OAAO,EAAE;;;;;QAK9B,KAAK,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;QAChC,MAAM,EAAE,eAAe,GAAG,EAAE,EAAE,kBAAkB,GAAG,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;;;;;;QAMtE,MAAM,iBAAiB,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAC/E,IAAI,iBAAiB,EAAE;;YAEnB,MAAM,EAAE,IAAI,EAAE,GAAG,iBAAiB,CAAC;;;YAGnC,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;gBACvB,eAAe,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;aACnD,MAAM,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;;;gBAGjC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aACvC,MAAM;gBACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;aACnD;SACJ,MAAM;YACH,OAAO,CAAC,GAAG,CAAC,CAAC,8BAA8B,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3E;;KAEJ;;IAED,uBAAuB,CAAC,OAAO,EAAE;;QAE7B,IAAI,YAAY,CAAC;QACjB,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;;QAEnC,QAAQ,IAAI;;YAER,KAAKgB,IAAY;;gBAEb,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;gBAE/B,MAAM;;YAEV,KAAKC,QAAgB;gBACjB,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;oBACzB,MAAM,IAAI,GAAG,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;oBAC5C,IAAI,IAAI,CAAC,MAAM,EAAE;wBACb,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC;qBACxG;iBACJ;gBACD,MAAM;;YAEV,KAAKC,UAAkB;gBACnB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBACzB,MAAM;;YAEV,KAAKC,WAAmB,CAAC;YACzB,KAAKC,WAAmB;;gBAEpB,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;oBAC7C,MAAM,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;;;;;;oBAM/B,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,YAAY,CAAC,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;oBAChE,MAAM,eAAe,GAAG,UAAU,CAAC,eAAe,IAAI,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC;oBAC1F,IAAI,IAAI,CAAC,MAAM,IAAI,UAAU,CAAC,IAAI,KAAK,CAAC,EAAE;wBACtC,IAAI,CAAC,WAAW,CAAC;4BACb,IAAI,EAAE;gCACF,IAAI;gCACJ,QAAQ;gCACR,CAAC,IAAI,GAAG;oCACJ,GAAG,UAAU;oCACb,eAAe;oCACf,IAAI;iCACP;6BACJ;yBACJ,CAAC,CAAC;qBACN;iBACJ;;gBAED,MAAM;;YAEV;gBACI,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,CAAC;;SAE3C;;KAEJ;;;;IAID,WAAW,CAAC,IAAI,EAAE;QACd,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI;;YAElB,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,KAAK,CAAC;YACpE,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;YAElD,IAAI,YAAY,KAAK,SAAS,EAAE;gBAC5B,OAAO,CAAC,IAAI,CAAC,CAAC,qDAAqD,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;aACpF,MAAM;gBACH,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC;;gBAEnC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;oBAC1B,YAAY,CAAC,IAAI,GAAG,IAAI,CAAC;iBAC5B;;gBAED,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI;sBACxB,YAAY,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC;sBAClC,YAAY,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;;gBAE1C,IAAI,MAAM,IAAI,MAAM,CAAC,MAAM,EAAE;oBACzB,MAAM,EAAE,KAAK,EAAE,GAAG,YAAY,CAAC,OAAO,CAAC;oBACvC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;;iBAEtH,MAAM,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,EAAE;oBAClC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;iBAC3E,MAAM,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,QAAQ,EAAE;;;oBAGhD,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;iBAChE;;aAEJ;;SAEJ,CAAC,CAAC;;KAEN;;CAEJ;;AAED,SAAS,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC;IACvD,OAAO,CAAC,GAAG,CAAC,CAAC,cAAc,EAAE,MAAM,KAAK,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE,EAAE,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;CAC3J;;AAED,SAAS,eAAe,CAAC,OAAO,CAAC;IAC7B,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,QAAQ,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC;IAC5C,QAAQ,OAAO,CAAC,IAAI;QAChB,KAAKjB,kBAA0B;YAC3B,OAAO,CAAC,EAAE,SAAS,CAAC,UAAU,EAAE,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;QAChG,KAAKD,SAAiB,CAAC;QACvB,KAAKgB,UAAkB;YACnB,OAAO,CAAC,EAAE,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;QACjD,KAAK,QAAQ,CAAC;QACd,KAAKD,QAAgB;YACjB,OAAO,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACtE,KAAKI,OAAe;YAChB,OAAO,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5E;YACI,OAAO,EAAE,CAAC;KACjB;CACJ;;AC/ec,MAAM,SAAS,CAAC;;;IAG3B,WAAW,GAAG;QACV,OAAO,CAAC,GAAG,CAAC,CAAC,qBAAqB,CAAC,EAAC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,WAAW,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;KACvE;;IAED,WAAW,CAAC,OAAO,CAAC;QAChB,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;KACjD;;IAED,UAAU,CAAC,OAAO,CAAC;QACf,OAAO,CAAC,GAAG,CAAC,CAAC,qDAAqD,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KAClG;;IAED,IAAI,SAAS,CAAC,OAAO,EAAE;QACnB,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;KAC7B;;IAED,SAAS,EAAE;QACP,OAAO,CAAC,GAAG,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;KACnC;;CAEJ;;AAED,OAAO,CAAC,GAAG,CAAC,CAAC,mCAAmC,CAAC,CAAC,CAAC;;;;"}