{"version":3,"file":"web-worker.js","sources":["../src/@heswell/server-api/transports/eventEmitter.mjs","../src/@heswell/server-api/connection.mjs","../src/@heswell/server-api/utils/arrayUtils.mjs","../node_modules/d3-array/src/ascending.js","../node_modules/d3-array/src/bisector.js","../node_modules/d3-array/src/bisect.js","../src/@heswell/data/store/filter.js","../src/@heswell/data/store/columnUtils.js","../src/@heswell/data/store/types.js","../src/@heswell/data/store/rangeUtils.js","../src/@heswell/data/store/table.js","../src/@heswell/data/store/rowset/rowSet.js","../src/@heswell/data/store/rowset/index.js","../src/@heswell/data/store/updateQueue.js","../src/@heswell/data/index.js","../src/@heswell/server-api/subscription.mjs","../src/@heswell/server-api/messages.js","../src/@heswell/server-api/serverProxy.mjs","../src/@heswell/server-api/web-worker.js"],"sourcesContent":["const MAX_LISTENERS = 10;\n\nexport class EventEmitter {\n\n    constructor() {\n        this._events = {};\n        this._maxListeners = MAX_LISTENERS;\n    }\n\n    addListener(type, listener) {\n        let m;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (this._events.newListener) {\n            this.emit('newListener', type, listener);\n        }\n\n        if (!this._events[type]) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        } else if (Array.isArray(this._events[type])) {\n            // If we've already got an array, just append.\n            this._events[type].push(listener);\n        } else {\n            // Adding the second element, need to change to array.\n            this._events[type] = [this._events[type], listener];\n        }\n\n        // Check for listener leak\n        if (Array.isArray(this._events[type]) && !this._events[type].warned) {\n            if (!isUndefined(this._maxListeners)) {\n                m = this._maxListeners;\n            } else {\n                m = MAX_LISTENERS;\n            }\n\n            if (m && m > 0 && this._events[type].length > m) {\n                this._events[type].warned = true;\n                console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                this._events[type].length);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeListener(type, listener) {\n        let list, position, length, i;\n\n        if (!isFunction(listener)) {\n            throw TypeError('listener must be a function');\n        }\n\n        if (!this._events || !this._events[type]) {\n            return this;\n        }\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n\n        } else if (Array.isArray(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0) {\n                return this;\n            }\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener) {\n                this.emit('removeListener', type, listener);\n            }\n        }\n\n        return this;\n\n    }\n\n    removeAllListeners(type) {\n\n        if (!this._events) {\n            return this;\n        }\n\n        const listeners = this._events[type];\n\n        if (isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else if (listeners) {\n            // LIFO order\n            while (listeners.length) {\n                this.removeListener(type, listeners[listeners.length - 1]);\n            }\n        }\n        delete this._events[type];\n\n        return this;\n\n    }\n\n    emit(type, ...args) {\n\n        if (!this._events) {\n            this._events = {};\n        }\n\n        // If there is no 'error' event listener then throw.\n        if (type === 'error') {\n            if (!this._events.error ||\n                (isObject(this._events.error) && !this._events.error.length)) {\n                const err = arguments[1];\n                if (err instanceof Error) {\n                    throw err; // Unhandled 'error' event\n                } else {\n                    // At least give some kind of context to the user\n                    throw new Error('Uncaught, unspecified \"error\" event. (' + err + ')');\n                }\n            }\n        }\n\n        const handler = this._events[type];\n\n        if (isUndefined(handler)) {\n            return false;\n        }\n\n        if (isFunction(handler)) {\n            switch (args.length) {\n            // fast cases\n            case 0:\n                handler.call(this);\n                break;\n            case 1:\n                handler.call(this, type, args[0]);\n                break;\n            case 2:\n                handler.call(this, type, args[0], args[1]);\n                break;\n            // slower\n            default:\n                handler.call(this, type, ...args);\n            }\n        } else if (Array.isArray(handler)) {\n            handler.slice().forEach(listener => listener.call(this, type, ...args));\n        }\n\n        return true;\n\n    }\n\n    once(type, listener) {\n\n        const handler = (evtName, message) => {\n            this.removeListener(evtName, handler);\n            listener(evtName, message);\n        };\n\n        this.on(type, handler);\n\n    }\n\n    on(type, listener) {\n        return this.addListener(type, listener);\n    }\n\n}\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\n","import {EventEmitter} from './transports/eventEmitter.mjs';\n\nconst transportModule = process.env.TRANSPORT;\n\nlet connection;\nlet _requestSeq = 0;\n\nexport default class Connection extends EventEmitter {\n\n    static connect(connectionString, userid=null, password=null) {\n\n        return connection || (connection = new Promise(\n            function (resolve, reject) {\n                import(/* webpackIgnore: true */ transportModule)\n                    .then(module => module.connect(connectionString))\n                    .then(transport => new Connection(transport))\n                    .then(resolve);\n            }\n        ));\n    }\n\n    constructor(transport) {\n\n        super();\n\n        this.transport = transport;\n\n        transport.on('message', (evtName, message) => {\n            if (Array.isArray(message)) {\n                message.forEach(message => this.publishMessage(message));\n            } else {\n                this.publishMessage(message);\n            }\n\n        });\n    }\n\n    publishMessage(message){\n        this.emit('message', message);\n    }\n\n    // send message to server\n    send(message){\n        this.transport.send(message);\n    }\n\n    // we could also allow server to provide it\n    nextRequestId() {\n        _requestSeq += 1;\n        return 'REQ' + _requestSeq;\n    }\n\n}\n","export function findKey(arr, test){\n    for (let i=0;i<arr.length;i++){\n        if (test(arr[i])){\n            return arr[i].key;\n        }\n    }\n}\n\nexport function indexOf(arr, test){\n    for (let i=0;i<arr.length;i++){\n        if (test(arr[i])){\n            return i;\n        }\n    }\n    return -1;\n}\n\nexport function replace(arr,idx, value){\n    const result = arr.slice();\n    result[idx] = value;\n    return result;\n}\n\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","import * as d3 from 'd3-array';\n\nexport const EQUALS = 'EQ';\nexport const GREATER_THAN = 'GT';\nexport const GREATER_EQ = 'GE';\nexport const LESS_THAN = 'LT';\nexport const LESS_EQ = 'LE';\nexport const AND = 'AND';\nexport const OR = 'OR';\nexport const STARTS_WITH = 'SW';\nexport const NOT_STARTS_WITH = 'NOT_SW';\nexport const IN = 'IN';\nexport const NOT_IN = 'NOT_IN';\n\nexport const SET_FILTER_DATA_COLUMNS = [\n    {name: 'value'}, \n    {name: 'count'}, \n    {name: 'totalCount'}\n];\n\nexport const BIN_FILTER_DATA_COLUMNS = [\n    {name: 'bin'}, \n    {name: 'count'}, \n    {name: 'bin-lo'},\n    {name: 'bin-hi'}\n];\nexport default function filterRows(rows, columnMap, filter) {\n    return applyFilter(rows, functor(columnMap, filter));\n}\n\n\nexport function getFilterColumn(column) {\n    return column.isGroup ? column.columns[0] : column;\n}\nexport function functor(columnMap, filter) {\n    //TODO convert filter to include colIdx ratherthan colName, so we don't have to pass cols\n    switch (filter.type) {\n    case IN: return testInclude(columnMap, filter);\n    case NOT_IN: return testExclude(columnMap, filter);\n    case EQUALS: return testEQ(columnMap, filter);\n    case GREATER_THAN: return testGT(columnMap, filter);\n    case GREATER_EQ: return testGE(columnMap, filter);\n    case LESS_THAN: return testLT(columnMap, filter);\n    case LESS_EQ: return testLE(columnMap, filter);\n    case STARTS_WITH: return testSW(columnMap, filter);\n    case NOT_STARTS_WITH: return testSW(columnMap, filter, true);\n    case AND: return testAND(columnMap, filter);\n    case OR: return testOR(columnMap, filter);\n    default:\n        console.log(`unrecognized filter type ${filter.type}`);\n        return () => true;\n    }\n}\n\nfunction applyFilter(rows, filter) {\n    const results = [];\n    for (let i = 0; i < rows.length; i++) {\n        if (filter(rows[i])) {\n            results.push(rows[i]);\n        }\n    }\n    return results;\n}\n\nfunction testAND(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.every(fn => fn(row));\n}\n\nfunction testOR(cols, f) {\n    const filters = f.filters.map(f1 => functor(cols, f1));\n    return row => filters.some(fn => fn(row));\n}\n\nfunction testSW(cols, f, inversed = false) {\n    const value = f.value.toLowerCase();\n    return inversed\n        ? row => row[cols[f.colName]].toLowerCase().indexOf(value) !== 0\n        : row => row[cols[f.colName]].toLowerCase().indexOf(value) === 0;\n   \n}\n\nfunction testGT(cols, f) {\n    return row => row[cols[f.colName]] > f.value;\n}\n\nfunction testGE(cols, f) {\n    return row => row[cols[f.colName]] >= f.value;\n}\n\nfunction testLT(cols, f) {\n    return row => row[cols[f.colName]] < f.value;\n}\n\nfunction testLE(cols, f) {\n    return row => row[cols[f.colName]] <= f.value;\n}\n\nfunction testInclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) !== -1;\n}\n\n// faster to convert values to a keyed map\nfunction testExclude(cols, f) {\n    // eslint-disable-next-line eqeqeq \n    return row => f.values.findIndex(val => val == row[cols[f.colName]]) === -1;\n}\n\nfunction testEQ(cols, f) {\n    return row => row[cols[f.colName]] === f.value;\n}\n\nexport function shouldShowFilter(filterColumnName, column) {\n    const filterColumn = getFilterColumn(column);\n    if (filterColumn.isGroup) {\n        return filterColumn.columns.some(col => col.name === filterColumnName);\n    } else {\n        return filterColumnName === filterColumn.name;\n    }\n}\n\nexport function includesNoValues(filter) {\n    // TODO make sure we catch all cases...\n    if (!filter){\n        return false;\n    } else if (filter.type === IN && filter.values.length === 0) {\n        return true;\n    } else if (filter.type === AND && filter.filters.some(f => includesNoValues(f))){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// does f2 only narrow the resultset from f1\nexport function extendsFilter(f1=null, f2=null) {\n    // ignore filters which are identical\n    // include or exclude filters which add values\n    if (f2 === null){\n        return false\n    } else if (f1 === null) {\n        return true;\n    }\n    if (f1.colName && f1.colName === f2.colName) {\n        if (f1.type === f2.type) {\n            switch (f1.type) {\n            case IN:\n                return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n            case NOT_IN: \n                return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n            case STARTS_WITH: return f2.value.length > f1.value.length && f2.value.indexOf(f1.value) === 0;\n                // more cases here such as GT,LT\n            default:\n            }\n        }\n\n    } else if (f1.colname && f2.colName) {\n        // different columns,always false\n        return false;\n    } else if (f2.type === AND && extendsFilters(f1, f2)) {\n        return true;\n    }\n\n    // safe option is to assume false, causing filter to be re-applied to base data\n    return false;\n}\n\nconst byColName = (a, b) => a.colName === b.colName ? 0 : a.colName < b.colName ? -1 : 1;\n\nfunction extendsFilters(f1, f2) {\n    if (f1.colName) {\n        const matchingFilter = f2.filters.find(f => f.colName === f1.colName);\n        return filterEquals(matchingFilter, f1, true);\n    } else if (f1.filters.length === f2.filters.length) {\n        // if the only differences are extra values in an excludes filter or fewer values in an includes filter\n        // then we are still extending the filter (i.e. narrowing the resultset)\n        const a = f1.filters.sort(byColName);\n        const b = f2.filters.slice().sort(byColName);\n\n        for (let i = 0; i < a.length; i++) {\n            if (!filterEquals(a[i], b[i], true) && !filterExtends(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (f2.filters.length > f1.filters.length){\n        return f1.filters.every(filter1 => {\n            const filter2 = f2.filters.find(f => f.colName === filter1.colName);\n            return filterEquals(filter1, filter2, true); // could also allow f2 extends f1\n        });\n    }\n}\n\nexport function addFilter(existingFilter, filter) {\n\n    if (includesNoValues(filter)){\n        const {colName} = filter;\n        existingFilter = removeFilterForColumn(existingFilter, {name:colName});\n    }\n\n    if (!existingFilter) {\n        return filter;\n    } else if (!filter) {\n        return existingFilter;\n    }\n   \n    if (existingFilter.type === AND && filter.type === AND) {\n        return { type: 'AND', filters: combine(existingFilter.filters, filter.filters) };\n    } else if (existingFilter.type === 'AND') {\n        const filters = replaceOrInsert(existingFilter.filters, filter);\n        return filters.length > 1\n            ? { type: 'AND', filters  }\n            : filters[0];\n    } else if (filter.type === 'AND') {\n        return { type: 'AND', filters: filter.filters.concat(existingFilter) };\n    } else if (filterEquals(existingFilter, filter, true)) {\n        return filter;\n    } else if (sameColumn(existingFilter, filter)){\n        return merge(existingFilter, filter);\n    } else {\n        return { type: 'AND', filters: [existingFilter, filter] };\n    }\n}\n\n// If we add an IN filter and there is an existing NOT_IN, we would always expect the IN\n// values to exist in the NOT_IN set (as long as user interaction is driving the filtering)\nfunction replaceOrInsert(filters, filter) {\n    const {type, colName, values} = filter;\n    if (type === IN) {\n        // see if we have a NOT_IN entry\n        let idx = filters.findIndex(f => f.type === NOT_IN && f.colName === colName);\n        if (idx !== -1){\n            const {values: existingValues} = filters[idx];\n            if (values.every(value => existingValues.indexOf(value) !== -1)){\n                if (values.length === existingValues.length){\n                    // we simply remove the existing NOT_IN filter ...\n                    return filters.filter((f, i) => i !== idx);\n                } else {\n                    // ... or strip the IN values from the NOT_IN values\n                    let newValues = existingValues.filter(value => !values.includes(value));\n                    return filters.map((filter,i) => i === idx ? {...filter, values: newValues}: filter)\n\n                }\n            }\n            else if (values.some(value => existingValues.indexOf(value) !== -1)){\n                console.log(`partial overlap between IN and NOT_IN`)\n\n            }\n        }\n\n\n        idx = filters.findIndex(f => f.type === IN && f.colName === filter.colName);\n        if (idx !== -1) {\n            return filters.map((f, i) => i === idx ? merge(f, filter) : f);\n        }\n    }\n\n    return filters.concat(filter);\n}\n\nfunction merge(f1, f2){\n    const {type: t1} = f1;\n    const {type: t2} = f2;      \n    const sameType = t1 === t2 ? t1 : '';\n\n    if (includesNoValues(f2)){\n        return f2;\n    } else if ((t1 === IN && t2 === NOT_IN) || (t1 === NOT_IN && t2 === IN)){\n        // do the two sets cancel each other out ?\n        if (f1.values.length === f2.values.length && f1.values.every(v => f2.values.includes(v))){  \n            // DOn't think this is right\n            return null;\n        } else if (t1 === NOT_IN){\n            if (f2.values.every(v => f1.values.includes(v))){\n                return {\n                    ...f1,\n                    values: f1.values.filter(v => !f2.values.includes(v))\n                }\n            }\n        }\n    } else if (sameType === IN || sameType === NOT_IN){\n        return {\n            ...f1,\n            values: f1.values.concat(f2.values.filter(v => !f1.values.includes(v)))\n        }\n    } else if (sameType === STARTS_WITH){\n        return {\n            type: OR,\n            filters: [f1, f2]\n        }\n    } else if (sameType === NOT_STARTS_WITH){\n        return {\n            type: AND,\n            filters: [f1, f2]\n        }\n\n    }\n\n    return f2;\n\n}\n\nfunction combine(existingFilters, replacementFilters) {\n\n    // TODO need a safer REGEX here\n    function equivalentType({ type: t1 }, { type: t2 }) {\n        return (t1 === t2) || (t1[0] === t2[0]);\n    }\n\n    const replaces = (existingFilter, replacementFilter) => {\n        return existingFilter.colName === replacementFilter.colName &&\n            equivalentType(existingFilter, replacementFilter);\n    };\n\n    const stillApplicable = existingFilter => replacementFilters.some(\n        replacementFilter => replaces(existingFilter, replacementFilter)) === false;\n\n    return existingFilters.filter(stillApplicable).concat(replacementFilters);\n}\n\nexport function removeFilter(sourceFilter, filterToRemove) {\n    if (filterEquals(sourceFilter, filterToRemove, true)) {\n        return null;\n    } else if (sourceFilter.type !== AND) {\n        throw Error(`removeFilter cannot remove ${JSON.stringify(filterToRemove)} from ${JSON.stringify(sourceFilter)}`);\n    } else {\n        const filters = sourceFilter.filters.filter(f => !filterEquals(f, filterToRemove));\n        return filters.length > 0 ? { type: AND, filters } : null;\n    }\n}\n\nexport function splitFilterOnColumn(filter, columnName) {\n    if (!filter){\n        return [null,null];\n    } else if (filter.colName === columnName) {\n        return [filter,null];\n    } else if (filter.type !== 'AND') {\n        return [null, filter];\n    } else {\n        const [[columnFilter=null], filters] = partition(filter.filters, f => f.colName === columnName);\n        return filters.length === 1\n            ? [columnFilter,filters[0]]\n            : [columnFilter, { type: 'AND', filters }];\n    }\n}\n\nexport const overrideColName = (filter, colName) => {\n    const {type} = filter;\n    if (type === AND || type === OR){\n        return {\n            type,\n            filters: filter.filters.map(f => overrideColName(f, colName))\n        }\n    } else {\n        return {...filter, colName}\n    }\n}\n\nexport function extractFilterForColumn(filter, columnName) {\n    if (!filter) {\n        return null;\n    }\n    const { type, colName } = filter;\n    switch (type) {\n        case AND: \n        case OR: \n            return collectFiltersForColumn(type, filter.filters, columnName);\n\n        default:\n            return colName === columnName ? filter : null;\n    }\n}\n\nfunction collectFiltersForColumn(type, filters, columName){\n    const results = [];\n    filters.forEach(filter => {\n        const ffc = extractFilterForColumn(filter, columName);\n        if (ffc !== null){\n            results.push(ffc);\n        }\n    })\n    if (results.length === 1){\n        return results[0];\n    } else {\n        return {\n            type,\n            filters: results\n        }\n    }\n}\n\nexport function includesColumn(filter, column) {\n    if (!filter) {\n        return false;\n    }\n    const { type, colName, filters } = filter;\n    switch (type) {\n    case AND: return filters.some(f => includesColumn(f, column));\n    default: return colName === column.name;\n    }\n}\n\nexport function removeFilterForColumn(sourceFilter, column) {\n    const colName = column.name;\n    if (!sourceFilter){\n        return null;\n    } else if (sourceFilter.colName === colName) {\n        return null;\n    } else if (sourceFilter.type === AND || sourceFilter.type === OR) {\n        const {type, filters} = sourceFilter;\n        const otherColFilters = filters.filter(f => f.colName !== colName);\n        switch(otherColFilters.length){\n            case 0: return null;\n            case 1: return otherColFilters[0];\n            default: return { type, otherColFilters } \n        }\n    } else {\n        return sourceFilter;\n    }\n}\n\nconst sameColumn = (f1, f2) => f1.colName === f2.colName;\n\nexport function filterEquals(f1, f2, strict = false) {\n    if (f1 && f1){\n        const isSameColumn = sameColumn(f1,f2);\n        if (!strict) {\n            return isSameColumn;\n        } else {\n            return isSameColumn &&\n                f1.type === f2.type && \n                f1.mode === f2.mode &&\n                f1.value === f2.value &&\n                sameValues(f1.values, f2.values);\n        }\n    } else {\n        return false;\n    }\n}\n\n// does f2 extend f1 ?\nfunction filterExtends(f1, f2) {\n    if (f1.type === IN && f2.type === IN) {\n        return f2.values.length < f1.values.length && containsAll(f1.values, f2.values);\n    } else if (f1.type === NOT_IN && f2.type === NOT_IN) {\n        return f2.values.length > f1.values.length && containsAll(f2.values, f1.values);\n    } else {\n        return false;\n    }\n}\n\n//TODO roll this into next function\nexport function projectFilterData(filterRows) {\n    return filterRows.map((row, idx) => [idx, 0, 0, null, row.name, row.count]);\n}\n\nexport function getBinnedValues(rows, key, numberOfBins = 20) {\n    const numbers = rows.map(row => row[key]);\n    // const start = performance.now();\n    const values = d3.histogram().thresholds(numberOfBins)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n    // const end = performance.now();\n    // onsole.log(`%ctook ${end - start} ms to build histogram`, 'font-weight:bold;color:red;');\n    // onsole.log(values);\n    return values;\n\n}\n\n// The folowing are array utilities but they are defined here as they are not suitable for large arrays, so we'll\n// keep them local to filters\nfunction containsAll(superList, subList) {\n    for (let i = 0, len = subList.length; i < len; i++) {\n        if (superList.indexOf(subList[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// only suitable for small arrays of simple types (e.g. filter values)\nfunction sameValues(arr1, arr2) {\n    if (arr1 === arr2) {\n        return true;\n    } else if (arr1.length === arr2.length) {\n        const a = arr1.slice().sort();\n        const b = arr2.slice().sort();\n        return a.join('|') === b.join('|');\n    }\n    return false;\n}\n\nfunction partition(list, test1, test2=null) {\n    const results1 = [];\n    const misses = [];\n    const results2 = test2===null ? null : [];\n\n    for (let i = 0; i < list.length; i++) {\n        if (test1(list[i])) {\n            results1.push(list[i]);\n        } else if (test2 !== null && test2(list[i])) {\n            results2.push(list[i]);\n        } else {\n            misses.push(list[i]);\n        }\n    }\n\n    return test2 === null\n        ? [results1, misses]\n        : [results1, results2, misses];\n}\n","import {\n    functor, \n    overrideColName, \n    SET_FILTER_DATA_COLUMNS, \n    BIN_FILTER_DATA_COLUMNS} from './filter';\n\nconst SORT_ASC = 'asc';\n\nexport const setFilterColumnMeta = metaData(SET_FILTER_DATA_COLUMNS)\nexport const binFilterColumnMeta = metaData(BIN_FILTER_DATA_COLUMNS)\n\nexport function mapSortCriteria(sortCriteria, columnMap) {\n    return sortCriteria.map(s => {\n        if (typeof s === 'string') {\n            return [columnMap[s], 'asc'];\n        } else if (Array.isArray(s)) {\n            const [columnName, sortDir] = s;\n            return [columnMap[columnName], sortDir || SORT_ASC];\n        } else {\n            throw Error('columnUtils.mapSortCriteria invalid input');\n        }\n\n    });\n}\n\nexport function buildColumnMap(columns){\n    if (columns){\n        return columns.reduce((map, column, i) => {\n            if (typeof column === 'string'){\n                map[column] = i;\n            } else if (typeof column.key === 'number') {\n                map[column.name] = column.key;\n            } else {\n                map[column.name] = i;\n            }\n            return map;\n        },{})\n    } else {\n        return null;\n    }\n}\n\nexport function projectColumns(map, columns, meta){\n    const length = columns.length;\n    const {IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n    return startIdx => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = 0;\n        return out;\n    }\n}\n\nexport function projectColumnsFilter(map, columns, meta, filter){\n    const length = columns.length;\n    const {IDX, DEPTH, COUNT, KEY, SELECTED} = meta;\n\n    // this is filterset specific where first col is always value\n    const fn = filter ? functor(map, overrideColName(filter, 'value'), true)  : () => true;\n    return startIdx => (row,i) => {\n        const out = [];\n        for (let i=0;i<length;i++){\n            const colIdx = map[columns[i].name];\n            out[i] = row[colIdx];\n        }\n        // assume row[0] is key for now\n        // out.push(startIdx+i, 0, 0, row[0]);\n        out[IDX] = startIdx+i;\n        out[DEPTH] = 0;\n        out[COUNT] = 0;\n        out[KEY] = row[0];\n        out[SELECTED] = fn(row) ? 1 : 0;\n\n        return out;\n    }\n}\n\nexport const toKeyedColumn = (column, key) =>\n    typeof column === 'string'\n        ? { key, name: column }\n        : typeof column.key === 'number'\n            ? column\n            : {...column, key};\n\nexport const toColumn = column =>\n    typeof column === 'string'\n        ? { name: column }\n        : column;\n\nexport function getFilterType(column){\n    return column.filter || getDataType(column);\n}\n\n// {name: 'Price', 'type': {name: 'price'}, 'aggregate': 'avg'},\n// {name: 'MarketCap', 'type': {name: 'number','format': 'currency'}, 'aggregate': 'sum'},\n\nexport function getDataType({type=null}){\n    if (type === null){\n        return 'set';\n    } else if (typeof type === 'string'){\n        return type;\n    } else {\n        switch(type.name){\n            case 'price':\n                return 'number';\n            default:\n                return type.name;\n        }\n    }\n\n}\n\n//TODO cache result by length\nexport function metaData(columns){\n    const start = Math.max(...columns.map((column, idx) => typeof column.key === 'number' ? column.key : idx));\n    return {\n        IDX: start + 1,\n        DEPTH: start + 2,\n        COUNT: start + 3,\n        KEY: start + 4,\n        SELECTED: start + 5,\n        PARENT_IDX: start + 6,\n        IDX_POINTER: start + 7,\n        FILTER_COUNT: start + 8,\n        NEXT_FILTER_IDX: start + 9,\n        count: start + 10\n    }\n}\n","export const DataTypes = {\n    ROW_DATA: 'rowData',\n    FILTER_DATA: 'filterData',\n    FILTER_BINS: 'filterBins'\n};\n\nexport const ASC = 'asc';\nexport const DSC = 'dsc';\n","export const NULL_RANGE = {lo: 0,hi: 0};\n\n// If the requested range overlaps the last sent range, we only need send the\n// newly exposed section of the range. The client will manage dropping off\n// the expired section.\n//\n// |----------------------------------| _range\n//  ++++++|----------------------------------| prevRange\n//  \n//\n//\n//  |------------------------------------| _range\n//  |----------------------------------|+  prevRange\n//TODO do we still need these calls to getFullRange ?\nexport function getDeltaRange(oldRange, newRange){\n    const {lo: oldLo, hi: oldHi} = oldRange /*getFullRange(oldRange)*/;\n    const {lo: newLo, hi: newHi} = newRange /*getFullRange(newRange)*/;\n\n    if (newLo >= oldLo && newHi <= oldHi){\n        // reduced range, no delta\n        return {lo: newHi, hi: newHi};\n\n    } else if (newLo >= oldHi || newHi < oldLo){\n        return {lo: newLo, hi: newHi};\n    } else if (newLo === oldLo && newHi === oldHi){\n        return {lo: oldHi,hi: oldHi};\n    } else {\n        return {\n            lo: newLo < oldLo ? newLo: oldHi,\n            hi: newHi > oldHi ? newHi: oldLo\n        };\n    }\n}\n\nexport function resetRange({lo,hi,bufferSize=0}){\n    return {\n        lo: 0,\n        hi: hi-lo,\n        bufferSize\n    };\n}\n\nexport function getFullRange({lo,hi,bufferSize=0}){\n    return {\n        lo: Math.max(0, lo - bufferSize),\n        hi: hi + bufferSize\n    };\n}\n\nexport function withinRange(range, index, offset=0) {\n    return index-offset >= range.lo && index-offset < range.hi;\n}\n\nconst SAME = 0;\nconst FWD = 2;\nconst BWD = 4;\nconst CONTIGUOUS = 8;\nconst OVERLAP = 16;\nconst REDUCE = 32;\nconst EXPAND = 64;\nconst NULL = 128;\n\nexport const RangeFlags = {\n    SAME,\n    FWD,\n    BWD,\n    CONTIGUOUS,\n    OVERLAP,\n    REDUCE,\n    EXPAND,\n    NULL\n}\n\nRangeFlags.GAP = ~(CONTIGUOUS | OVERLAP | REDUCE)\n\nexport function compareRanges(range1, range2){\n    if (range2.lo === 0 && range2.hi === 0){\n        return NULL;\n    } else if (range1.lo === range2.lo && range1.hi === range2.hi){\n        return SAME;\n    } else if (range2.hi > range1.hi){\n        if (range2.lo > range1.hi){\n            return FWD;\n        } else if (range2.lo === range1.hi){\n            return FWD + CONTIGUOUS;\n        } else if (range2.lo >= range1.lo){\n            return FWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo < range1.lo){\n        if (range2.hi < range1.lo){\n            return BWD;\n        } else if (range2.hi === range1.lo){\n            return BWD + CONTIGUOUS;\n        } else if (range2.hi > range1.lo){\n            return BWD + OVERLAP;\n        } else {\n            return EXPAND;\n        }\n    } else if (range2.lo > range1.lo) {\n        return REDUCE + FWD;\n    } else {\n        return REDUCE + BWD\n    }\n}\n","/*global fetch */\nimport {EventEmitter} from '@heswell/utils';\nimport {buildColumnMap} from './columnUtils'\n\nconst defaultUpdateConfig = {\n    applyUpdates: false,\n    applyInserts: false,\n    interval: 500\n}\n\nexport default class Table extends EventEmitter {\n\n    constructor(config){\n        super();\n\n        const {name, columns=null, primaryKey, dataPath, data, updates = {}} = config;\n\n        this.name = name;\n        this.primaryKey = primaryKey;\n        this.columns = columns;\n        this.keys = {};\n        this.index = {};\n        this.rows = [];\n        this.updateConfig = {\n            ...defaultUpdateConfig,\n            ...updates\n        }\n        this.columnMap = buildColumnMap(columns);\n        this.columnCount = 0;\n        this.status = null;\n\n        // console.log(`Table \n        //     columns = ${JSON.stringify(columns,null,2)}\n        //     columnMap = ${JSON.stringify(this.columnMap,null,2)}    \n        //     `)\n\n\n        if (data){\n            this.parseData(data);\n        } else if (dataPath){\n            this.loadData(dataPath);\n        }\n\n        this.installDataGenerators(config);\n    }\n\n    // ...updates = one or more pairs of (colIdx, colValue)\n    update(rowIdx, ...updates){\n        //onsole.log(`Table.update ${this.name} idx: ${rowIdx}  ${JSON.stringify(updates)}` );\n        const results = [];\n        let row = this.rows[rowIdx];\n        for (let i=0;i<updates.length;i+=2){\n            const colIdx = updates[i];\n            const value = updates[i+1];\n            results.push(colIdx, row[colIdx], value);\n            row[colIdx] = value;\n        }\n        this.emit('rowUpdated', rowIdx, results);\n    }\n\n    insert(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const idx = this.rows.length;\n        let row = this.rowFromData(idx, data, columnnameList);\n        this.rows.push(row);\n        this.emit('rowInserted', idx, row);\n    }\n\n    remove(key){\n        if (this.keys[key]){\n            const index = this.indices[key];\n            delete this.keys[key];\n            delete this.indices[key];\n            this.rows.splice(index,1);\n\n            for (let k in this.indices){\n                if (this.indices[k] > index){\n                    this.indices[k] -= 1;\n                }\n            }\n\n            this.emit('rowRemoved', this.name, key);\n\n        }\n    }\n\n    clear(){\n\n    }\n\n    toString(){\n        const out = ['\\n' + this.name];\n        out.splice.apply(out, [1,0].concat(this.rows.map(function(row){return row.toString();})));\n        return out.join('\\n');\n    }\n\n    async loadData(url){\n        fetch(url,{\n\n        })\n            .then(data => data.json())\n            .then(json => {\n                console.log(`Table.loadData: got ${json.length} rows`);\n                this.parseData(json);\n            })\n            .catch(err => {\n                console.error(err);\n            });\n\n    }\n\n    parseData(data){\n        let columnnameList = this.columns ? this.columns.map(c => c.name): null;\n        const rows = [];\n        for (let i=0;i<data.length;i++){\n            let row = this.rowFromData(i, data[i], columnnameList);\n            rows.push(row);\n        }\n        this.rows = rows;\n\n        if (this.columns === null){\n            this.columns = columnsFromColumnMap(this.inputColumnMap);\n            this.columnMap = buildColumnMap(this.columns);\n        }\n        this.status = 'ready';\n        this.emit('ready');\n        if (this.updateConfig && this.updateConfig.applyUpdates !== false){\n            setTimeout(() => {\n                this.applyUpdates();\n            },1000);\n        }\n        // move this\n        if (this.updateConfig && this.updateConfig.applyInserts !== false){\n            setTimeout(() => {\n                this.applyInserts();\n            },10000);\n        }\n    }\n\n    rowFromData(idx, data, columnnameList){\n        // 2 metadata items for each row, the idx and unique key\n        const {index, primaryKey=null, columnMap: map} = this;\n\n        if (Array.isArray(data)){\n            const key = data[map[this.primaryKey]];\n            index[key] = idx;\n            return [...data, idx, key];\n        } else {\n            // This allows us to load data from objects as rows, without predefined columns, where\n            // not every row may have every column. How would we handle primary key ?\n            const columnMap = map || (this.columnMap = {});\n            const colnames = columnnameList || Object.getOwnPropertyNames(data);\n            const row = [idx];\n            let colIdx;\n            let key;\n\n            for (let i=0; i<colnames.length; i++){\n                const name = colnames[i];\n                const value = data[name];\n                if ((colIdx = columnMap[name]) === undefined){\n                    colIdx = columnMap[name] = this.columnCount++;\n                }\n                row[colIdx] = value;\n                // If we don't know the primary key, assume it is the first column for now\n                if ((name === primaryKey) || (primaryKey === null && i === 0)){\n                    key = value;\n                    index[value] = idx;\n                }\n            }\n            // doesn't this risk pushing the metadata into the wrong slots if not every row has every \n            // field\n            row.push(idx, key)\n            return row;\n        }\n    }\n\n    //TODO move all these methods into an external helper\n    applyInserts(){\n\n        const idx = this.rows.length;\n        const newRow = this.createRow(idx);\n        if (newRow){\n            this.insert(newRow);\n        } else {\n            console.log(`createRow did not return a new row`);\n        }\n\n        setTimeout(() => this.applyInserts(),5000);\n\n    }\n\n    applyUpdates(){\n        const {rows} = this;\n        // const count = Math.round(rows.length / 50);\n        const count = 100;\n\n        for (let i=0; i<count; i++){\n            const rowIdx = getRandomInt(rows.length - 1);\n            const update = this.updateRow(rowIdx, this.rows[rowIdx], this.columnMap);\n            if (update){\n                this.update(rowIdx, ...update);\n            }\n        }\n\n        setTimeout(() => this.applyUpdates(),this.updateConfig.interval);\n\n    }\n\n    createRow(idx){\n        console.warn(`createRow ${idx} must be implemented as a plugin`);\n    }\n\n    updateRow(/*idx, row, columnMap*/){\n        return null;\n    }\n\n    async installDataGenerators(/*config*/){\n        //console.warn(`installDataGenerators must be implemented by a more specific subclass`);\n    }\n\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction columnsFromColumnMap(columnMap){\n\n    const columnNames = Object.getOwnPropertyNames(columnMap);\n\n    return columnNames\n        .map(name => ({name, key: columnMap[name]}))\n        .sort(byKey)\n        .map(({name}) => ({name}));\n\n}\n\nfunction byKey(col1, col2){\n    return col1.key - col2.key;\n}\n","/**\n * Keep all except for groupRowset in this file to avoid circular reference warnings\n */\nimport * as d3 from 'd3-array';\nimport Table from '../table';\nimport { sort, sortExtend, sortReversed, sortBy, sortPosition, sortableFilterSet } from '../sort';\nimport { \n    BIN_FILTER_DATA_COLUMNS,\n    SET_FILTER_DATA_COLUMNS,\n    extendsFilter,\n    extractFilterForColumn,\n    functor as filterPredicate,\n    splitFilterOnColumn,\n    overrideColName\n} from '../filter';\nimport { addRowsToIndex } from '../rowUtils';\nimport { groupbyExtendsExistingGroupby } from '../groupUtils';\nimport { projectColumns, projectColumnsFilter, mapSortCriteria, metaData } from '../columnUtils';\nimport { DataTypes } from '../types';\nimport { getDeltaRange, getFullRange, NULL_RANGE } from '../rangeUtils';\n\nconst SINGLE_COLUMN = 1;\n\nconst NO_OPTIONS = {\n    filter: null\n}\n\nexport default class BaseRowSet {\n\n    constructor(table, columns, offset = 0) {\n        this.table = table;\n        this.offset = offset;\n        this.baseOffset = offset;\n        this.range = NULL_RANGE;\n        this.columns = columns;\n        this.currentFilter = null;\n        this.filterSet = null;\n        this.selectedSet = [];\n        this.columnMap = table.columnMap;\n        this.meta = metaData(columns);\n        this.data = table.rows;\n        const {length} = this.data;\n        this.totalCount = length;\n    }\n\n    // used by binned rowset\n    get filteredData() {\n        if (this.filterSet) {\n            return this.filterSet;\n        } else {\n            const { IDX } = this.meta;\n            return this.data.map(row => row[IDX])\n        }\n    }\n\n    get filterCount(){\n        return this.filterSet\n            ? this.filterSet.length\n            : this.data.length;\n    }\n\n    setRange(range, useDelta = true) {\n\n        const { lo, hi } = useDelta ? getDeltaRange(this.range, range) : getFullRange(range);\n        const {totalCount} = this;\n        const resultset = this.slice(lo, hi);\n        this.range = range;\n        return {\n            rows: resultset,\n            range,\n            size: this.size,\n            offset: this.offset,\n            totalCount\n        };\n    }\n\n    currentRange() {\n        const { lo, hi } = this.range;\n        const {totalCount} = this;\n        const resultset = this.slice(lo, hi);\n        return {\n            rows: resultset,\n            range: this.range,\n            size: this.size,\n            offset: this.offset,\n            totalCount\n        };\n    }\n\n    selectNavigationSet(useFilter) {\n        const { COUNT, IDX_POINTER, FILTER_COUNT, NEXT_FILTER_IDX } = this.meta;\n        return useFilter\n            ? [this.filterSet, NEXT_FILTER_IDX, FILTER_COUNT]\n            : [this.sortSet, IDX_POINTER, COUNT];\n    }\n\n    //TODO cnahge to return a rowSet, same as getDistinctValuesForColumn\n    getBinnedValuesForColumn(column) {\n        const key = this.columnMap[column.name];\n        const { data: rows, filteredData } = this;\n        const numbers = filteredData.map(rowIdx => rows[rowIdx][key]);\n        const data = d3.histogram().thresholds(20)(numbers).map((arr, i) => [i + 1, arr.length, arr.x0, arr.x1]);\n\n        const table = new Table({ data, primaryKey: 'bin', columns: BIN_FILTER_DATA_COLUMNS });\n        const filterRowset = new BinFilterRowSet(table, BIN_FILTER_DATA_COLUMNS, column.name);\n        return filterRowset;\n    }\n\n    getDistinctValuesForColumn(column) {\n        const { data: rows, columnMap, currentFilter } = this;\n        const colIdx = columnMap[column.name]\n        const resultMap = {};\n        const data = [];\n        const dataRowCount = rows.length;\n        const [columnFilter, otherFilters] = splitFilterOnColumn(currentFilter, column)\n        // this filter for column that we remove will provide our selected values   \n        console.log(`we are missing opportunity to set selected with ${JSON.stringify(columnFilter)}`)     \n        let dataRowAllFilters = 0;\n\n        if (otherFilters === null) {\n            let result;\n            for (let i = 0; i < dataRowCount; i++) {\n                const val = rows[i][colIdx];\n                if (result = resultMap[val]) {\n                    result[2] = ++result[1];\n                } else {\n                    result = [val, 1, 1]\n                    resultMap[val] = result;\n                    data.push(result)\n                }\n            }\n            dataRowAllFilters = dataRowCount;\n        } else {\n\n            const fn = filterPredicate(columnMap, otherFilters);\n            let result;\n\n            for (let i = 0; i < dataRowCount; i++) {\n                const row = rows[i];\n                const val = row[colIdx];\n                const isIncluded = fn(row) ? 1 : 0;\n                if (result = resultMap[val]) {\n                    result[1] += isIncluded;\n                    result[2]++;\n                } else {\n                    result = [val, isIncluded, 1]\n                    resultMap[val] = result;\n                    data.push(result)\n                }\n                dataRowAllFilters += isIncluded;\n            }\n        }\n\n        //TODO primary key should be indicated in columns\n        const table = new Table({ data, primaryKey: 'value', columns: SET_FILTER_DATA_COLUMNS });\n        return new SetFilterRowSet(table, SET_FILTER_DATA_COLUMNS, column.name, dataRowAllFilters, dataRowCount);\n\n    }\n}\n\n//TODO should range be baked into the concept of RowSet ?\nexport class RowSet extends BaseRowSet {\n\n    // TODO stream as above\n    static fromGroupRowSet({ table, columns, offset, currentFilter: filter }) {\n        return new RowSet(table, columns, offset, {\n            filter\n        });\n    }\n    //TODO consolidate API of rowSet, groupRowset\n    constructor(table, columns, offset = 0, { filter = null } = NO_OPTIONS) {\n        super(table, columns, offset);\n        this.project = projectColumns(table.columnMap, columns, this.meta);\n        this.sortCols = null;\n        this.sortReverse = false;\n        this.sortSet = this.buildSortSet();\n        this.filterSet = null;\n        this.sortRequired = false;\n        if (filter) {\n            this.currentFilter = filter;\n            this.filter(filter);\n        }\n    }\n\n    buildSortSet() {\n        const len = this.data.length;\n        const arr = Array(len);\n        for (let i = 0; i < len; i++) {\n            arr[i] = [i, null, null];\n        }\n        return arr;\n    }\n\n    slice(lo, hi) {\n\n        if (this.filterSet) {\n            const filteredData = this.filterSet.slice(lo, hi);\n            const filterMapper = typeof filteredData[0] === 'number'\n                ? idx => this.data[idx]\n                : ([idx]) => this.data[idx];\n            return filteredData\n                .map(filterMapper)\n                .map(this.project(lo + this.offset));\n        } else if (this.sortCols) {\n            const sortSet = this.sortSet;\n            const results = []\n            for (let i = lo, rows = this.data, len = rows.length; i < len && i < hi; i++) {\n                const idx = this.sortReverse\n                    ? sortSet[len - i - 1][0]\n                    : sortSet[i][0];\n                const row = rows[idx];\n                results.push(row);\n            }\n            return results.map(this.project(lo + this.offset));\n        } else {\n            return this.data.slice(lo, hi).map(this.project(lo + this.offset));\n        }\n    }\n\n    // deprecated\n    get size() {\n        return this.filterSet === null\n            ? this.data.length\n            : this.filterSet.length\n    }\n\n    get first() {\n        return this.data[0];\n    }\n    get last() {\n        return this.data[this.data.length - 1];\n    }\n    get rawData() {\n        return this.data;\n    }\n\n    setStatus(status) {\n        this.status = status;\n    }\n\n    addRows(rows) {\n        addRowsToIndex(rows, this.index, this.meta.IDX);\n        this.data = this.data.concat(rows);\n    }\n\n    sort(sortCols) {\n\n        const sortSet = this.currentFilter === null\n            ? this.sortSet\n            : this.filterSet = sortableFilterSet(this.filterSet);\n\n        this.sortRequired = this.currentFilter !== null;\n\n        if (sortReversed(this.sortCols, sortCols, SINGLE_COLUMN)) {\n            this.sortReverse = !this.sortReverse;\n        } else if (this.sortCols !== null && groupbyExtendsExistingGroupby(sortCols, this.sortCols)) {\n            this.sortReverse = false;\n            sortExtend(sortSet, this.data, this.sortCols, sortCols, this.columnMap)\n        } else {\n            this.sortReverse = false;\n            sort(sortSet, this.data, sortCols, this.columnMap)\n        }\n\n        this.sortCols = sortCols;\n\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        // this.filterCount = this.totalCount;\n        if (this.sortRequired) {\n            this.sort(this.sortCols);\n        }\n    }\n\n    filter(filter) {\n        const extendsCurrentFilter = extendsFilter(this.currentFilter, filter);\n        const fn = filter && filterPredicate(this.columnMap, filter);\n        const { data: rows } = this;\n        let [navSet] = this.selectNavigationSet(extendsCurrentFilter && this.filterSet)\n        const newFilterSet = [];\n\n        for (let i = 0; i < navSet.length; i++) {\n            const rowIdx = navSet === this.filterSet ? navSet[i] : navSet[i][0];\n            const row = rows[rowIdx];\n            if (fn(row)) {\n                newFilterSet.push(rowIdx)\n            }\n\n        }\n        this.filterSet = newFilterSet;\n        this.currentFilter = filter;\n        if (!extendsCurrentFilter && this.sortRequired) {\n            // TODO this might be very expensive for large dataset\n            // WHEN DO WE DO THIS - IS THIS CORRECT !!!!!\n            this.sort(this.sortCols)\n        }\n        return newFilterSet.length;\n\n    }\n\n    update(idx, updates) {\n        if (this.currentFilter === null && this.sortCols === null) {\n            if (idx >= this.range.lo && idx < this.range.hi) {\n                return [idx + this.offset, ...updates];\n            }\n        } else if (this.currentFilter === null) {\n            const { sortSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const [rowIdx] = sortSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        } else {\n            // sorted AND/OR filtered\n            const { filterSet } = this;\n            for (let i = this.range.lo; i < this.range.hi; i++) {\n                const rowIdx = Array.isArray(filterSet[i]) ? filterSet[i][0] : filterSet[i];\n                if (rowIdx === idx) {\n                    return [i + this.offset, ...updates];\n                }\n            }\n        }\n    }\n\n    insert(idx, row) {\n        // TODO multi colun sort sort DSC \n        if (this.sortCols === null && this.currentFilter === null) {\n            // simplest scenario, row will be at end of sortset ...\n            this.sortSet.push([idx, null, null]);\n            if (idx >= this.range.hi) {\n                // ... row is beyond viewport\n                return {\n                    size: this.size\n                }\n            } else {\n                // ... row is within viewport\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            }\n        } else if (this.currentFilter === null) {\n            // sort only\n            const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n            const [[colIdx]] = sortCols;\n            const sortRow = [idx, row[colIdx]];\n            const sorter = sortBy([[1, 'asc']]);\n            const sortPos = sortPosition(this.sortSet, sorter, sortRow, 'last-available');\n            this.sortSet.splice(sortPos, 0, sortRow);\n\n            if (sortPos >= this.range.hi) {\n                return {\n                    size: this.size\n                }\n            } else if (sortPos >= this.range.lo) {\n                return {\n                    size: this.size,\n                    replace: true\n                }\n            } else {\n                return {\n                    size: this.size,\n                    offset: this.offset - 1\n                }\n            }\n\n        } else if (this.sortCols === null) {\n            // filter only\n            const fn = filterPredicate(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                const navIdx = this.filterSet.length;\n                this.filterSet.push(idx);\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n        } else {\n            // sort AND filter\n            const fn = filterPredicate(this.columnMap, this.currentFilter);\n            if (fn(row)) {\n                // TODO what about totalCOunt\n\n                const sortCols = mapSortCriteria(this.sortCols, this.columnMap);\n                const [[colIdx]] = sortCols; // TODO multi-colun sort\n                const sortRow = [idx, row[colIdx]];\n                const sorter = sortBy([[1, 'asc']]); // TODO DSC\n                const navIdx = sortPosition(this.filterSet, sorter, sortRow, 'last-available');\n                this.filterSet.splice(navIdx, 0, sortRow);\n\n                if (navIdx >= this.range.hi) {\n                    // ... row is beyond viewport\n                    return {\n                        size: this.size\n                    }\n                } else if (navIdx >= this.range.lo) {\n                    // ... row is within viewport\n                    return {\n                        size: this.size,\n                        replace: true\n                    }\n                } else {\n                    return {\n                        size: this.size,\n                        offset: this.offset - 1\n                    }\n                }\n\n            } else {\n                return {}\n            }\n\n        }\n    }\n}\n\n// TODO need to retain and return any searchText\nexport class SetFilterRowSet extends RowSet {\n    constructor(table, columns, columnName, dataRowAllFilters, dataRowTotal) {\n        super(table, columns);        \n        this.columnName = columnName;\n        this._searchText = null;\n        this.dataRowFilter = null;\n        this.dataCounts = {\n            dataRowTotal : dataRowTotal,\n            dataRowAllFilters : dataRowAllFilters,\n            dataRowCurrentFilter : 0,\n            filterRowTotal : this.data.length,\n            filterRowSelected : this.data.length,\n            filterRowHidden : 0\n        };\n        this.sort([['value', 'asc']]);\n        this.setSelected(null);\n        this.totalCount = dataRowTotal;\n    }\n\n    get searchText() {\n        return this._searchText;\n    }\n\n    set searchText(text) {\n        // TODO\n        this.selectedCount = this.filter({ type: 'SW', colName: 'value', value: text });\n        // recalculate totalCount\n        const {filterSet, data: rows} = this;\n        let totalCount = 0;\n        const colIdx = this.columnMap.totalCount;\n        for (let i=0;i<filterSet.length;i++){\n            const row = rows[filterSet[i]];\n            totalCount += row[colIdx];\n        }\n        this.totalCount = totalCount;\n        this._searchText = text;\n    }\n\n\n    currentRange(){\n        //TODO move these into a single struct\n\n            return {\n                ...super.currentRange(),\n                //TODO is this necessary, these won't change on a range request\n                dataCounts: this.dataCounts\n            }\n    \n    }\n    \n    setRange(range, useDelta){\n\n        return {\n            ...super.setRange(range, useDelta),\n            //TODO is this necessary, these won't change on a range request\n            dataCounts: this.dataCounts\n        }\n    }\n\n    filter(filter){\n        super.filter(filter);\n\n        const {dataCounts, filterSet, data: rows, dataRowFilter, table, columnName} = this;\n        let columnFilter;\n\n        if (dataRowFilter && (columnFilter = extractFilterForColumn(dataRowFilter, columnName))){\n            const columnMap = table.columnMap;\n            const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'value'), true);\n            dataCounts.filterRowSelected = filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0) \n                \n        } else {\n            dataCounts.filterRowSelected = filterSet.length;\n        }\n\n        dataCounts.filterRowTotal = filterSet.length;\n    }\n\n    clearFilter() {\n        this.currentFilter = null;\n        this.filterSet = null;\n        this._searchText = '';\n    }\n\n\n    get values() {\n        const key = this.columnMap['value'];\n        return this.filterSet.map(idx => this.data[idx][key])\n    }\n\n    setSelected(dataRowFilter, dataRowAllFilters) {\n\n        const columnFilter = extractFilterForColumn(dataRowFilter, this.columnName);\n        const columnMap = this.table.columnMap;\n        const {dataCounts, data: rows, filterSet} = this;\n\n        this.dataRowFilter = dataRowFilter;\n        \n        if (columnFilter){\n            const fn = filterPredicate(columnMap, overrideColName(columnFilter, 'value'), true);\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.reduce((count, i) => count + (fn(rows[i]) ? 1 : 0),0) \n                : rows.reduce((count, row) => count + (fn(row) ? 1 : 0),0) \n        } else {\n            dataCounts.filterRowSelected = filterSet\n                ? filterSet.length\n                : rows.length;\n        }\n\n        dataCounts.dataRowAllFilters = dataRowAllFilters;\n\n        this.project = projectColumnsFilter(\n            columnMap,\n            this.columns,\n            this.meta,\n            columnFilter\n        );\n\n        return this.currentRange();\n\n    }\n\n}\n\nexport class BinFilterRowSet extends RowSet {\n    constructor(table, columns, columnName) {\n        super(table, columns);\n        this.type = DataTypes.FILTER_BINS;\n        this.columnName = columnName;\n    }\n\n    setSelected(filter){\n        console.log(`need to apply filter to selected BinRowset`, filter)\n    }\n    // we don't currently have a concept of range here, but it will\n    // be used in the future\n    // Note: currently no projection here, we don't currently need metadata\n    setRange() {\n        console.log(`BinFilterRowset.setRange`)\n        return {\n            type: this.type,\n            rows: this.data,\n            range: null,\n            size: this.size,\n            offset: 0\n        };\n    }\n\n}\n","// Note, these must be exported in this order and must be consumed from this file.\n// to avoid circular dependency issues.\nexport {RowSet, SetFilterRowSet, BinFilterRowSet} from './rowSet';\nexport {GroupRowSet} from './group-rowset';","/*\n    Inserts (and size records) and updates must be batched separately. Because updates are \n    keyed by index position and index positions may be affected by an insert operation, the\n    timeline must be preserved. Updates can be coalesced until an insert is received. Then\n    the update batch must be closed, to be followed by the insert(s). Similarly, multiple\n    inserts, with no interleaved updates, can be batched (with a single size record). The batch\n    will be closed as soon as the next update is received. So we alternate between update and\n    insert processing, with each transition athe preceeding batch is closed off.\n    An append is a simple insert that has no re-indexing implications.  \n\n*/\nexport default class UpdateQueue {\n\n    constructor(){\n        this._queue = [];\n    }\n\n      get length() { return this._queue.length; }\n\n      update(update) {\n          //TODO we could also coalesce updates into an insert or rowset, if present\n          const batch = this.getCurrentBatch('update');\n\n          const [rowIdx] = update;\n          const {updates} = batch;\n\n          for (let i = 0, len = updates.length; i < len; i++) {\n              if (updates[i][0] === rowIdx) {\n                  // we already have an update for this item, update the update...\n                  let d = updates[i];\n                  for (let colIdx = 1; colIdx < update.length; colIdx += 2) {\n                      const pos = d.indexOf(update[colIdx]);\n                      if (pos === -1) {// should check that it is really a colIdx,not a value\n                          d.push(update[colIdx], update[colIdx + 1]);\n                      } else {\n                          d[pos + 1] = update[colIdx + 1];\n                      }\n                  }\n\n                  return;\n              }\n          }\n          updates.push(update);\n      }\n\n      resize(size) {\n          const batch = this.getCurrentBatch('size');\n          batch.size = size;\n      }\n\n      append(row, offset) {\n          const batch = this.getCurrentBatch('insert');\n          //onsole.log(`UpdateQueue append ${row[0]}`);\n          batch.rows.push(row);\n          batch.offset = offset;\n      }\n\n      replace(rows, size, offset) {\n          const batch = this.getCurrentBatch('rowset');\n          batch.rows = rows;\n          batch.size = size;\n          batch.offset = offset;\n      }\n\n      popAll() {\n          const results = this._queue;\n          this._queue = [];\n          return results;\n      }\n\n      getCurrentBatch(type) {\n\n          const q = this._queue;\n          const len = q.length;\n\n          let batch = len === 0 || type === 'rowset'\n              ? (q[0] = createBatch(type))\n              : q[len - 1];\n\n          if (batch.type !== type) {\n              // roll size recored into subsequent insert \n              if (type === 'insert' && batch.type === 'size') {\n                  batch.type = 'insert';\n                  batch.rows = [];\n              } else if (type === 'size' && batch.type === 'insert') {\n                  // that's ok - go ahead and update size on the insert batch\n              } else {\n                  batch = (q[len] = createBatch(type));\n              }\n          }\n\n          return batch;\n\n      }\n  }\n\nfunction createBatch(type) {\n    switch (type) {\n    case 'rowset': return { type, rows: [] };\n    case 'update': return { type, updates: [] };\n    case 'insert': return { type, rows: [] };\n    case 'size': return { type };\n    default: throw Error('Unknown batch type');\n    }\n}\n","\nimport { getFilterType, toColumn, toKeyedColumn, buildColumnMap, metaData } from './store/columnUtils'\nimport { sortByToMap } from './store/sort'\nimport {\n  AND,\n  OR,\n  IN,\n  NOT_IN,\n  STARTS_WITH,\n  NOT_STARTS_WITH,\n  addFilter,\n  extractFilterForColumn,\n  getFilterColumn,\n  includesColumn,\n  removeFilterForColumn,\n  shouldShowFilter } from './store/filter';\n\n  import {\n  getFullRange,\n  resetRange,\n  NULL_RANGE as NULL } from './store/rangeUtils';\n\nimport {\n  toggleGroupState,\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby } from './store/groupUtils'\n\nimport {\n  isEmptyRow,\n  mergeAndPurge,\n  purgeAndFill,\n  update } from './store/rowUtils'\n\nimport * as types from './store/types';\n\nexport const groupHelpers = {\n  toggleGroupState,\n  updateGroupBy,\n  indexOfCol,\n  groupbyExtendsExistingGroupby\n}\n\nexport {default as Table} from './store/table';\nexport {default as InMemoryView} from './store/InMemoryView';\n\nexport const sortUtils = {\n  sortByToMap\n}\n\nexport const columnUtils = {\n  buildColumnMap,\n  getFilterType,\n  toColumn,\n  toKeyedColumn,\n  metaData\n}\n\nexport const rowUtils = {\n  isEmptyRow, mergeAndPurge, purgeAndFill, update\n}\n\nexport const filter = {\n  AND,\n  OR,\n  IN,\n  NOT_IN,\n  STARTS_WITH,\n  NOT_STARTS_WITH,\n  shouldShowFilter,\n  addFilter,\n  extractFilterForColumn,\n  removeFilterForColumn,\n  getFilterColumn,\n  includesColumn\n}\n\nexport const rangeUtils = {\n  getFullRange,\n  resetRange\n}\n\nexport const DataTypes = types.DataTypes;\n\nexport const ASC = types.ASC;\nexport const DSC = types.DSC;\nexport const NULL_RANGE = NULL;\n","import { replace, indexOf } from './utils/arrayUtils.mjs';\nimport {rangeUtils, DataTypes} from '../data/index';\nimport { metaData } from '../data/store/columnUtils';\nimport {setFilterColumnMeta} from '../data/store/columnUtils';\n\n\nconst {NULL_RANGE} = rangeUtils;\n\n//TODO can this be merged with DataRange\nexport class DataRange {\n    constructor(range = NULL_RANGE, size = 0, offset = 0, data = []) {\n        this.range = range;\n        this._size = size;\n        this.offset = offset;\n        this.data = data;\n        this.selected = null;\n        this.pendingRange = null;\n    }\n    get size(){\n        return this._size;\n    }\n    set size(val) {\n        if (typeof val !== 'number') {\n            console.error(`DataRange.size invalid value ${val}`);\n        } else {\n            if (this.data.length > val) {\n                this.data.length = val;\n            }\n            this._size = val;\n        }\n    }\n    clear() {\n        this._size = 0;\n        this.data.length = 0;\n        this.range = rangeUtils.resetRange(this.range);\n    }\n}\n\nexport default class Subscription {\n\n    // TODO need to allow for large bufferSize, so we can load entire dataset\n    constructor({ columns, range, size = 0, offset = 0 }) {\n        this.columns = columns;\n        this.meta = metaData(columns);\n        this.bufferSize = 100;\n        this._data = new DataRange(range, size, offset);\n        this._filterData = new DataRange();\n    }\n\n    get offset() { return this._data.offset; }\n    get size() { return this._data.size; }\n    set size(val) { this._data.size = val; }\n\n    reset(dataType, range = NULL_RANGE) {\n        console.log(`reset ${dataType} ${JSON.stringify(range)}`);\n        const [targetData] = this.getData(dataType);\n        targetData.data = [];\n        targetData.size = 0;\n        targetData.range = range;\n    }\n\n    putSnapshot({ size, offset, rows, range: rangeFromServer }) {\n        const { range } = this._data;\n        this._data = new DataRange(range, size, offset, rows);\n        const results = this._data.data.slice(range.lo, range.hi);\n        console.log(`[Subscription.putSnapshot] range: ${range.lo} - ${range.hi} in: ${rows.length} rows, out: ${results.length} rows`);\n        return results;\n    }\n\n    clear() {\n        this._data.clear();\n    }\n    // realign the (buffered) data set to the new range.\n    // return any rows that we already have in the buffer and that now come into range.\n    putRange({ lo, hi }, dataType = DataTypes.ROW_DATA) {\n        console.log(`[Subscription.putRange] range=${lo} - ${hi}`);\n        const [targetData, meta] = this.getData(dataType);\n        const [out, rowsInRange] = this._putRange(targetData, lo, hi, meta);\n        targetData.range = { lo, hi };\n        targetData.data = out;\n        return rowsInRange;\n    }\n\n    // this never changes the range, rows within data are already aligned to (buffered) range\n    // we need to be passed in the INDEX_OFFSET so we can detect change\n    putRows(rows, offset = 0) {\n\n        const [targetData, meta] = this.getData();\n        const results = this._putRows(targetData, rows, meta, offset);\n\n        if (offset !== targetData.offset) {\n            targetData.offset = offset;\n        }\n\n        console.log(`[Subscription.putRows] in: ${rows.length} rows, out: ${results.rowset.length} rows`);\n        return results;\n    }\n\n    putData(dataType, { type, rows: data, size }) {\n        //onsole.groupCollapsed(`Subscription.putData<${dataType}> [${data.length ? data[0][0]: null} - ${data.length ? data[data.length-1][0]: null}]`);\n        if (type === DataTypes.FILTER_BINS){\n            return {rowset: data};\n        } else {\n            const [targetData, meta] = this.getData(dataType);\n            targetData.size = size;\n            const results = this._putRows(targetData, data, meta);\n            return results;\n        }\n    }\n\n    get rowData() { return this._data; }\n    get filterData() { return this._filterData; }\n    get filterSize() { return this._filterData.size; }\n    set filterSize(val) { this._filterData.size = val; }\n\n    getData(dataType = DataTypes.ROW_DATA) {\n        return dataType === DataTypes.ROW_DATA ? [this._data, this.meta] :\n            dataType === DataTypes.FILTER_DATA ? [this._filterData, setFilterColumnMeta] :\n                [null];\n    }\n\n    _putRange(targetData, lo, hi, meta) {\n        const { data, range, offset } = targetData;\n        const {IDX} = meta;\n\n        const low = lo + offset;\n        const high = hi + offset;\n        const bufferLow = Math.max(offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const prevLow = range.lo + offset;\n        const prevHigh = range.hi + offset;\n        const len = data.length;\n        const out = [];\n        const rowsInRange = [];\n        let requiredLow;\n        let requiredHigh;\n        let row;\n        let firstRowIdx = -1;\n        let i = 0;\n\n        if (low >= prevHigh || high <= prevLow) {\n            requiredLow = low;\n            requiredHigh = high;\n        } else if (high > prevHigh) {\n            requiredLow = prevHigh;\n            requiredHigh = high;\n        } else {\n            requiredLow = low;\n            requiredHigh = prevLow;\n        }\n\n        while (row === undefined && firstRowIdx < len) {\n            firstRowIdx += 1;\n            row = data[firstRowIdx];\n        }\n\n        for (i = firstRowIdx; i < len; i++) {\n            row = data[i];\n            // Don't discard any rows if we haven't sent the range to the server.\n            // if row is undefined, we have a gap in our data. THis happens when scrolling backwards\n            // we have discarded some data when we were going forwards, but the server doesn't know\n            // that, so hasn't sent us enough data \n            if (row) {\n                let idx = row[IDX];\n\n                if (idx >= bufferHigh) {\n                    break;\n                } else if (idx >= bufferLow && idx < bufferHigh) { // ok as long as we're scrolling forwards\n                    out[idx - bufferLow] = row;\n\n                    if (idx >= requiredLow && idx < requiredHigh) {\n                        rowsInRange.push(row);\n                    }\n                }\n            }\n        }\n\n        return [out, rowsInRange];\n\n    }\n\n    _putRows(targetData, rows, meta, newOffset = 0) {\n        const { data, range, offset } = targetData;\n        const {IDX} = meta;\n        const { lo, hi } = range;\n        const low = lo + offset;\n        const high = hi + offset;\n        const bufferLow = Math.max(offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const rowset = [];\n        const updates = [];\n\n        for (let i = 0; i < rows.length; i++) {\n            let row = rows[i];\n            let idx = row[IDX];\n\n            if (lo === 0 && idx < offset) {\n                //onsole.log(`Subscription.putRows we are at the top and this.is an insert at the top`);\n                data.unshift(row); // unsafe  - temp hack only\n                rowset.push(row);\n                if (newOffset === offset) {\n                    console.warn(`Subscription.putRows would expect a lowered offset in this scenario`);\n                }\n            } else if (idx >= bufferLow && idx < bufferHigh) {\n                let rowIdx = idx - bufferLow;\n                data[rowIdx] = row;\n                if (idx >= low && idx < high) {\n                    rowset.push(row);\n                }\n            }\n        }\n\n        return { rowset, updates };\n\n    }\n\n    putUpdates(updates) {\n\n        const { lo, hi } = this._data.range;\n        const low = lo + this.offset;\n        const high = hi + this.offset;\n        const bufferLow = Math.max(this.offset, low - this.bufferSize);\n        const bufferHigh = high + this.bufferSize;\n        const updatesInRange = [];\n\n        //onsole.log(`%cSubscription.putUpdates ${updates.length} updates range = lo:${lo} hi: ${hi}`,'color:green;font-eright:bold');\n\n        for (let i = 0; i < updates.length; i++) {\n            let update = updates[i];\n            let idx = update[0];\n\n            if (idx >= bufferLow && idx < bufferHigh) {\n                let row = this._data.data[idx - bufferLow];\n\n                if (row === undefined) {\n                    console.log(`%cSubscription.putUpdates update submitted for row that is absent from buffer idx:${idx}\n                        range [${lo} - ${hi}] ==> [${low} - ${high}]\n                        buffer [${bufferLow} ${bufferHigh}]\n                        `, `color:red;font-weight:bold`);\n                } else {\n                    // keep the rows immutable, these row instances end up going to the client\n                    row = row.slice();\n                    // apply updates\n                    //onsole.log(`client.Subscription receive updates ${JSON.stringify(update)}`);\n                    for (let ii = 1; ii < update.length; ii += 2) {\n                        // should we double check that the value has actually changed ?\n                        row[update[ii]] = update[ii + 1];\n                    }\n\n                    if (idx >= low && idx < high) {\n                        updatesInRange.push(update);\n                    }\n                    this._data.data[idx - bufferLow] = row;\n                }\n\n            }\n        }\n\n        //onsole.log(`%c    ... ${updates.length} updates ${updatesInRange.length} in range `,'color:green;font-eright:bold');\n        return { updates: updatesInRange };\n\n    }\n\n    // Replace the group row with toggled group state and return it immediately to the client.\n    // We have the opportunity for more caching opportunities here - caching the \n    // child contents of grouped data.\n    toggleGroupNode(groupKey) {\n        const { KEY, DEPTH } = this.meta;\n        const idx = indexOf(this._data.data, row => row[KEY] === groupKey);\n        const groupRow = this._data.data[idx];\n        return this._data.data[idx] = replace(groupRow, DEPTH, -groupRow[DEPTH]);\n    }\n}\n","export const ServerApiMessageTypes = {\n  addSubscription: 'AddSubscription',\n  setColumns: 'setColumns'\n}\n\nexport const CONNECT = 'connect';\nexport const COLUMN_LIST = 'ColumnList';\nexport const DATA = 'data';\nexport const FILTER_DATA = 'filterData';\nexport const GROUP_BY = 'groupBy';\nexport const TABLE_LIST = 'TableList';\nexport const UNSUBSCRIBE = 'TerminateSubscription';\nexport const MODIFY_SUBSCRIPTION = 'ModifySubscription';\nexport const SUBSCRIBED = 'Subscribed';\nexport const SET_VIEWPORT_RANGE = 'setViewRange';\nexport const SORT = 'sort';\nexport const FILTER = 'filter';\nexport const SELECT = 'select';\nexport const SET_GROUP_STATE = 'setGroupState';\nexport const VIEWPORT_RANGE_CHANGED = 'ViewRangeChanged';\nexport const EXPAND_GROUP = 'ExpandGroup';\nexport const COLLAPSE_GROUP = 'CollapseGroup';\nexport const GET_FILTER_DATA = 'GetFilterData';\nexport const GET_SEARCH_DATA = 'GetSearchData';\nexport const SEARCH_DATA = 'searchData';\nexport const SNAPSHOT = 'snapshot';\n\nexport const RowData = 'rowData';\nexport const Size = 'size';\nexport const FilterData = 'filterData';\nexport const TableList = 'table-list';\nexport const ConnectionStatus = 'connection-status';\n","import Connection from './connection.mjs';\nimport Subscription from './subscription.mjs';\nimport * as Message from './messages.js';\nimport {ServerApiMessageTypes as API} from './messages.js';\nimport {DataTypes} from '../data/store/types.js';\nimport {NULL_RANGE} from '../data/store/rangeUtils.js';\n\nconst serverModule = process.env.SERVER_MODULE || '/server-api/dist/viewserver.js';\nconsole.log(`[ServerProxy] serverModule = ${serverModule}`)\nconst PLAIN = 'color: black; font-weight: normal';\nconst BLUE = 'color: blue; font-weight: bold';\nconst BROWN = 'color: brown; font-weight: bold';\nconst MSG_FROM_CLIENT = '<== C';\nconst MSG_TO_CLIENT = '==> C';\nconst MSG_TO_SERVER = '==> S';\nconst MSG_FROM_SERVER = '<== S';\n\nlet asyncServerModule;\n\nconst BUFFER_SIZE = 100;\n\nlet _windowId = 1;\n\nfunction windowId() {\n    return _windowId++;\n}\n\nconst BUFFER_ROWS = 100;\n\nfunction partition(array, test, pass = [], fail = []) {\n\n    for (let i = 0, len = array.length; i < len; i++) {\n        (test(array[i], i) ? pass : fail).push(array[i]);\n    }\n\n    return [pass, fail];\n}\n\nexport class ServerProxy {\n\n    constructor(postMessage) {\n        this.server = null;\n        this.connection = null;\n        this.connectionStatus = 'not-connected';\n\n        this.queuedRequests = [];\n        this.subscriptions = {};\n        this.pendingSubscriptionRequests = {};\n\n        Promise.resolve().then(() => {\n            console.log(`[ServerProxy.constructor]   ==> identity`);\n            postMessage({ data: { type: 'identify', clientId: windowId() } });\n        });\n\n        // tidy this up\n        this.postMessage = message => {\n            print(message.data, MSG_TO_CLIENT);\n            postMessage(message);\n        }\n\n    }\n\n    toString(){\n        return `ServerProxy: ${this.connectionStatus}`\n    }\n\n    handleMessageFromClient(message) {\n\n        const { type, viewport } = message;\n        const isReady = this.connectionStatus === 'ready';\n        let subscription;\n        print(message, MSG_FROM_CLIENT);\n\n        switch (type) {\n\n            case Message.CONNECT:\n                this.connect(message);\n                break;\n\n            case API.addSubscription:\n                this.subscribe(message)\n                break;\n\n            case Message.SET_VIEWPORT_RANGE:\n                //TODO drop buffering if we are scrolling faster than buffer can keep up\n                if (subscription = this.subscriptions[viewport]) {\n                    const { bufferSize } = subscription;\n                    const { range, dataType } = message;\n                    const { size, offset } = subscription[dataType];\n                    this.sendMessageToServer({\n                        type: Message.SET_VIEWPORT_RANGE,\n                        ...message,\n                        dataType,\n                        range: { ...range, bufferSize }\n                    });\n                    const rows = subscription.putRange(message.range, dataType);\n                    if (rows.length) {\n                        console.log(`%cserverProxy emit<${dataType}> rows from cache ${rows.length ? rows[0][0]: null} - ${rows.length ? rows[rows.length-1][0]: null}`,'color:red');\n                        // never send back selectedIndices from cache, they will often be stale\n                        this.postMessage({ data: { type: dataType, viewport, [dataType]: { data: rows, size, offset, range } } });\n                    }\n                } else {\n                    console.log(`%c setViewRange, no subscription`,'background-color: brown;color: cyan')\n                    this.queuedRequests.push(message);\n                }\n\n                break;\n\n            case Message.EXPAND_GROUP:\n            case Message.COLLAPSE_GROUP:\n\n                this.sendIfReady(message, this.connectionStatus === 'ready');\n\n                if (subscription = this.subscriptions[viewport]) {\n                    const groupRow = subscription.toggleGroupNode(message.groupKey);\n                    const {IDX, DEPTH} = subscription.meta;\n                    const updates = [[groupRow[IDX], DEPTH, groupRow[DEPTH]]];\n                    this.postMessage({ data: { type: 'update', viewport, updates } });\n                }\n\n                break;\n\n            case Message.UNSUBSCRIBE:\n\n                this.sendIfReady(message, isReady);\n                delete this.subscriptions[viewport];\n\n                break;\n\n            case Message.GROUP_BY:\n                if (subscription = this.subscriptions[viewport]) {\n                    subscription.clear();\n                }\n            case Message.SET_GROUP_STATE:\n            case Message.TABLE_LIST:\n            case Message.COLUMN_LIST:\n            case Message.SORT:\n            case Message.FILTER:\n            case Message.SELECT:\n                this.sendIfReady(message, isReady);\n\n                break;\n\n            case Message.GET_FILTER_DATA:\n                //TODO expand range, so we prepopulate subscription cache\n                // console.log(`%c>>>${new Date().toISOString().slice(11,23)} handleMesageFromClient '${Message.GET_FILTER_DATA}' `, 'color:green;font-weight:bold');\n                this.sendIfReady(message, isReady);\n                if (subscription = this.subscriptions[viewport]) {\n                    subscription.reset(DataTypes.FILTER_DATA, message.range);\n                }\n                break;\n\n            case Message.MODIFY_SUBSCRIPTION:\n\n                if (subscription = this.subscriptions[viewport]) {\n\n                    this.sendIfReady(message, isReady);\n\n                    if (message.sortCriteria) {\n                        subscription.reset(DataTypes.ROW_DATA, message.range);\n                    } else if (message.range) {\n                        subscription.putRange(message.range);\n                    }\n\n                    // We should store all chnaged attributes on the subscription here. There will be times\n                    // when we need to know the attributes of the subscription in order to correctly\n                    // interpret the data received.\n                    if (message.groupBy) {\n                        subscription.groupBy = message.groupBy;\n                    }\n                }\n\n                break;\n\n            default:\n                console.warn(`%cServerProxy.handleMesageFromClient NOT HANDLED ${JSON.stringify(message)}`, 'background-color:green;color:white');\n\n        }\n\n    }\n\n    sendIfReady(message, isReady) {\n        if (isReady) {\n            this.sendMessageToServer(message);\n        } else {\n            this.queuedRequests.push(message);\n        }\n\n        return isReady;\n\n    }\n\n    // if we're going to support multiple connections, we need to save them against connectionIs\n    connect({connectionString, connectionId=0}) {\n\n        console.log(`[ServerProxy.connect] connectionString: ${connectionString} connectionId: ${connectionId}`)\n        this.connectionStatus = 'connecting';\n\n        const module = asyncServerModule ||\n            (asyncServerModule = import(/* webpackIgnore: true */ serverModule)\n                .catch(err => console.log(`failed to load server ${err}`)))\n\n        module.then(serverModule => {\n            const Server = serverModule.default;\n            const server = this.server = new Server();\n\n            Connection.connect(connectionString).then(connection => {\n                // shouldn't we read connection status from the connection object itself\n                this.connection = connection;\n\n                // call the server to group messages by viewport, then invoke each batch with the subscription for that viewport\n                connection.on('message', (evtName, msg) => {\n                    return this.receiveMessageFromServer(msg);\n                });\n\n                if (server.connectionPipeline) {\n                    const [first, ...rest] = server.connectionPipeline;\n                    rest.reduce((result, next) => result\n                        .then(next), first(connection))\n                        .then(() => this.onReady(connectionId));\n                } else {\n                    this.onReady(connectionId);\n                }\n\n            });\n\n        });\n    }\n\n    subscribe(/* client message */ message ){\n        const isReady = this.connectionStatus === 'ready';\n        const { viewport } = message;\n\n        if (message) {\n            const byTypeAndViewport = msg => msg.viewport === viewport && msg.type === Message.SET_VIEWPORT_RANGE;\n            const [rangeMessages] = partition(this.queuedRequests, byTypeAndViewport);\n\n            const { range = NULL_RANGE } = message;\n            this.pendingSubscriptionRequests[viewport] = message;\n            console.log(`%c SUBSCRIBE to ${viewport} \n                with range ${range.lo} = ${range.hi} stored\n                        range ${range.lo} = ${range.hi === 0 ? 10 : range.hi} sent to server\n                        we have ${rangeMessages.length} range messages\n\n                ${JSON.stringify(this.queuedRequests,null,2)}`,'background-color: brown;color: cyan')\n                console.log(message)\n\n            this.sendIfReady({\n                ...message,\n                range: {\n                    lo: 0,\n                    hi: range.hi || 10, // where should this come from. This will cause key errors if bigger than viewport\n                    bufferSize: BUFFER_SIZE\n                }\n            }, isReady);\n        }\n\n    }\n\n    subscribed(/* server message */ message){\n        const {viewport} = message;\n        if (this.pendingSubscriptionRequests[viewport]) {\n\n            const { size, offset } = message;\n            const request = this.pendingSubscriptionRequests[viewport];\n            // const {table, columns, sort, filter, groupBy} = request;\n            let { range, columns } = request;\n            console.log(`%c[ServerProxy.handleMessageFromServer] SUBSCRIBED create subscription range ${range.lo} - ${range.hi}`,'background-color: yellow')\n            const subscription = this.subscriptions[viewport] = new Subscription({\n                columns,\n                range,\n                size,\n                offset,\n            });\n\n            this.pendingSubscriptionRequests[viewport] = undefined;\n\n            const byViewport = vp => item => item.viewport === vp;\n            const byMessageType = msg => msg.type === Message.SET_VIEWPORT_RANGE;\n            const [messagesForThisViewport, messagesForOtherViewports] = partition(this.queuedRequests, byViewport(viewport));\n            const [rangeMessages, otherMessages] = partition(messagesForThisViewport, byMessageType);\n\n            this.queuedRequests = messagesForOtherViewports;\n            rangeMessages.forEach(msg => {\n\n                range = msg.range;\n\n                const rows = subscription.putRange(range);\n\n                if (rows.length) {\n                    // is it ever likely that we will have data immediately following subscription ?\n                    //onsole.log(`ServerProxy.subscribed ${rows.length} rows in range, following queued message handling`);\n                    this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { data: rows, size } } });\n                }\n\n            });\n\n            if (otherMessages.length) {\n                console.log(`we have ${otherMessages.length} messages still to process`);\n            }\n\n            // send a widened range request to populate buffer\n            this.sendMessageToServer({\n                type: Message.SET_VIEWPORT_RANGE,\n                dataType: DataTypes.ROW_DATA,\n                viewport,\n                range: {\n                    lo: Math.max(0, range.lo - BUFFER_ROWS),\n                    hi: range.hi + BUFFER_ROWS\n                }\n            });\n\n        }\n\n    }\n\n    onReady(connectionId){\n        this.connectionStatus = 'ready';\n        // messages which have no dependency on previous subscription\n        console.log(`%c onReady ${JSON.stringify(this.queuedRequests)}`,'background-color: brown;color: cyan')\n\n        const byReadyToSendStatus = msg => msg.viewport === undefined || msg.type === API.addSubscription;\n        const [readyToSend, remainingMessages] = partition(this.queuedRequests, byReadyToSendStatus);\n        // TODO roll setViewRange messages into subscribe messages\n        readyToSend.forEach(msg => this.sendMessageToServer(msg));\n        this.queuedRequests = remainingMessages;\n        this.postMessage({ data: { type: 'connection-status', status: 'ready', connectionId } });\n    }\n\n    sendMessageToServer(message) {\n        const { clientId } = this.connection;\n        const { requestId = this.connection.nextRequestId() } = message;\n        const serverMessage = this.server.serialize(message, clientId, requestId);\n        if (serverMessage === null) {\n            console.warn(`[ServerProxy sendMessageToServer] ${JSON.stringify(message)} not supported by server`);\n        } else {\n            print(message, MSG_TO_SERVER);\n            this.connection.send(serverMessage);\n        }\n    }\n\n    receiveMessageFromServer(message) {\n\n        // onsole.groupCollapsed(`receiveMessageFromServer`);\n        // onsole.log(message);\n        // onsole.groupEnd();\n        print(message, MSG_FROM_SERVER);\n        const { messageHandlers = {}, customMessageTypes = {} } = this.server;\n\n        // feels wrong to pass all subscriptions to server here - should really pass just the subscription\n        // for the message. But as a payload can include messages for more than one subscription, we would\n        // first have to ask server to group the messages by viewport. Some messages are not associated\n        // with any viewport\n        const messageFromServer = this.server.deserialize(message, this.subscriptions);\n        if (messageFromServer) {\n\n            const { type } = messageFromServer;\n\n            // messages that can be handled entirely by the server - e.g. Heartbeat\n            if (messageHandlers[type]) {\n                messageHandlers[type](this.connection, message);\n            } else if (customMessageTypes[type]) {\n                // can be used to chain message requests/responses e.g. a server initiating a LOGIN \n                // request can reister a listener for the LOGIN_RESPONSE\n                this.connection.emit(type, message);\n            } else {\n                this.handleMessageFromServer(messageFromServer);\n            }\n        } else {\n            console.log(`unable to deserialize message ${JSON.stringify(message)}`);\n        }\n\n    }\n\n    handleMessageFromServer(message) {\n\n        let subscription;\n        const { type, viewport } = message;\n\n        switch (type) {\n\n            case Message.DATA:\n\n                this.processData(message.data);\n\n                break;\n\n            case Message.SNAPSHOT:\n                if (subscription = this.subscriptions[viewport]) {\n                    const { data } = message;\n                    const rows = subscription.putSnapshot(data);\n                    if (rows.length) {\n                        this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { ...data, data: rows } } });\n                    }\n                }\n                break;\n\n            case Message.SUBSCRIBED:\n                this.subscribed(message);\n                break;\n\n            case Message.FILTER_DATA:\n            case Message.SEARCH_DATA:\n\n                if (subscription = this.subscriptions[viewport]) {\n                    const { filterData } = message;\n\n                    const { rowset: data } = subscription.putData(type, filterData);\n\n                    // if (dataType === DataTypes.FILTER_BINS){\n                    //     this.postMessage( {\n                    //         data: {\n                    //             type: DataTypes.FILTER_BINS,\n                    //             viewport,\n                    //             [dataType]: filterData\n                    //         }\n                    //     } );\n\n                    /*} else */ if (data.length || filterData.size === 0) {\n                        this.postMessage({\n                            data: {\n                                type,\n                                viewport,\n                                [type]: {\n                                    ...filterData,\n                                    data\n                                }\n                            }\n                        });\n                    }\n                }\n\n                break;\n\n            default:\n                this.postMessage({ data: message });\n\n        }\n\n    }\n\n    // data is an array of batches where each batch contains the set of \n    // data updates for one viewport\n    processData(data) {\n        data.forEach(batch => {\n\n            const { viewport, size, offset, rows, updates: rowUpdates } = batch;\n            const subscription = this.subscriptions[viewport];\n\n            if (subscription === undefined) {\n                console.warn(`ServerProxy.processData no subscription for viewport ${viewport}`);\n            } else {\n                const lastSize = subscription.size;\n\n                if (typeof size === 'number') {\n                    subscription.size = size;\n                }\n                //TODO rows should be bundled into a data structure with range, offset, selected, like filter and search results\n                let { rowset, updates } = rows\n                    ? subscription.putRows(rows, offset)\n                    : subscription.putUpdates(rowUpdates);\n\n                if (rowset && rowset.length) {\n                    const { range } = subscription.rowData;\n                    this.postMessage({ data: { type: DataTypes.ROW_DATA, viewport, rowData: { data: rowset, size, range, offset } } });\n\n                } else if (updates && updates.length) {\n                    this.postMessage({ data: { type: 'update', viewport, updates, size } });\n                } else if (size !== undefined && size !== lastSize) {\n                    // size undefined if we have received an update where no updated rows are in the viewport\n                    // post a size update - only the scrollbar will reflect the change\n                    this.postMessage({ data: { type: 'size', viewport, size } });\n                }\n\n            }\n\n        });\n\n    }\n\n}\n\nfunction print(message, direction, method=null){\n    const color = direction === MSG_FROM_SERVER || direction === MSG_TO_CLIENT ? BLUE : BROWN;\n    console.log(`%c[ServerProxy${method === null ? '' : '.' + method}] %c${direction}  ${message.type} %c${messageToString(message, direction)}`, PLAIN, color, PLAIN, color, PLAIN);\n}\n\nfunction messageToString(message, direction){\n    const {requestId='', viewport=''} = message;\n    switch (message.type){\n        case Message.SET_VIEWPORT_RANGE:\n            return `${requestId} range: %c${message.range.lo} - ${message.range.hi} %cvp ${viewport}`;\n        case API.addSubscription:\n        case Message.SUBSCRIBED:\n            return `${requestId} vp:${message.viewport}`;\n        case 'rowset':\n        case Message.SNAPSHOT:\n            return `${message.data.rows.length} of ${message.data.size} rows`;\n        case Message.RowData:\n            return `${message.rowData.data.length} of ${message.rowData.size} rows`;\n        case Message.FILTER_DATA:\n            if (message.data){\n                console.table(message.data.rows)\n            }\n            return `${(message.data || message.filterData).rows.length} of %c${(message.data || message.filterData).size} rows`;\n        default:\n            return '';\n    }\n}\n","\nimport {ServerProxy} from './serverProxy.mjs';\n\nexport default class WebWorker {\n\n    //TODO allow connectionString to be passed in constructor\n    constructor() {\n        console.log(`WebWorker.constructor`)\n        this._server = new ServerProxy(message => this._onmessage(message));\n    }\n\n    postMessage(message){\n        this._server.handleMessageFromClient(message);\n    }\n\n    _onmessage(message){\n        console.log(`message received from worker, no client is listening ${JSON.stringify(message)}`);\n    }\n\n    set onmessage(handler) {\n        this._onmessage = handler;\n    }\n\n    terminate(){\n        console.log(`terminate worker`);\n    }\n\n}\n\nconsole.log(`>>>> The webworker script has loded`);\n "],"names":["DataTypes","types.DataTypes","NULL_RANGE","partition","Message.CONNECT","API","Message.SET_VIEWPORT_RANGE","Message.EXPAND_GROUP","Message.COLLAPSE_GROUP","Message.UNSUBSCRIBE","Message.GROUP_BY","Message.SET_GROUP_STATE","Message.TABLE_LIST","Message.COLUMN_LIST","Message.SORT","Message.FILTER","Message.SELECT","Message.GET_FILTER_DATA","Message.MODIFY_SUBSCRIPTION","Message.DATA","Message.SNAPSHOT","Message.SUBSCRIBED","Message.FILTER_DATA","Message.SEARCH_DATA","Message.RowData"],"mappings":"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"}